 window.addEventListener("keydown", function(e) {
    if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
}, false);
 
 document.querySelector('#spaceInvaders').addEventListener('click', () => {  
            
            const scoreEl = document.querySelector("#scoreEl")
            const canvas = document.querySelector("canvas")
            const c = canvas.getContext('2d')
            const ctx = canvas.getContext('2d')
            
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            
            if (canvas.width > 1024 / .6) {
                canvas.width = 1024 /.6
            }
            if (canvas.height > 576 / .6) {
                canvas.height = 576 / .6
            }

            defaultWidth = 1024
            defaultHeight = 576

            scalingRatioWidth = defaultWidth / canvas.width
            scalingRatioHeight =  defaultHeight / canvas.height
            widthCapped = scalingRatioWidth
            heightCapped = scalingRatioHeight

            if (scalingRatioWidth<1) {
                widthCapped = 1
            }
            if (scalingRatioHeight<1) {
                heightCapped = 1
            }

            planetNumbers = Math.floor((Math.random() * 78)) + 1
            planet2Numbers = Math.floor((Math.random() * 78)) + 1

            backgroundNumbers = Math.floor(Math.random() * 70) + 1
            backgroundMusic =  Math.floor(Math.random() * 10) + 1

            randomPlanetSize = ((Math.random() * 100) + 150) / scalingRatioWidth
            randomPlanetSize2 = ((Math.random() * 100) + 150) / scalingRatioWidth

            planetChance = Math.floor(Math.random() * 10)

            randomWidth = (Math.random() * canvas.width*.8) 
            randomHeight = (Math.random() * canvas.height*.8) 

            randomWidth2 = (Math.random() * canvas.width*.6) 
            randomHeight2 = (Math.random() * canvas.height*.6) 

            planet1Active = false
            planet2Active = false

            const bgplanet = new Image();
            const bgplanet2 = new Image();

            if (planetChance <= 80) 
                planet1Active = true
                
            if (planetChance <= 20) 
                planet2Active = true

            bgplanet2.src = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/planets/planet' + planetNumbers + '.png' 
            bgplanet.src = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/planets/planet' + planet2Numbers + '.png' 


            const bgimg = new Image();
            bgimg.src = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/backgrounds/spacebg' + backgroundNumbers + '.png';



         
           /*  const audio = {
                backgroundMusic: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/ETHinvaderOST/track' + backgroundMusic + '.mp3?raw=true',
                loop: true
                }),


                bomb: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/bomb.mp3?raw=true'
                }),

                bonus: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/bonus.mp3?raw=true',
                volume: 0.8
                }),
                enemyShoot: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/enemyShoot.wav?raw=true'
                }),
                explode: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/explode.wav?raw=true'
                }),
                gameOver: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/gameOver.mp3?raw=true'
                }),
                select: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/select.mp3?raw=true'
                }),
                shoot: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/shoot.wav?raw=true',
                volume: .5
                }),
                start: new Howl({
                src: 'https://github.com/ETHinvaders/ETHinvader_Files/blob/main/audio/start.mp3?raw=true'
                })
            }

 */
            class Player {
                constructor() {

                    this.velocity = {
                        x: 0,
                        y: 0
                    }

                    this.rotation = 0
                    this.opacity = 1
                    this.powerUp = ''
                    const image = new Image()
                    image.src = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/spaceship.png'
                    image.onload = () => {
                        const scale = .5 / widthCapped
                        this.image = image
                        this.width = image.width * scale
                        this.height = image.height * scale
                        this.position = {
                            x: canvas.width / 2 - this.width /2,
                            y: canvas.height - this.height - 20
                        }
                    }

                    this.particles = []
                    this.frames = 0

                }

                draw() {
                    c.save()
                    c.globalAlpha = this.opacity
                    c.translate(player.position.x + player.width/2, 
                    player.position.y + player.height/2)
                    
                    c.rotate(this.rotation)

                    c.translate(-player.position.x + -player.width/2, 
                    -player.position.y + -player.height/2)

                    if (this.image)
                        c.drawImage(
                            this.image, 
                            this.position.x, 
                            this.position.y, 
                            this.width, 
                            this.height)
                    c.restore()
                }


                update() {
                    if (this.image) {
                        this.draw()
                        this.position.x += this.velocity.x
                    }

                    this.frames++
                    if (this.frames % 10 == 0) {
                        this.particles.push(new Particle({
                            position: {
                                x: this.position.x + this.width/2,
                                y: this.position.y + this.height
                            },
                            velocity: {
                                x: 0,
                                y: .4
                            },
                            radius: Math.random() * 2,
                            color: 'white',
                            fades: true
                            }))
                    }
                }
            }

            class Projectile {
                constructor({position, velocity, color='red'}) {
                    this.position = position
                    this.velocity = velocity
                    this.color = color
                    this.radius = 7 / scalingRatioWidth
                }

                draw() {
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2)
                    c.fillStyle = this.color
                    c.fill()
                    c.closePath()
                }   

                update() {
                        this.draw()
                        this.position.x += this.velocity.x * (widthCapped*.8)
                        this.position.y += this.velocity.y * (widthCapped*.8)
                }        
            }


            class Particle {
                constructor({position, velocity, radius, color, fades}) {
                    this.position = position
                    this.velocity = velocity

                    this.radius = radius / scalingRatioWidth
                    this.color = color
                    this.opacity = 1
                    this.fades = fades
                }

                draw() {
                    c.save()
                    c.globalAlpha = this.opacity
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2)
                    c.fillStyle = this.color
                    c.fill()
                    c.closePath()
                    c.restore()
                }   

                update() {
                        this.draw()
                        this.position.x += this.velocity.x
                        this.position.y += this.velocity.y
                        
                        if (this.fades) {
                            this.opacity  -= 0.01
                        }
                }        
            }

            class InvaderProjectile {
                constructor({position, velocity}) {
                    this.position = position
                    this.velocity = velocity

                    this.width = 5 / scalingRatioWidth
                    this.height = 15 / scalingRatioHeight
                }

                draw() {
                    c.fillStyle = '#FCB226'
                    c.fillRect(this.position.x, this.position.y, this.width, this.height)
                }   

                update() {
                        this.draw()
                        this.position.x += this.velocity.x
                        this.position.y += this.velocity.y
                }        
            }


            class Invader {
                constructor({position = {x: 0, y: 0}, src, hp = 1, scale = 1.3}) {

                    this.velocity = {
                        x: 0,
                        y: 0
                    }

                    this.src = src
                    this.hp = hp

                    const image = new Image()
                    image.src = src
                    image.onload = () => {
                        this.scale = scale / (scalingRatioWidth/2)
                        this.image = image
                        this.width = image.width * scale / scalingRatioWidth
                        this.height = image.height * scale / scalingRatioWidth
                        this.position = {
                            x: position.x,
                            y: position.y
                        }
                    }
                }

                draw() {

                    if (this.image)
                        c.drawImage(
                            this.image, 
                            this.position.x, 
                            this.position.y, 
                            this.width, 
                            this.height)
                }


                update({velocity}) {
                    if (this.image) {
                        this.draw()
                        this.position.x += velocity.x
                        this.position.y += velocity.y
                    }
                }

                shoot(invaderProjectiles) {
                    invaderProjectiles.push(new InvaderProjectile({
                        position: {
                            x: this.position.x + this.width/2,
                            y: this.position.y + this.height
                        },
                        velocity: {
                            x: 0,
                            y: 5 / scalingRatioWidth
                        }
                    }))
                }
            }

            class Grid {
                constructor() {
                    this.position = {
                        x: 0,
                        y: 200
                    }
                    this.velocity = {
                        x: 2,
                        y: 0
                    }
                    this.invaders = []

                    const columns = Math.floor(Math.random() * 6 + 3)
                    const rows = Math.floor(Math.random() * 4 + 2)
                    bossChance = Math.floor(Math.random() * 100 )
                    healthChance = Math.floor(Math.random() * 0 )

                    // choose sprite for invader
                    if (rows <= 2) {
                        temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader01.png'
                        this.hp = 5
                        this.velocity.x = 3 / scalingRatioWidth
                        objectSpace = (35 /widthCapped) + 50

                    } else if (columns <= 4) {
                        temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader02.png'
                        this.hp = 2
                        this.velocity.x = 1 / scalingRatioWidth
                        objectSpace = (50 /widthCapped) + 50
                    }
                    else if (!columns <= 4 && !rows <= 3) {
                        this.velocity.x = 2 / scalingRatioWidth
                        temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader.png'
                        objectSpace = (25 /widthCapped) + 50
                        if (frames % 2) {
                            temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader05.png'
                            objectSpace = (45 /widthCapped) + 50
                        }
                    }

                    
                    this.width = columns * objectSpace / scalingRatioWidth

                    // console.log('boss' + bossChance)
                    // console.log('health' + healthChance)
                    if (bossChance <= 92) {
                        for (let x = 0; x< columns; x++) {
                            for (let y = 0; y< rows; y++) {
                                this.invaders.push(new Invader({position: {
                                    x: x * (objectSpace /widthCapped),
                                    y: y * 30 / widthCapped
                                },
                                src: temp
                            }
                            ))
                        }
                        }
                    }   else {
                        temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader03.png'
                        this.velocity.x = .65 /scalingRatioWidth
                        this.invaders.push(new Invader({position: {
                            x:  0,
                            y:  0
                        },
                        src: temp,
                        hp: 50,
                        scale: 1
                    }
                    ))
                    }
                    
                    if (healthChance >= 6) {
                        temp = 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/random/healthpack.png'
                        this.velocity.x = .65 /scalingRatioWidth
                        this.invaders.push(new Invader({position: {
                            x:  Math.floor(Math.random() * 800),
                            y:  Math.floor(Math.random() * 200)
                        },
                        src: temp,
                    }
                    ))
                    }
                    objectSpace = 30 / scalingRatioWidth
                }


                update() {
                    this.position.x += this.velocity.x
                    this.position.y += this.velocity.y

                    this.velocity.y = 0

                    if (this.position.x + this.width*.8 >= canvas.width || this.position.x <= 0) {
                        this.velocity.x = -this.velocity.x
                        this.velocity.y = 30 /scalingRatioHeight
                    }
                }
            }

            class PowerUp {
                constructor({position, velocity, color='yellow'}) {
                    this.position = position
                    this.velocity = velocity
                    this.color = color
                    this.radius = 25 /scalingRatioWidth
                }

                draw() {
                    c.beginPath()
                    c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2)
                    c.fillStyle = 'yellow'
                    c.fill()
                    c.closePath()
                }   

                update() {
                        this.draw()
                        this.position.x += this.velocity.x
                        this.position.y += this.velocity.y
                }        
            }

            class Bomb {
                static radius = 45 /scalingRatioWidth
                constructor({ position, velocity}) {
                this.position = position
                this.velocity = velocity
                this.radius = 45 /scalingRatioWidth
                this.color =  'red'
                this.opacity = 1
                this.active = false
            
                gsap.to(this, {
                    radius: 45 /scalingRatioWidth
                })
                }
            
                draw() {
                c.save()
                c.globalAlpha = this.opacity
                c.beginPath()
                c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2)
                c.closePath()
                c.fillStyle = this.color
                c.fill()
                c.restore()
                }
            
                update() {
                this.draw()
                this.position.x += this.velocity.x
                this.position.y += this.velocity.y
            
                if (
                    this.position.x + this.radius + this.velocity.x >= canvas.width ||
                    this.position.x - this.radius + this.velocity.x <= 0
                ) {
                    this.velocity.x = -this.velocity.x
                } else if (
                    this.position.y + this.radius + this.velocity.y >= canvas.height ||
                    this.position.y - this.radius + this.velocity.y <= 0
                )
                    this.velocity.y = -this.velocity.y
                }

                explode() {
                    // audio.bomb.play()
                    this.active = true
                    this.velocity.x = 0
                    this.velocity.y = 0
                    gsap.to(this, {
                        radius: 200 /scalingRatioWidth,
                        color: 'white'
                    })
                
                    gsap.to(this, {
                        delay: 0.1,
                        opacity: 0,
                        duration: 0.15
                    })

                }

            }
            
            function init() {
               
                player = new Player()
                projectiles = []
                grids = []
                invaderProjectiles = []
                particles = []
                deaths = []
                powerUps = []
                keys = {
                a: {
                    pressed: false
                },
                d: {
                    pressed: false
                },
                space: {
                    pressed: false
                }, 
                p: {
                    pressed: false
                },
                m: {
                    pressed: false
                }
                }


                playerDeaths = 0
                frames = 0
                randomInterval = Math.floor(Math.random() * 500 + 500)
                game = {
                    over: false,
                    active: true
                }
                score = 0

                for (let i = 0; i < 100; i++) {
                    particles.push(
                    new Particle({
                        position: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                        },
                        velocity: {
                        x: 0,
                        y: 0.3
                        },
                        radius: Math.random() * 2,
                        color: 'white'
                    })
                    )
                }
            }

            let particles = []
            let bombs = []
            let frames = 0
            let randomInterval = Math.floor((Math.random() * 800) + 300)
            let game = {
                over: false,
                active: true
            }

            let moveLeft = 'false'
            let moveRight = 'false'
            let keyPressed = 'false'
            let muteSound = ''

            let score = 0
            let temp = ''
            let particleColor = ''
            let objectSpace = 30
            let playerDeaths = 0
            let bossChance = 0
            let healthChance = 0
            let runningRNG = Math.floor(Math.random() * 100000)
            let paused = 'false'
            let mouseDown = 'false'
            

            for (let i = 0; i < 100; i++) {
                particles.push(new Particle({
                    position: {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    },
                    velocity: {
                        x: 0,
                        y: .4
                    },
                    radius: (Math.random() * .8) /scalingRatioWidth,
                    color: 'white'
                    })
                )
            }


            function endGame() {
                console.log('you lose')
                // audio.gameOver.play()

                // Makes player disappear
                setTimeout(() => {
                    player.opacity = 0
                    game.over = true
                }, 0)

                // stops game altogether
                setTimeout(() => {
                    game.active = false
                    document.querySelector('#restartScreen').style.display = 'flex'
                }, 2000)

                createParticles({
                    object: player,
                    color: 'white',
                    fades: true
                })
            
   
            }


            function createParticles({object, color, fades, size = 3}) {
                for (let i = 0; i < 15; i++) {
                    particles.push(new Particle({
                        position: {
                            x: object.position.x + object.width/2,
                            y: object.position.y + object.height/2
                        },
                        velocity: {
                            x: (Math.random() - 0.5) * 2,
                            y: (Math.random() - 0.5) * 2
                        },
                        radius: (Math.random() * size) /scalingRatioWidth,
                        color: color || '#BAA0DE',
                        fades: true,
                        })
                    )
                    }
            }

            function animate() {
                if (!game.active) return

                requestAnimationFrame(animate)
                c.drawImage(bgimg, 0, 0, bgimg.width/widthCapped, bgimg.height/heightCapped, 0, 0, canvas.width, canvas.height)


                // RENDERS PLANETS
                if (planet1Active) {
                    c.drawImage(bgplanet, randomWidth, randomHeight, randomPlanetSize, randomPlanetSize) 
                } 

                if (planet2Active) {
                    c.drawImage(bgplanet2, randomWidth2, randomHeight2, randomPlanetSize2, randomPlanetSize2) 
                } 

                // healthbar
                currentHealth = (((canvas.width/3)  * scalingRatioWidth) - playerDeaths*5.35)

                if (playerDeaths < 15 && !game.over) {
                    c.fillStyle = 'green'
                    c.fillRect(canvas.width - 380, canvas.height - 40, currentHealth, canvas.height/30)
                } else if (playerDeaths < 35 && !game.over) {
                    c.fillStyle = 'yellow'
                    c.fillRect(canvas.width - 380, canvas.height - 40, currentHealth, canvas.height/30)
                } else if (playerDeaths <= 60 && !game.over) {
                    c.fillStyle = 'red'
                    c.fillRect(canvas.width - 380, canvas.height - 40, currentHealth, canvas.height/30)
                }



                // spawns bombs
                if (runningRNG < 90000 && runningRNG > 99900 && bombs.length < 2) {
                    bombs.push(
                    new Bomb({
                        position: {
                        x: Math.random() *  canvas.width,
                        y: Math.random() *  canvas.height/1.5
                        },
                        velocity: {
                        x: (Math.random() - 0.5) * (6 / scalingRatioWidth),
                        y: (Math.random() - 0.5) * (6 / scalingRatioWidth)
                        }
                    })
                    )
                }

                // update() renders bombs to screen
                for (let i = bombs.length - 1; i >= 0; i--) {
                    const bomb = bombs[i]
                    
                    if (bomb.opacity <= 0) {
                    bombs.splice(i, 1)
                    } else bomb.update()
                }

                
                
                for (let i = powerUps.length - 1; i >= 0; i--){
                    const powerUp = powerUps[i]

                    if (powerUp.position.x - powerUp.radius >= canvas.width)
                        powerUps.splice(i,1)
                    if (powerUp.position.y + powerUp.radius >= canvas.height)
                        powerUps.splice(i,1)
                    if (powerUp.position.y <= 0)
                        powerUps.splice(i,1)
                    else
                        powerUp.update()

            
                }

                // gives trailing particle effect for player spaceship
                player.update()
                for (let i = player.particles.length - 1; i >= 0; i--){
                    const particle = player.particles[i]
                    particle.update()
                }


                // update() renders all particles
                particles.forEach((particle, i) => {

                    if (particle.position.y - particle.radius >= canvas.height) {
                        particle.position.x = Math.random() * canvas.width
                        particle.position.y = -particle.radius
                    }

                    if (particle.opacity <= 0) {
                        setTimeout(() => {
                            particles.splice(i,1)
                        }, 0)
                    } else {
                        particle.update()
                    }
                })


                // loop through projectiles to detect for collision
                invaderProjectiles.forEach((invaderProjectile, index) => {
                    if (invaderProjectile.position.y + invaderProjectile.height >= canvas.height) {
                        setTimeout(() => {
                            invaderProjectiles.splice(index, 1)
                        }, 0)          
                    }   else  invaderProjectile.update()

                    // projectile hits player
                    if (invaderProjectile.position.y + invaderProjectile.height >= player.position.y
                        && invaderProjectile.position.x + invaderProjectile.width >= player.position.x
                        && invaderProjectile.position.x <= player.position.x + player.width) {
                            
                            createParticles({
                                object: player,
                                color: 'white',
                                fades: true
                            })

                            if (player.powerUp != 'MachineGun'){
                                playerDeaths += 15
                            }

                            // audio.explode.play()
                            invaderProjectiles.splice(index, 1)

                            if (playerDeaths >=  50) {
                                console.log('you lose')
                                endGame()
    
                            }
                    }
                })


                projectiles.forEach((projectile, index) => {


                    // if projectile touches bomb, remove projectile
                    for (let k = bombs.length - 1; k >= 0; k--) {
                        const bomb = bombs[k]
                            
                        if (
                            Math.hypot(
                            projectile.position.x - bomb.position.x,
                            projectile.position.y - bomb.position.y
                            ) <
                            projectile.radius + bomb.radius &&
                            !bomb.active
                            ) {
                            projectiles.splice(index, 1)
                            bomb.explode()
                            bomb.active == 'true'
                            }
                        }


                    // if projectile touches powerUp, remove projectile
                    for (let j = powerUps.length - 1; j >= 0; j--) {
                        const powerUp = powerUps[j]
                
                        if (
                        Math.hypot(
                            projectile.position.x - powerUp.position.x,
                            projectile.position.y - powerUp.position.y
                        ) <
                        projectile.radius + powerUp.radius
                        ) {
                        projectiles.splice(index, 1)
                        powerUps.splice(j, 1)
                        player.powerUp = 'MachineGun'
                        //   console.log(player.powerUp)
                        console.log('powerup started')
                        // audio.bonus.play()
                
                        setTimeout(() => {
                            player.powerUp = null
                            console.log('powerup ended')
                        }, 5000)
                        }
                    }
                                


                    // garbage collection of projectiles
                    if (projectile.position.y + projectile.radius <= 0) {
                        setTimeout(() => {
                            projectiles.splice(index, 1)
                        }, 0)
                    } else {
                    projectile.update()
                    }
                })


                // spawns powerUps
                if (runningRNG > 99950) {

                    powerUps.push(new PowerUp({
                        position: {
                            x: (Math.random() * 150) / scalingRatioWidth,
                            y: (Math.random() * 150) / scalingRatioWidth
                        },
                        velocity: {
                            x: (Math.random() * 3) / scalingRatioWidth,
                            y: (Math.random() * .5) / scalingRatioWidth 
                        }
                        }))
                }

                

                grids.forEach((grid, gridIndex) => {
                    grid.update()

                    // spawning projectiles
                    if (frames % (100) == 0 && grid.invaders.length >0) {
                        grid.invaders[Math.floor(Math.random() * grid.invaders.length)].shoot(invaderProjectiles)    
                    }

                   grid.invaders.forEach((invader, i) => {
                    invader.update({velocity: grid.velocity})

                    for (let j = bombs.length - 1; j >= 0; j--) {
                        const bomb = bombs[j]
                
                        const invaderRadius = 60
                
                        // if bomb touches invader, remove invader
                        if (
                          Math.hypot(
                            invader.position.x - bomb.position.x,
                            invader.position.y - bomb.position.y
                          ) <
                            invaderRadius + bomb.radius &&
                          bomb.active
                        ) {
                          score += 50
                          scoreEl.innerHTML = score

                          playerDeaths = playerDeaths - 2
                          if (playerDeaths < 0) {
                            playerDeaths = 0
                          }

                          const scoreLabel = document.createElement('label')
                          scoreLabel.innerHTML = 50
                          scoreLabel.style.position = 'absolute'
                          scoreLabel.style.color = 'white'
                          scoreLabel.style.top = invader.position.y + 'px'
                          scoreLabel.style.left = invader.position.x + 'px' 
                          document.querySelector('#parentDiv').appendChild(scoreLabel)

                          gsap.to(scoreLabel, {
                              opacity: 0
                          })

                          grid.invaders.splice(i, 1)
                          createParticles({
                            object: invader,
                            fades: true
                          })
                        }
                      }
                        

                        // projectiles hit enemy
                        projectiles.forEach((projectile, j) => {
                            if (projectile.position.y - projectile.radius <= invader.position.y + invader.height
                                && projectile.position.x + projectile.radius >= invader.position.x
                                && projectile.position.x - projectile.radius <= invader.position.x + invader.width
                                && projectile.position.y + projectile.radius >= invader.position.y  && (frames%3)) {
                                    
                                    setTimeout(() => {
                                    const invaderFound = grid.invaders.find(invader2 => invader2 == invader)
                                    const projectileFound = projectiles.find(projectile2 => projectile2 == projectile)
                                    
                                    // remove invader and projectile
                                    if (invaderFound && projectileFound) {
                                        invaderFound.hp -= 1


                                        // set particle color for each enemy
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader.png') {
                                            particleColor = '#BAA0DE'
                                        }
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader01.png'){
                                            particleColor = '#1EDC12'
                                        } 
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader02.png') {
                                            particleColor = '#FA65D6'
                                        } 
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader03.png') {
                                            particleColor = '#D52E1A'
                                        }
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader05.png') {
                                            particleColor = 'yellow'
                                        }
                                        if (invader.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/random/healthpack.png') {
                                            particleColor = 'white'
                                        }
                                        
                                        createParticles({
                                            object: invader,
                                            fades: true,
                                            color: particleColor

                                        })


                                        // decides score to give based on which enemy the player shot
                                        if (invaderFound.hp <= 0 || invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader03.png') {
                                            projectiles.splice(j, 1)
                                            // audio.shoot.play()


                                            if (invaderFound.hp <= 0) {
                                                grid.invaders.splice(i, 1)
                                                if (playerDeaths > 0)
                                                    playerDeaths -= 1
                                                if (invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader03.png' && invaderFound.hp <= 0 ) {
                                                    score += 5000
                                                    scoreEl.innerHTML = score
                                                    // audio.explode.play()

                                                    const scoreLabel = document.createElement('label')
                                                    scoreLabel.innerHTML = 5000
                                                    scoreLabel.style.position = 'absolute'
                                                    scoreLabel.style.color = 'white'
                                                    scoreLabel.style.top = invader.position.y + 'px'
                                                    scoreLabel.style.left = invader.position.x + 'px' 
                                                    document.querySelector('#parentDiv').appendChild(scoreLabel)
                    
                                                    gsap.to(scoreLabel, {
                                                        opacity: 0
                                                    })
                    
                                                }
                                            }

                                            if (invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader02.png') {
                                                score += 300
                                                scoreEl.innerHTML = score

                                                const scoreLabel = document.createElement('label')
                                                scoreLabel.innerHTML = 300
                                                scoreLabel.style.position = 'absolute'
                                                scoreLabel.style.color = 'white'
                                                scoreLabel.style.top = invader.position.y + 'px'
                                                scoreLabel.style.left = invader.position.x + 'px' 
                                                document.querySelector('#parentDiv').appendChild(scoreLabel)
                
                                                gsap.to(scoreLabel, {
                                                    opacity: 0
                                                })
                
                                            }

                                            if (invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader01.png') {
                                                score += 200
                                                scoreEl.innerHTML = score

                                                const scoreLabel = document.createElement('label')
                                                scoreLabel.innerHTML = 200
                                                scoreLabel.style.position = 'absolute'
                                                scoreLabel.style.color = 'white'
                                                scoreLabel.style.top = invader.position.y + 'px'
                                                scoreLabel.style.left = invader.position.x + 'px' 
                                                document.querySelector('#parentDiv').appendChild(scoreLabel)
                
                                                gsap.to(scoreLabel, {
                                                    opacity: 0
                                                })
                

                                            }

                                            if (invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader.png' 
                                            || invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/invaders/invader05.png') {
                                                score += 100
                                                scoreEl.innerHTML = score

                                                const scoreLabel = document.createElement('label')
                                                scoreLabel.innerHTML = 100
                                                scoreLabel.style.position = 'absolute'
                                                scoreLabel.style.color = 'white'
                                                scoreLabel.style.top = invader.position.y + 'px'
                                                scoreLabel.style.left = invader.position.x + 'px' 
                                                document.querySelector('#parentDiv').appendChild(scoreLabel)
                
                                                gsap.to(scoreLabel, {
                                                    opacity: 0
                                                })
                

                
                                            }

                                            if (invaderFound.src == 'https://raw.githubusercontent.com/ETHinvaders/ETHinvader_Files/main/random/healthpack.png' && playerDeaths > 0) {
                                                playerDeaths -= 25
                                                if (playerDeaths <= 0) {
                                                    playerDeaths = 0
                                                }
                                                // audio.bonus.play()
                                            }   

                                            if (grid.invaders.length > 0) {
                                                const firstInvader = grid.invaders[0]
                                                const lastInvader = grid.invaders[grid.invaders.length - 1]

                                                grid.width = lastInvader.position.x - firstInvader.position.x + lastInvader.width
                                                grid.position.x = firstInvader.position.x
                                            } else {
                                                grids.splice(gridIndex, 1)
                                            }
                                        }
                                    }
                                }, 0)
                            }
                        })




                    })
                })


                // key presses to set velocity
                if (keys.a.pressed && player.position.x >= 0 || moveLeft == 'true' && player.position.x >= 0) {
                    player.velocity.x = -5 / scalingRatioWidth
                    player.rotation = -.15      
                } else if (keys.d.pressed && player.position.x + player.width <= canvas.width || moveRight == 'true' && player.position.x + player.width <= canvas.width) {
                    player.velocity.x = 5 / scalingRatioWidth
                    player.rotation = .15      
                } else {
                    player.velocity.x = 0
                    player.rotation = 0
                }

                // spawning enemies at randomInterval
                if (frames % randomInterval == 0) {
                    grids.push(new Grid())
                    randomInterval = Math.floor((Math.random() * 800) + 300)
                    frames = 0
                }

                if (keys.space.pressed && player.powerUp == 'MachineGun' && frames % 5)
                projectiles.push(
                    new Projectile({
                        position: {
                            x: player.position.x + player.width/2,
                            y: player.position.y
                        },
                        velocity: {
                            x: 0,
                            y: -10 / scalingRatioWidth
                        },
                        color: 'yellow'
                    })
                )

                frames++


                if (paused == 'false') {
                    runningRNG = Math.floor(Math.random() * 100000)
                } else {
                    runningRNG = 0
                }

                if (paused == 'false' && keys.p.pressed) {
                    paused = 'true'
                }

            }

            let keyHeld = 0 

            addEventListener('keydown', ({key}) => {
                //if (game.over) return

                switch (key) {
                    case 'm':     
                        if (keys.m.pressed = false)
                            keys.m.pressed == true
                        if (keys.m.pressed = true) 
                            keys.m.pressed == false
                        break
                    case 'p':     
                        keys.p.pressed = true
                        break
                    case 'a':     
                        keys.a.pressed = true
                        break
                    case 'd':     
                        keys.d.pressed = true
                        break
                    case ' ': 
                        keys.space.pressed = true
                        if (player.powerUp == 'MachinGun') return
                        if (keyHeld <10) {
                        projectiles.push(
                            new Projectile({
                                position: {
                                    x: player.position.x + player.width/2,
                                    y: player.position.y
                                },
                                velocity: {
                                    x: 0,
                                    y: -10 / scalingRatioWidth
                                }
                            })
                        )
                        keyHeld += 1
                        }
                        break

                }
            })

            addEventListener('keyup', ({key}) => {
                switch (key) {
                    case 'a':     
                        keys.a.pressed = false
                        break
                    case 'd':     
                        keys.d.pressed = false
                        break
                    case ' ':     
                        keys.space.pressed = false

                        keyHeld = 0
                        break
                    case 'p':     
                        keys.p.pressed = false
                        break                 
                }
        })


            document.querySelector('#startScreen').style.display = 'none'
            // audio.backgroundMusic.play()
            // audio.start.play()
            init()

            setTimeout(() => {
                    animate() // starts game
                }, 300)
            
            
            document.querySelector('#restartButton').addEventListener('click', () => {
                // audio.select.play()
                document.querySelector('#restartScreen').style.display = 'none'
                init()
                animate() // starts game
            })
        })

        var Enjine = {};

/*         canvas.width = window.innerWidth *.95
        canvas.height = window.innerWidth *.85

        if (canvas.width > 1280) {
        canvas.width = 1280
        }
        if (canvas.height > 960) {
            canvas.height = 960
        } */

        Enjine.GameCanvas = function() {
            this.Canvas = null;
            this.Context2D = null;
            this.BackBuffer = null;
            this.BackBufferContext2D = null;
        };

        Enjine.GameCanvas.prototype = {
            Initialize: function(canvasId, resWidth, resHeight) {
                this.Canvas = document.getElementById(canvasId);
                this.Context2D = this.Canvas.getContext("2d");
                this.BackBuffer = document.createElement("canvas");
                this.BackBuffer.width = resWidth;
                this.BackBuffer.height = resHeight;
                this.BackBufferContext2D = this.BackBuffer.getContext("2d");
            },
            
            BeginDraw: function() {
                this.BackBufferContext2D.clearRect(0, 0, this.BackBuffer.width, this.BackBuffer.height);
                this.Context2D.clearRect(0, 0, this.Canvas.width, this.Canvas.height);
            },
            
            EndDraw: function() {
                this.Context2D.drawImage(this.BackBuffer, 0, 0, this.BackBuffer.width, this.BackBuffer.height, 0, 0, this.Canvas.width, this.Canvas.height);
            }
        };

        Enjine.Keys = {
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 80,
            Left: 37,
            Up: 38,
            Right: 39,
            Down: 40,
            Space: 32,
            Shift: 16,
        };

        Enjine.KeyboardInput = {
            Pressed: new Array(),
            
            Initialize: function() {
                var self = this;
                document.onkeydown = function(event) { self.KeyDownEvent(event); }
                document.onkeyup = function(event) { self.KeyUpEvent(event); }
            },
            
            IsKeyDown: function(key) {
                if (this.Pressed[key] != null)
                    return this.Pressed[key];
                return false;
            },
            
            KeyDownEvent: function(event) {
                this.Pressed[event.keyCode] = true;
            this.PreventScrolling(event);
            },
            
            KeyUpEvent: function(event) {
                this.Pressed[event.keyCode] = false;
            this.PreventScrolling(event);
            },

            PreventScrolling: function(event) {
                // 37: left, 38: up, 39: right, 40: down
                if(event.keyCode >= 37 && event.keyCode <= 40){
                    event.preventDefault();
                }
            }
        };

        Enjine.Resources = {
        Images: {},
        Sounds: {},

        Destroy: function() {
            delete this.Images;
            delete this.Sounds;
            return this;
        },
        
        //***********************/
        //Images
        AddImage: function(name, src) {
            var tempImage = new Image();
            this.Images[name] = tempImage;
            tempImage.src = src;
            return this;
        },
        
        AddImages: function(array) {
            for (var i = 0; i < array.length; i++) {
                var tempImage = new Image();
                this.Images[array[i].name] = tempImage;
                tempImage.src = array[i].src;
            }
            return this;
        },
        
        ClearImages: function() {
            delete this.Images;
            this.Images = new Object();
            return this;
        },
        
        RemoveImage: function(name) {
            delete this.Images[name];
            return this;
        },
        
        //***********************/
        //Sounds
        AddSound: function(name, src, maxChannels) {
            this.Sounds[name] = [];
            this.Sounds[name].index = 0;
            if (!maxChannels) {
                maxChannels = 3;
            }
            for (var i = 0; i < maxChannels; i++) {
                this.Sounds[name][i] = new Audio(src);	
            }
            return this;
        },
        
        ClearSounds: function() {
            delete this.Sounds;
            this.Sounds = {};
            return this;
        },
        
        RemoveSound: function(name) {
            delete this.Sounds[name];
            return this;
        },
        
        PlaySound: function(name, loop) {
            if (this.Sounds[name].index >= this.Sounds[name].length) {
                this.Sounds[name].index = 0;	
            }
            if (loop) {
                this.Sounds[name][this.Sounds[name].index].addEventListener("ended", this.LoopCallback, false);
            }
            this.Sounds[name][this.Sounds[name].index++].play();
            return this.Sounds[name].index;
        },
        
        PauseChannel: function(name, index) {
            if (!this.Sounds[name][index].paused) {
                this.Sounds[name][index].pause();
            }
            return this;
        },
        
        PauseSound: function(name) {
            for (var i = 0; i < this.Sounds[name].length; i++) {
                if (!this.Sounds[name][i].paused) {
                    this.Sounds[name][i].pause();
                }
            }
            return this;
        },
        
        ResetChannel: function(name, index) {
            this.Sounds[name][index].currentTime = 0;
            this.StopLoop(name, index);
            return this;
        },
        
        ResetSound: function(name) {
            for (var i = 0; i < this.Sounds[name].length; i++) {
                this.Sounds[name].currentTime = 0;
                this.StopLoop(name, i);
            }
            return this;
        },
        
        StopLoop: function(name, index) {
            this.Sounds[name][index].removeEventListener("ended", this.LoopCallback, false);	
        },
        
        LoopCallback: function() {
            this.currentTime = -1;
            this.play();
        }
    };

        Enjine.Drawable = function() {
            this.ZOrder = 0;
        };

        Enjine.Drawable.prototype = {
            Draw: function(context) { }
        };

        Enjine.GameStateContext = function(defaultState) {
            this.State = null;
            
            if (defaultState != null) {
                this.State = defaultState;
                this.State.Enter();
            }
        };

        Enjine.GameStateContext.prototype = {
            ChangeState: function(newState) {
                if (this.State != null) {
                    this.State.Exit();
                }
                this.State = newState;
                this.State.Enter();
            },
            
            Update: function(delta) {
                this.State.CheckForChange(this);
                this.State.Update(delta);
            },
            
            Draw: function(delta) {
                this.State.Draw(delta);
            }
        };

        /**
         * Base game state class to at least ensure that all the functions exist.
         */ 
        Enjine.GameState = function() { }

        Enjine.GameState.prototype = {
            Enter: function () {},
            Exit: function() {},
            Update: function(delta) {},
            Draw: function(context) {},
            CheckForChange: function(context) {}
        };

        Enjine.GameTimer = function() {
            this.FramesPerSecond = 1000 / 30;
            this.LastTime = 0;
            this.IntervalFunc = null;
            this.UpdateObject = null;
        };

        Enjine.GameTimer.prototype = {
            Start: function() {
                this.LastTime = new Date().getTime();
                var self = this;
                this.IntervalFunc = setInterval(function() { self.Tick() }, this.FramesPerSecond);
            },
            
            Tick: function() {
                if (this.UpdateObject != null) {
                    var newTime = new Date().getTime();
                    var delta = (newTime - this.LastTime) / 1000;
                    this.LastTime = newTime;
                    
                    this.UpdateObject.Update(delta);
                }
            },
            
            Stop: function() {
                clearInterval(this.IntervalFunc);
            }
        };

        Enjine.Camera = function() {
            this.X = 0;
            this.Y = 0;
        };

        Enjine.DrawableManager = function() {
            this.Unsorted = true;
            this.Objects = [];
        };

        Enjine.DrawableManager.prototype = {
            Add: function(object) {
                this.Objects.push(object);
                this.Unsorted = true;
            },
            
            AddRange: function(objects) {
                this.Objects = this.Objects.concat(objects);
                this.Unsorted = true;
            },
            
            Clear: function() {
                this.Objects.splice(0, this.Objects.length);
            },
            
            Contains: function(obj) {
                var i = this.Objects.length;
                while (i--) {
                    if (this.Objects[i] === obj) {
                        return true;
                    }
                }
                return false;
            },
            
            Remove: function(object) {
                var index = this.Objects.indexOf(object);
                this.Objects.splice(index, 1);
            },
            
            RemoveAt: function(index) {
                this.Objects.splice(index, 1);
            },
            
            RemoveRange: function(index, length) {
                this.Objects.splice(index, length);
            },
            
            RemoveList: function(items) {
                var i = 0, j = 0;
                for (j = 0; j < items.length; i++) {
                    for (i = 0; i < this.Objects.length; i++) {
                        if (this.Objects[i] === items[j]) {
                            this.Objects.splice(i, 1);
                            items.splice(j, 1);
                            j--;
                            break;
                        }
                    }
                }
            },
            
            Update: function(delta) {
                var i = 0;
                for (i = 0; i < this.Objects.length; i++) {
                    if (this.Objects[i].Update) {
                        this.Objects[i].Update(delta);
                    }
                }
            },
            
            Draw: function(context, camera) {
                
                //sort the sprites based on their 'z depth' to get the correct drawing order
                if (this.Unsorted) {
                    this.Unsorted = false;
                    this.Objects.sort(function(x1,x2) { return x1.ZOrder - x2.ZOrder; });
                }
                
                var i = 0;
                for (i = 0; i < this.Objects.length; i++) {
                    if (this.Objects[i].Draw) {
                        this.Objects[i].Draw(context, camera);
                    }
                }
            }
        };

        Enjine.Sprite = function() {
            this.X = 0;
            this.Y = 0;
            this.Image = null;
        };

        Enjine.Sprite.prototype = new Enjine.Drawable();

        Enjine.Sprite.prototype.Draw = function(context, camera) {
            context.drawImage(this.Image, this.X - camera.X, this.Y - camera.Y);
        };
 
        Enjine.SpriteFont = function(strings, image, letterWidth, letterHeight, letters) {
            this.Image = image;
            this.Letters = letters;
            this.LetterWidth = letterWidth;
            this.LetterHeight = letterHeight;
            this.Strings = strings;
        };

        Enjine.SpriteFont.prototype = new Enjine.Drawable();

        Enjine.SpriteFont.prototype.Draw = function(context, camera) {
            for (var s = 0; s < this.Strings.length; s++) {
                var string = this.Strings[s];
                for (var i = 0; i < string.String.length; i++) {
                    var code = string.String.charCodeAt(i);
                    context.drawImage(this.Image, this.Letters[code].X, this.Letters[code].Y, this.LetterWidth, this.LetterHeight, string.X + this.LetterWidth * (i + 1), string.Y, this.LetterWidth, this.LetterHeight);
                }
            }
        };

        Enjine.FrameSprite = function() {
            this.FrameX = 0;
            this.FrameY = 0;
            this.FrameWidth = 0;
            this.FrameHeight = 0;
        };

        Enjine.FrameSprite.prototype = new Enjine.Sprite();

        Enjine.FrameSprite.prototype.Draw = function(context, camera) {
            context.drawImage(this.Image, this.FrameX, this.FrameY, this.FrameWidth, this.FrameHeight, this.X - camera.X, this.Y - camera.Y, this.FrameWidth, this.FrameHeight);
        };
 
        Enjine.AnimationSequence = function(startRow, startColumn, endRow, endColumn) {
            this.StartRow = startRow;
            this.StartColumn = startColumn;
            this.EndRow = endRow;
            this.EndColumn = endColumn;
            
            //sometimes in an animated sprite, we want it to behave like a regular sprite (static)
            //this variable will keep it from wasting time updating animation when the sequence
            //is only a single frame long, for things like standing or pausing action
            this.SingleFrame = false;
            
            if ((this.StartRow == this.EndRow) && (this.StartColumn == this.EndColumn)) {
                this.SingleFrame = true;
            }
        };

        /**
            Subclass that extends the regular sprite with animation capability.
            Code by Rob Kleffner, 2011
        */

        Enjine.AnimatedSprite = function() {
            this.LastElapsed = 0;
            this.FramesPerSecond = 1 / 20;
            this.CurrentSequence = null;
            this.Playing = false;
            this.Looping = false;
            this.Rows = 0;
            this.Columns = 0;
            
            //cheesy dictionary hack to make animation sequences more accessible
            this.Sequences = new Object();
        };

        Enjine.AnimatedSprite.prototype = new Enjine.FrameSprite();

        Enjine.AnimatedSprite.prototype.Update = function(delta) {
            if (this.CurrentSequence.SingleFrame) {
                return;
            }
            if (!this.Playing) {
                return;
            }

            this.LastElapsed -= delta;
            
            if (this.LastElapsed > 0) {
                return;
            }
            
            this.LastElapsed = this.FramesPerSecond;
            this.FrameX += this.FrameWidth;
            
            //increment the frame
            if (this.FrameX > (this.Image.width - this.FrameWidth)) {
                this.FrameX = 0;
                this.FrameY += this.FrameHeight;
                
                if (this.FrameY > (this.Image.height - this.FrameHeight)) {
                    this.FrameY = 0;
                }
            }
            
            //check if it's at the end of the animation sequence
            var seqEnd = false;
            if ((this.FrameX > (this.CurrentSequence.EndColumn * this.FrameWidth)) && (this.FrameY == (this.CurrentSequence.EndRow * this.FrameHeight))) {
                seqEnd = true;
            } else if (this.FrameX == 0 && (this.FrameY > (this.CurrentSequence.EndRow * this.FrameHeight))) {
                seqEnd = true;
            }
            
            //go back to the beginning if looping, otherwise stop playing
            if (seqEnd) {
                if (this.Looping) {
                    this.FrameX = this.CurrentSequence.StartColumn * this.FrameWidth;
                    this.FrameY = this.CurrentSequence.StartRow * this.FrameHeight;
                } else {
                    this.Playing = false;
                }
            }
        };

        Enjine.AnimatedSprite.prototype.PlaySequence = function(seqName, loop) {
            this.Playing = true;
            this.Looping = loop;
            this.CurrentSequence = this.Sequences["seq_" + seqName];
            this.FrameX = this.CurrentSequence.StartColumn * this.FrameWidth;
            this.FrameY = this.CurrentSequence.StartRow * this.FrameHeight;
        };

        Enjine.AnimatedSprite.prototype.StopLooping = function() {
            this.Looping = false;
        };

        Enjine.AnimatedSprite.prototype.StopPlaying = function() {
            this.Playing = false;
        };

        Enjine.AnimatedSprite.prototype.SetFrameWidth = function(width) {
            this.FrameWidth = width;
            this.Rows = this.Image.width / this.FrameWidth;
        };

        Enjine.AnimatedSprite.prototype.SetFrameHeight = function(height) {
            this.FrameHeight = height;
            this.Columns = this.Image.height / this.FrameHeight;
        };

        Enjine.AnimatedSprite.prototype.SetColumnCount = function(columnCount) {
            this.FrameWidth = this.Image.width / columnCount;
            this.Columns = columnCount;
        };

        Enjine.AnimatedSprite.prototype.SetRowCount = function(rowCount) {
            this.FrameHeight = this.Image.height / rowCount;
            this.Rows = rowCount;
        };

        Enjine.AnimatedSprite.prototype.AddExistingSequence = function(name, sequence) {
            this.Sequences["seq_" + name] = sequence;
        };

        Enjine.AnimatedSprite.prototype.AddNewSequence = function(name, startRow, startColumn, endRow, endColumn) {
            this.Sequences["seq_" + name] = new Enjine.AnimationSequence(startRow, startColumn, endRow, endColumn);
        };

        Enjine.AnimatedSprite.prototype.DeleteSequence = function(name) {
            if (this.Sequences["seq_" + name]  != null) {
                delete this.Sequences["seq_" + name];
            }
        };

        Enjine.AnimatedSprite.prototype.ClearSequences = function() {
            delete this.Sequences;
            this.Sequences = new Object();
        };

        Enjine.Collideable = function(obj, width, height, collisionEvent) {
            this.Base = obj;
            this.X = obj.X;
            this.Y = obj.Y;
            this.Width = width;
            this.Height = height;
            
            if (collisionEvent != null) {
                this.CollisionEvent = collisionEvent;
            } else {
                this.CollisionEvent = function() {}
            }
        };

        Enjine.Collideable.prototype = {
            Update: function() {
                this.X = this.Base.X;
                this.Y = this.Base.Y;
            },
            
            CheckCollision: function(other) {
                var left1 = this.X, left2 = other.X;
                var right1 = (this.X + this.Width), right2 = (other.X + other.Width);
                var top1 = this.Y, top2 = other.Y;
                var bottom1 = (this.Y + this.Height), bottom2 = other.Y + other.Height;
                
                if (bottom1 < top2) {
                    return;
                }
                if (top1 > bottom2) {
                    return;
                }
                if (right1 < left2) {
                    return;
                }
                if (left1 > right2) {
                    return;
                }
                
                //collision, fire the events!
                this.CollisionEvent(other);
                other.CollisionEvent(this);
            }
        };
 
        Enjine.Application = function() {
            this.canvas = null;
            this.timer = null;
            this.stateContext = null;
        };

        Enjine.Application.prototype = {
            Update: function(delta) {
                
                this.stateContext.Update(delta);
                
                this.canvas.BeginDraw();
                
                this.stateContext.Draw(this.canvas.BackBufferContext2D);
                
                this.canvas.EndDraw();
            },
            
            Initialize: function(defaultState, resWidth, resHeight) {
                this.canvas = new Enjine.GameCanvas();
                this.timer = new Enjine.GameTimer();
                Enjine.KeyboardInput.Initialize();      
                this.canvas.Initialize("canvas", resWidth, resHeight);
                this.timer.UpdateObject = this;
                
                this.stateContext = new Enjine.GameStateContext(defaultState);
                
                this.timer.Start();
            }
        };

        var Mario = {};

        Mario.SpriteCuts = {

        /*********************
         * Font related
         ********************/         
        CreateBlackFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(0));
        },
        
        CreateRedFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(8));
        },
        
        CreateGreenFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(16));
        },
        
        CreateBlueFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(24));
        },
        
        CreateYellowFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(32));
        },
        
        CreatePinkFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(40));
        },
        
        CreateCyanFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(48));
        },
        
        CreateWhiteFont: function() {
            return new Enjine.SpriteFont([], Enjine.Resources.Images["font"], 8, 8, this.GetCharArray(56));
        },
        
        GetCharArray: function(y) {
            var letters = [];
            var i = 0;
            for (i = 32; i < 127; i++) {
                letters[i] = { X: (i - 32) * 8, Y: y };
            }
            return letters;
        },
        
        /*********************
         * Spritesheet related
         ********************/
        GetBackgroundSheet: function() {
            var sheet = [];
            var x = 0, y = 0, width = Enjine.Resources.Images["background"].width / 32, height = Enjine.Resources.Images["background"].height / 32;
            
            for (x = 0; x < width; x++) {
                sheet[x] = [];
            
                for (y = 0; y < height; y++) {
                    sheet[x][y] = { X: x * 32, Y: y * 32, Width: 32, Height: 32 };
                }
            }
            return sheet;
        },
        
        GetLevelSheet: function() {
            var sheet = [], x = 0, y = 0, width = Enjine.Resources.Images["map"].width / 16, height = Enjine.Resources.Images["map"].height / 16;
            
            for (x = 0; x < width; x++) {
                sheet[x] = [];
                
                for (y = 0; y < height; y++) {
                    sheet[x][y] = { X: x * 16, Y: y * 16, Width: 16, Height: 16 };
                }
            }
            return sheet;
        }
    };

        Mario.Tile = {
        BlockUpper: 1 << 0,
        BlockAll: 1 << 1,
        BlockLower: 1 << 2,
        Special: 1 << 3,
        Bumpable: 1 << 4,
        Breakable: 1 << 5,
        PickUpable: 1 << 6,
        Animated: 1 << 7,
        Behaviors: [],
        
        LoadBehaviors: function() {
            var b = [];
            b[0] = 0;
            b[1] = 20;
            b[2] = 28;
            b[3] = 0;
            b[4] = 130;
            b[5] = 130;
            b[6] = 130;
            b[7] = 130;
            b[8] = 2;
            b[9] = 2;
            b[10] = 2;
            b[11] = 2;
            b[12] = 2;
            b[13] = 0;
            b[14] = 138;
            b[15] = 0;
            b[16] = 162;
            b[17] = 146;
            b[18] = 154;
            b[19] = 162;
            b[20] = 146;
            b[21] = 146;
            b[22] = 154;
            b[23] = 146;
            b[24] = 2;
            b[25] = 0;
            b[26] = 2;
            b[27] = 2;
            b[28] = 2;
            b[29] = 0;
            b[30] = 2;
            b[31] = 0;
            b[32] = 192;
            b[33] = 192;
            b[34] = 192;
            b[35] = 192;
            b[36] = 0;
            b[37] = 0;
            b[38] = 0;
            b[39] = 0;
            b[40] = 2;
            b[41] = 2;
            b[42] = 0;
            b[43] = 0;
            b[44] = 0;
            b[45] = 0;
            b[46] = 2;
            b[47] = 0;
            b[48] = 0;
            b[49] = 0;
            b[50] = 0;
            b[51] = 0;
            b[52] = 0;
            b[53] = 0;
            b[54] = 0;
            b[55] = 0;
            b[56] = 2;
            b[57] = 2;
            
            var i = 0;
            for (i = 58; i < 128; i++) {
                b[i] = 0;
            }
            
            b[128] = 2;
            b[129] = 2;
            b[130] = 2;
            b[131] = 0;
            b[132] = 1;
            b[133] = 1;
            b[134] = 1;
            b[135] = 0;
            b[136] = 2;
            b[137] = 2;
            b[138] = 2;
            b[139] = 0;
            b[140] = 2;
            b[141] = 2;
            b[142] = 2;
            b[143] = 0;
            b[144] = 2;
            b[145] = 0;
            b[146] = 2;
            b[147] = 0;
            b[148] = 0;
            b[149] = 0;
            b[150] = 0;
            b[151] = 0;
            b[152] = 2;
            b[153] = 2;
            b[154] = 2;
            b[155] = 0;
            b[156] = 2;
            b[157] = 2;
            b[158] = 2;
            b[159] = 0;
            b[160] = 2;
            b[161] = 2;
            b[162] = 2;
            b[163] = 0;
            b[164] = 0;
            b[165] = 0;
            b[166] = 0;
            b[167] = 0;
            b[168] = 2;
            b[169] = 2;
            b[170] = 2;
            b[171] = 0;
            b[172] = 2;
            b[173] = 2;
            b[174] = 2;
            b[175] = 0;
            b[176] = 2;
            b[177] = 2;
            b[178] = 2;
            b[179] = 0;
            b[180] = 1;
            b[181] = 1;
            b[182] = 1;
            
            for (i = 183; i < 224; i++) {
                b[i] = 0;
            }
            
            b[224] = 1;
            b[225] = 1;
            b[226] = 1;
            
            for (i = 227; i < 256; i++) {
                b[i] = 0;
            }
            
            this.Behaviors = b;
        }
    };

    Mario.LevelType = {
        Overground: 0,
        Underground: 1,
        Castle: 2
    };

    Mario.Odds = {
        Straight: 0,
        HillStraight: 1,
        Tubes: 2,
        Jump: 3,
        Cannons: 4
    };

    Mario.Level = function(width, height) {
        this.Width = width;
        this.Height = height;
        this.ExitX = 10;
        this.ExitY = 10;
        
        this.Map = [];
        this.Data = [];
        this.SpriteTemplates = [];
        
        var x = 0, y = 0;
        for (x = 0; x < this.Width; x++) {
            this.Map[x] = [];
            this.Data[x] = [];
            this.SpriteTemplates[x] = [];
            
            for (y = 0; y < this.Height; y++) {
                this.Map[x][y] = 0;
                this.Data[x][y] = 0;
                this.SpriteTemplates[x][y] = null;
            }
        }
    };

    Mario.Level.prototype = {
        Update: function() {
            var x = 0, y = 0;
            for (x = 0; x < this.Width; x++) {
                for (y = 0; y < this.Height; y++) {
                    if (this.Data[x][y] > 0) {
                        this.Data[x][y]--;
                    }
                }
            }
        },
        
        GetBlockCapped: function(x, y) {
            if (x < 0) { x = 0; }
            if (y < 0) { y = 0; }
            if (x >= this.Width) { x = this.Width - 1; }
            if (y >= this.Height) { y = this.Height - 1; }
            return this.Map[x][y];
        },
        
        GetBlock: function(x, y) {
            if (x < 0) { x = 0; }
            if (y < 0) { return 0; }
            if (x >= this.Width) { x = this.Width - 1; }
            if (y >= this.Height) { y = this.Height - 1; }
            return this.Map[x][y];
        },
        
        SetBlock: function(x, y, block) {
            if (x < 0) { return; }
            if (y < 0) { return; }
            if (x >= this.Width) { return; }
            if (y >= this.Height) { return; }
            this.Map[x][y] = block;
        },
        
        SetBlockData: function(x, y, data) {
            if (x < 0) { return; }
            if (y < 0) { return; }
            if (x >= this.Width) { return; }
            if (y >= this.Height) { return; }
            this.Data[x][y] = data;
        },
        
        IsBlocking: function(x, y, xa, ya) {
            var block = this.GetBlock(x, y);
            var blocking = ((Mario.Tile.Behaviors[block & 0xff]) & Mario.Tile.BlockAll) > 0;
            blocking |= (ya > 0) && ((Mario.Tile.Behaviors[block & 0xff]) & Mario.Tile.BlockUpper) > 0;
            blocking |= (ya < 0) && ((Mario.Tile.Behaviors[block & 0xff]) & Mario.Tile.BlockLower) > 0;

            return blocking;
        },
        
        GetSpriteTemplate: function(x, y) {
            if (x < 0) { return null; }
            if (y < 0) { return null; }
            if (x >= this.Width) { return null; }
            if (y >= this.Height) { return null; }
            return this.SpriteTemplates[x][y];
        },
        
        SetSpriteTemplate: function(x, y, template) {
            if (x < 0) { return; }
            if (y < 0) { return; }
            if (x >= this.Width) { return; }
            if (y >= this.Height) { return; }
            this.SpriteTemplates[x][y] = template;
        }
    };

        Mario.BackgroundGenerator = function(width, height, distant, type) {
        this.Width = width;
        this.Height = height;
        this.Distant = distant;
        this.Type = type;
    };

    Mario.BackgroundGenerator.prototype = {
        SetValues: function(width, height, distant, type) {
            this.Width = width;
            this.Height = height;
            this.Distant = distant;
            this.Type = type;
        },

        CreateLevel: function() {
            var level = new Mario.Level(this.Width, this.Height);
            switch (this.Type) {
                case Mario.LevelType.Overground:
                    this.GenerateOverground(level);
                    break;
                case Mario.LevelType.Underground:
                    this.GenerateUnderground(level);
                    break;
                case Mario.LevelType.Castle:
                    this.GenerateCastle(level);
                    break;
            }
            return level;
        },
        
        GenerateOverground: function(level) {
            var range = this.Distant ? 4 : 6;
            var offs = this.Distant ? 2 : 1;
            var oh = Math.floor(Math.random() * range) + offs;
            var h = Math.floor(Math.random() * range) + offs;
            
            var x = 0, y = 0, h0 = 0, h1 = 0, s = 2;
            for (x = 0; x < this.Width; x++) {
                oh = h;
                while (oh === h) {
                    h = Math.floor(Math.random() * range) + offs;
                }
                
                for (y = 0; y < this.Height; y++) {
                    h0 = (oh < h) ? oh : h;
                    h1 = (oh < h) ? h : oh;
                    s = 2;
                    if (y < h0) {
                        if (this.Distant){
                            s = 2;
                            if (y < 2) { s = y; }
                            level.SetBlock(x, y, 4 + s * 8);
                        } else {
                            level.SetBlock(x, y, 5);
                        }
                    } else if (y === h0) {
                        s = h0 === h ? 0 : 1;
                        s += this.Distant ? 2 : 0;
                        level.SetBlock(x, y, s);
                    } else if (y === h1) {
                        s = h0 === h ? 0 : 1;
                        s += this.Distant ? 2 : 0;
                        level.SetBlock(x, y, s + 16);
                    } else {
                        s = (y > h1) ? 1 : 0;
                        if (h0 === oh) { s = 1 - s; }
                        s += this.Distant ? 2 : 0;
                        level.SetBlock(x, y, s + 8);
                    }
                }
            }
        },
        
        GenerateUnderground: function(level) {
            var x = 0, y = 0, t = 0, yy = 0;
            if (this.Distant) {
                var tt = 0;
                for (x = 0; x < this.Width; x++) {
                    if (Math.random() < 0.75) { tt = 1 - tt; }
                
                    for (y = 0; y < this.Height; y++) {
                        t = tt;
                        yy = y - 2;
                        
                        if (yy < 0 || yy > 4) {
                            yy = 2;
                            t = 0;
                        }
                        level.SetBlock(x, y, (4 + t + (3 + yy) * 8));
                    }
                }
            } else {
                for (x = 0; x < this.Width; x++) {
                    for (y = 0; y < this.Height; y++) {
                        t = x % 2;
                        yy = y - 1;
                        if (yy < 0 || yy > 7) {
                            yy = 7;
                            t = 0;
                        }
                        if (t === 0 && yy > 1 && yy < 5) {
                            t = -1;
                            yy = 0;
                        }
                        
                        level.SetBlock(x, y, (6 + t + yy * 8));
                    }
                }
            }
        },
        
        GenerateCastle: function(level) {
            var x = 0, y = 0, t = 0, yy = 0;
            if (this.Distant) {
                for (x = 0; x < this.Width; x++) {
                    for (y = 0; y < this.Height; y++) {
                        t = x % 2;
                        yy = y - 1;
                        
                        if (yy > 2 && yy < 5) {
                            yy = 2;
                        } else if (yy >= 5) {
                            yy -= 2;
                        }
                        
                        if (yy < 0) {
                            t = 0;
                            yy = 5;
                        } else if (yy > 4) {
                            t = 1;
                            yy = 5;
                        } else if (t < 1 && yy === 3) {
                            t = 0;
                            yy = 3;
                        } else if (t < 1 && yy > 0 && yy < 3) {
                            t = 0;
                            yy = 2;
                        }
                        
                        level.SetBlock(x, y, (1 + t + (yy + 4) * 8));
                    }
                }
            } else {
                for (x = 0; x < this.Width; x++) {
                    for (y = 0; y < this.Height; y++) {
                        t = x % 3;
                        yy = y - 1;
                        
                        if (yy > 2 && yy < 5) {
                            yy = 2;
                        } else if (yy >= 5) {
                            yy -= 2;
                        }
                        
                        if (yy < 0) {
                            t = 1;
                            yy = 5;
                        } else if (yy > 4) {
                            t = 2;
                            yy = 5;
                        } else if (t < 2 && yy === 4) {
                            t = 2;
                            yy = 4;
                        } else if (t < 2 && yy > 0 && yy < 4) {
                            t = 4;
                            yy = -3;
                        }
                        
                        level.SetBlock(x, y, (1 + t + (yy + 3) * 8));
                    }
                }
            }
        }
        
    };

        Mario.BackgroundRenderer = function(level, width, height, distance) {
            this.Level = level;
            this.Width = width;
            this.Distance = distance;
            this.TilesY = ((height / 32) | 0) + 1;
            
            this.Background = Mario.SpriteCuts.GetBackgroundSheet();
        };

        Mario.BackgroundRenderer.prototype = new Enjine.Drawable();

        Mario.BackgroundRenderer.prototype.Draw = function(context, camera) {
            var xCam = camera.X / this.Distance;
            var x = 0, y = 0, b = null, frame = null;
            
            //the OR truncates the decimal, quicker than Math.floor
            var xTileStart = (xCam / 32) | 0;
            //the +1 makes sure the right edge tiles get drawn
            var xTileEnd = (((xCam + this.Width) / 32) | 0);
            
            for (x = xTileStart; x <= xTileEnd; x++) {
                for (y = 0; y < this.TilesY; y++) {
                    b = this.Level.GetBlock(x, y) & 0xff;
                    frame = this.Background[b % 8][(b / 8) | 0];
                    
                    //bitshifting by five is the same as multiplying by 32
                    context.drawImage(Enjine.Resources.Images["background"], frame.X, frame.Y, frame.Width, frame.Height, ((x << 5) - xCam) | 0, (y << 5) | 0, frame.Width, frame.Height);
                }
            }
        };

        Mario.ImprovedNoise = function(seed) {
            this.P = [];
            this.Shuffle(seed);
        };

        Mario.ImprovedNoise.prototype = {
            Shuffle: function(seed) {
                var permutation = [];
                var i = 0, j = 0, tmp = 0;
                
                for (i = 0; i < 256; i++) {
                    permutation[i] = i;
                }
                
                for (i = 0; i < 256; i++) {
                    j = ((Math.random() * (256 - 1)) | 0) + i;
                    tmp = permutation[i];
                    permutation[i] = permutation[j];
                    permutation[j] = tmp;
                    this.P[i + 256] = this.P[i] = permutation[i];
                }
            },
            
            PerlinNoise: function(x, y) {
                var i = 0, n = 0, stepSize = 0;
                
                for (i = 0; i < 8; i++) {
                    stepSize = 64 / (1 << i);
                    n += this.Noise(x / stepSize, y / stepSize, 128) / (1 << i);
                }
                
                return n;
            },
            
            Noise: function(x, y, z) {
                var nx = (x | 0) & 255, ny = (y | 0) & 255, nz = (z | 0) & 255;
                x -= (x | 0);
                y -= (y | 0);
                z -= (z | 0);
                
                var u = this.Fade(x), v = this.Fade(y), w = this.Fade(z);
                var A = this.P[nx] + ny, AA = this.P[A] + nz, AB = this.P[A + 1] + nz,
                B = this.P[nx + 1] + ny, BA = this.P[B] + nz, BB = this.P[B + 1] + nz;
                
                return this.Lerp(w, this.Lerp(v, this.Lerp(u, this.Grad(this.P[AA], x, y, z),
                    this.Grad(this.P[BA], x - 1, y, z)),
                    this.Lerp(u, this.Grad(this.P[AB], x, y - 1, z),
                        this.Grad(this.P[BB], x - 1, y - 1, z))),
                    this.Lerp(v, this.Lerp(u, this.Grad(this.P[AA + 1], x, y, z - 1),
                        this.Grad(this.P[BA + 1], x - 1, y, z - 1)),
                        this.Lerp(u, this.Grad(this.P[AB + 1], x, y - 1, z - 1), this.Grad(this.P[BB + 1], x - 1, y - 1, z - 1))));
            },
            
            Fade: function(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            },
            
            Lerp: function(t, x, y) {
                return x + t * (y - x);
            },
            
            Grad: function(hash, x, y, z) {
                var h = hash & 15;
                var u = h < 8 ? x : y;
                var v = h < 4 ? y : (h === 12 || h === 14) ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        };

        Mario.NotchSprite = function(image) {
            this.XOld = 0; this.YOld = 0;
            this.X = 0; this.Y = 0;
            this.Xa = 0; this.Ya = 0;
            this.XPic = 0; this.YPic = 0;
            this.XPicO = 0; this.YPicO = 0;
            this.PicWidth = 32; this.PicHeight = 32;
            this.XFlip = false; this.YFlip = false;
            this.Visible = true;
            this.Image = image;
            this.Delta = 0;
            this.SpriteTemplate = null;
            this.Layer = 1;
        };

        Mario.NotchSprite.prototype = new Enjine.Drawable();

        Mario.NotchSprite.prototype.Draw = function(context, camera) {
            var xPixel = 0, yPixel = 0;
            if (!this.Visible) {
                return;
            }
            
            xPixel = ((this.XOld + (this.X - this.XOld) * this.Delta) | 0) - this.XPicO;
            yPixel = ((this.YOld + (this.Y - this.YOld) * this.Delta) | 0) - this.YPicO;
            
            context.save();
            context.scale(this.XFlip ? -1 : 1, this.YFlip ? -1 : 1);
            context.translate(this.XFlip ? -320 : 0, this.YFlip ? -240 : 0);
            context.drawImage(this.Image, this.XPic * this.PicWidth, this.YPic * this.PicHeight, this.PicWidth, this.PicHeight,
                this.XFlip ? (320 - xPixel - this.PicWidth) : xPixel, this.YFlip ? (240 - yPixel - this.PicHeight) : yPixel, this.PicWidth, this.PicHeight);
            context.restore();
        };

        Mario.NotchSprite.prototype.Update = function(delta) {
            this.XOld = this.X;
            this.YOld = this.Y;
            this.Move();
            this.Delta = delta;
        };

        Mario.NotchSprite.prototype.UpdateNoMove = function(delta) {
            this.XOld = this.X;
            this.YOld = this.Y;
            this.Delta = 0;
        };

        Mario.NotchSprite.prototype.Move = function() {
            this.X += this.Xa;
            this.Y += this.Ya;
        };

        Mario.NotchSprite.prototype.GetX = function(delta) {
            return ((this.XOld + (this.X - this.XOld) * delta) | 0) - this.XPicO;
        };

        Mario.NotchSprite.prototype.GetY = function(delta) {
            return ((this.YOld + (this.Y - this.YOld) * delta) | 0) - this.YPicO;
        };

        Mario.NotchSprite.prototype.CollideCheck = function() { };

        Mario.NotchSprite.prototype.BumpCheck = function(xTile, yTile) { };

        Mario.NotchSprite.prototype.Release = function(mario) { };

        Mario.NotchSprite.prototype.ShellCollideCheck = function(shell) {
            return false;
        };

        Mario.NotchSprite.prototype.FireballCollideCheck = function(fireball) {
            return false;
        };

        Mario.Character = function() {
            //these are static in Notch's code... here it doesn't seem necessary
            this.Large = false;
            this.Fire = false;
            this.Coins = 0;
            this.Lives = 3;
            this.LevelString = "none";
            this.GroundInertia = 0.89;
            this.AirInertia = 0.89;
            
            //non static variables in Notch's code
            this.RunTime = 0;
            this.WasOnGround = false;
            this.OnGround = false;
            this.MayJump = false;
            this.Ducking = false;
            this.Sliding = false;
            this.JumpTime = 0;
            this.XJumpSpeed = 0;
            this.YJumpSpeed = 0;
            this.CanShoot = false;
            
            this.Width = 4;
            this.Height = 24;
            
            //Level scene
            this.World = null;
            this.Facing = 0;
            this.PowerUpTime = 0;
            
            this.XDeathPos = 0; this.YDeathPos = 0;
            this.DeathTime = 0;
            this.WinTime = 0;
            this.InvulnerableTime = 0;
            
            //Sprite
            this.Carried = null;
            
            this.LastLarge = false;
            this.LastFire = false;
            this.NewLarge = false;
            this.NewFire = false;
        };

        Mario.Character.prototype = new Mario.NotchSprite(null);

        Mario.Character.prototype.Initialize = function(world) {
            this.World = world;
            this.X = 32;
            this.Y = 0;
            this.PowerUpTime = 0;
            
            //non static variables in Notch's code
            this.RunTime = 0;
            this.WasOnGround = false;
            this.OnGround = false;
            this.MayJump = false;
            this.Ducking = false;
            this.Sliding = false;
            this.JumpTime = 0;
            this.XJumpSpeed = 0;
            this.YJumpSpeed = 0;
            this.CanShoot = false;
            
            this.Width = 4;
            this.Height = 24;
            
            //Level scene
            this.World = world;
            this.Facing = 0;
            this.PowerUpTime = 0;
            
            this.XDeathPos = 0; this.YDeathPos = 0;
            this.DeathTime = 0;
            this.WinTime = 0;
            this.InvulnerableTime = 0;
            
            //Sprite
            this.Carried = null;
            
            this.SetLarge(this.Large, this.Fire);
        };

        Mario.Character.prototype.SetLarge = function(large, fire) {
            if (fire) {
                large = true;
            }
            if (!large) {
                fire = false;
            }
            
            this.LastLarge = this.Large;
            this.LastFire = this.Fire;
            this.Large = large;
            this.Fire = fire;
            this.NewLarge = this.Large;
            this.NewFire = this.Fire;
            
            this.Blink(true);
        };

        Mario.Character.prototype.Blink = function(on) {
            this.Large = on ? this.NewLarge : this.LastLarge;
            this.Fire = on ? this.NewFire : this.LastFire;
            
            if (this.Large) {
                if (this.Fire) {
                    this.Image = Enjine.Resources.Images["fireMario"];
                } else {
                    this.Image = Enjine.Resources.Images["mario"];
                }
                
                this.XPicO = 16;
                this.YPicO = 31;
                this.PicWidth = this.PicHeight = 32;
            } else {
                this.Image = Enjine.Resources.Images["smallMario"];
                this.XPicO = 8;
                this.YPicO = 15;
                this.PicWidth = this.PicHeight = 16;
            }
        };

        Mario.Character.prototype.Move = function() {
            if (this.WinTime > 0) {
                this.WinTime++;
                this.Xa = 0;
                this.Ya = 0;
                return;
            }
            
            if (this.DeathTime > 0) {
                this.DeathTime++;
                if (this.DeathTime < 11) {
                    this.Xa = 0;
                    this.Ya = 0;
                } else if (this.DeathTime === 11) {
                    this.Ya = -15;
                } else {
                    this.Ya += 2;
                }
                this.X += this.Xa;
                this.Y += this.Ya;
                return;
            }
            
            if (this.PowerUpTime !== 0) {
                if (this.PowerUpTime > 0) {
                    this.PowerUpTime--;
                    this.Blink((((this.PowerUpTime / 3) | 0) & 1) === 0);
                } else {
                    this.PowerUpTime++;
                    this.Blink((((-this.PowerUpTime / 3) | 0) & 1) === 0);
                }
                
                if (this.PowerUpTime === 0) {
                    this.World.Paused = false;
                }
                
                this.CalcPic();
                return;
            }
            
            if (this.InvulnerableTime > 0) {
                this.InvulnerableTime--;
            }
            
            this.Visible = (((this.InvulerableTime / 2) | 0) & 1) === 0;
            
            this.WasOnGround = this.OnGround;
            var sideWaysSpeed = Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift) ? 1.2 : 0.6;
            
            if (this.OnGround) {
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Down) && this.Large) {
                    this.Ducking = true;
                } else {
                    this.Ducking = false;
                }
            }
                
            if (this.Xa > 2) {
                this.Facing = 1;
            }
            if (this.Xa < -2) {
                this.Facing = -1;
            }
            
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space) || (this.JumpTime < 0 && !this.OnGround && !this.Sliding)) {
                if (this.JumpTime < 0) {
                    this.Xa = this.XJumpSpeed;
                    this.Ya = -this.JumpTime * this.YJumpSpeed;
                    this.JumpTime++;
                } else if (this.OnGround && this.MayJump) {
                    Enjine.Resources.PlaySound("jump");
                    this.XJumpSpeed = 0;
                    this.YJumpSpeed = -1.9;
                    this.JumpTime = 7;
                    this.Ya = this.JumpTime * this.YJumpSpeed;
                    this.OnGround = false;
                    this.Sliding = false;
                } else if (this.Sliding && this.MayJump) {
                    Enjine.Resources.PlaySound("jump");
                    this.XJumpSpeed = -this.Facing * 6;
                    this.YJumpSpeed = -2;
                    this.JumpTime = -6;
                    this.Xa = this.XJumpSpeed;
                    this.Ya = -this.JumpTime * this.YJumpSpeed;
                    this.OnGround = false;
                    this.Sliding = false;
                    this.Facing = -this.Facing;
                } else if (this.JumpTime > 0) {
                    this.Xa += this.XJumpSpeed;
                    this.Ya = this.JumpTime * this.YJumpSpeed;
                    this.JumpTime--;
                }
            } else {
                this.JumpTime = 0;
            }
            
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Left) && !this.Ducking) {
                if (this.Facing === 1) {
                    this.Sliding = false;
                }
                this.Xa -= sideWaysSpeed;
                if (this.JumpTime >= 0) {
                    this.Facing = -1;
                }
            }
            
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Right) && !this.Ducking) {
                if (this.Facing === -1) {
                    this.Sliding = false;
                }
                this.Xa += sideWaysSpeed;
                if (this.JumpTime >= 0) {
                    this.Facing = 1;
                }
            }
            
            if ((!Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Left) && !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Right)) || this.Ducking || this.Ya < 0 || this.OnGround) {
                this.Sliding = false;  
            }
            
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift) && this.CanShoot && this.Fire && this.World.FireballsOnScreen < 2) {
                Enjine.Resources.PlaySound("fireball");
                this.World.AddSprite(new Mario.Fireball(this.World, this.X + this.Facing * 6, this.Y - 20, this.Facing));
            }
            
            this.CanShoot = !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift);
            this.MayJump = (this.OnGround || this.Sliding) && !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space);
            this.XFlip = (this.Facing === -1);
            this.RunTime += Math.abs(this.Xa) + 5;
            
            if (Math.abs(this.Xa) < 0.5) {
                this.RunTime = 0;
                this.Xa = 0;
            }
            
            this.CalcPic();
            
            if (this.Sliding) {
                this.World.AddSprite(new Mario.Sparkle(this.World, ((this.X + Math.random() * 4 - 2) | 0) + this.Facing * 8,
                    ((this.Y + Math.random() * 4) | 0) - 24, Math.random() * 2 - 1, Math.random(), 0, 1, 5));
                this.Ya *= 0.5;
            }
            
            this.OnGround = false;
            this.SubMove(this.Xa, 0);
            this.SubMove(0, this.Ya);
            if (this.Y > this.World.Level.Height * 16 + 16) {
                this.Die();
            }
            
            if (this.X < 0) {
                this.X = 0;
                this.Xa = 0;
            }
            
            if (this.X > this.World.Level.ExitX * 16) {
                this.Win();
            }
            
            if (this.X > this.World.Level.Width * 16) {
                this.X = this.World.Level.Width * 16;
                this.Xa = 0;
            }
            
            this.Ya *= 0.85;
            if (this.OnGround) {
                this.Xa *= this.GroundInertia;
            } else {
                this.Xa *= this.AirInertia;
            }
            
            if (!this.OnGround) {
                this.Ya += 3;
            }
            
            if (this.Carried !== null) {
                this.Carried.X *= this.X + this.Facing * 8;
                this.Carried.Y *= this.Y - 2;
                if (!Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift)) {
                    this.Carried.Release(this);
                    this.Carried = null;
                }
            }
        };

        Mario.Character.prototype.CalcPic = function() {
            var runFrame = 0, i = 0;
            
            if (this.Large) {
                runFrame = ((this.RunTime / 20) | 0) % 4;
                if (runFrame === 3) {
                    runFrame = 1;
                }
                if (this.Carried === null && Math.abs(this.Xa) > 10) {
                    runFrame += 3;
                }
                if (this.Carried !== null) {
                    runFrame += 10;
                }
                if (!this.OnGround) {
                    if (this.Carried !== null) {
                        runFrame = 12;
                    } else if (Math.abs(this.Xa) > 10) {
                        runFrame = 7;
                    } else {
                        runFrame = 6;
                    }
                }
            } else {
                runFrame = ((this.RunTime / 20) | 0) % 2;
                if (this.Carried === null && Math.abs(this.Xa) > 10) {
                    runFrame += 2;
                }
                if (this.Carried !== null) {
                    runFrame += 8;
                }
                if (!this.OnGround) {
                    if (this.Carried !== null) {
                        runFrame = 9;
                    } else if (Math.abs(this.Xa) > 10) {
                        runFrame = 5;
                    } else {
                        runFrame = 4;
                    }
                }
            }
            
            if (this.OnGround && ((this.Facing === -1 && this.Xa > 0) || (this.Facing === 1 && this.Xa < 0))) {
                if (this.Xa > 1 || this.Xa < -1) {
                    runFrame = this.Large ? 9 : 7;
                }
                
                if (this.Xa > 3 || this.Xa < -3) {
                    for (i = 0; i < 3; i++) {
                        this.World.AddSprite(new Mario.Sparkle(this.World, (this.X + Math.random() * 8 - 4) | 0, (this.Y + Math.random() * 4) | 0, Math.random() * 2 - 1, Math.random() * -1, 0, 1, 5));
                    }
                }
            }
            
            if (this.Large) {
                if (this.Ducking) {
                    runFrame = 14;
                }
                this.Height = this.Ducking ? 12 : 24;
            } else {
                this.Height = 12;
            }
            
            this.XPic = runFrame;
        };

        Mario.Character.prototype.SubMove = function(xa, ya) {
            var collide = false;
            
            while (xa > 8) {
                if (!this.SubMove(8, 0)) {
                    return false;
                }
                xa -= 8;
            }
            while (xa < -8) {
                if (!this.SubMove(-8, 0)) {
                    return false;
                }
                xa += 8;
            }
            while (ya > 8) {
                if (!this.SubMove(0, 8)) {
                    return false;
                }
                ya -= 8;
            }
            while (ya < -8) {
                if (!this.SubMove(0, -8)) {
                    return false;
                }
                ya += 8;
            }
            
            if (ya > 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                }
            }
            if (ya < 0) {
                if (this.IsBlocking(this.X + xa, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
            }
            
            if (xa > 0) {
                this.Sliding = true;
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
                
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
                
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
            }
            if (xa < 0) {
                this.Sliding = true;
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
                
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
                
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                } else {
                    this.Sliding = false;
                }
            }
            
            if (collide) {
                if (xa < 0) {
                    this.X = (((this.X - this.Width) / 16) | 0) * 16 + this.Width;
                    this.Xa = 0;
                }
                if (xa > 0) {
                    this.X = (((this.X + this.Width) / 16 + 1) | 0) * 16 - this.Width - 1;
                    this.Xa = 0;
                }
                if (ya < 0) {
                    this.Y = (((this.Y - this.Height) / 16) | 0) * 16 + this.Height;
                    this.JumpTime = 0;
                    this.Ya = 0;
                }
                if (ya > 0) {
                    this.Y = (((this.Y - 1) / 16 + 1) | 0) * 16 - 1;
                    this.OnGround = true;
                }
                
                return false;
            } else {
                this.X += xa;
                this.Y += ya;
                return true;
            }
        };

        Mario.Character.prototype.IsBlocking = function(x, y, xa, ya) {
            var blocking = false, block = 0, xx = 0, yy = 0;
            
            x = (x / 16) | 0;
            y = (y / 16) | 0;
            if (x === ((this.X / 16) | 0) && y === ((this.Y / 16) | 0)) {
                return false;
            }
            
            block = this.World.Level.GetBlock(x, y);
            
            if (((Mario.Tile.Behaviors[block & 0xff]) & Mario.Tile.PickUpable) > 0) {
                this.GetCoin();
                Enjine.Resources.PlaySound("coin");
                this.World.Level.SetBlock(x, y, 0);
                for (xx = 0; xx < 2; xx++) {
                    for (yy = 0; yy < 2; yy++) {
                        this.World.AddSprite(new Mario.Sparkle(this.World, x * 16 + xx * 8 + ((Math.random() * 8) | 0), y * 16 + yy * 8 + ((Math.random() * 8) | 0), 0, 0, 0, 2, 5));
                    }
                }
            }
            
            blocking = this.World.Level.IsBlocking(x, y, xa, ya);
            if (blocking && ya < 0) {
                this.World.Bump(x, y, this.Large);
            }
            return blocking;
        };

        Mario.Character.prototype.Stomp = function(object) {
            var targetY = 0;

            if (this.DeathTime > 0 || this.World.Paused) {
                return;
            }
            
            targetY = object.Y - object.Height / 2;
            this.SubMove(0, targetY - this.Y);
            
            if (object instanceof Mario.Enemy || object instanceof Mario.BulletBill) {
                
                Enjine.Resources.PlaySound("kick");
                this.XJumpSpeed = 0;
                this.YJumpSpeed = -1.9;
                this.JumpTime = 8;
                this.Ya = this.JumpTime * this.YJumpSpeed;
                this.OnGround = false;
                this.Sliding = false;
                this.InvulnerableTime = 1;
            } else if (object instanceof Mario.Shell) {
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift) && object.Facing === 0) {
                    this.Carried = object;
                    object.Carried = true;
                } else {
                    Enjine.Resources.PlaySound("kick");
                    this.XJumpSpeed = 0;
                    this.YJumpSpeed = -1.9;
                    this.JumpTime = 8;
                    this.Ya = this.JumpTime * this.YJumpSpeed;
                    this.OnGround = false;
                    this.Sliding = false;
                    this.InvulnerableTime = 1;
                }
            }
        };

        Mario.Character.prototype.GetHurt = function() {
            if (this.DeathTime > 0 || this.World.Paused) {
                return;
            }
            if (this.InvulnerableTime > 0) {
                return;
            }
            
            if (this.Large) {
                this.World.Paused = true;
                this.PowerUpTime = -18;
                Enjine.Resources.PlaySound("powerdown");
                if (this.Fire) {
                    this.SetLarge(true, false);
                } else {
                    this.SetLarge(false, false);
                }
                this.InvulnerableTime = 32;
            } else {
                this.Die();
            }
        };

        Mario.Character.prototype.Win = function() {
            this.XDeathPos = this.X | 0;
            this.YDeathPos = this.Y | 0;
            this.World.Paused = true;
            this.WinTime = 1;
            Enjine.Resources.PlaySound("exit");
        };

        Mario.Character.prototype.Die = function() {
            this.XDeathPos = this.X | 0;
            this.YDeathPos = this.Y | 0;
            this.World.Paused = true;
            this.DeathTime = 1;
            Enjine.Resources.PlaySound("death");
            this.SetLarge(false, false);
        };

        Mario.Character.prototype.GetFlower = function() {
            if (this.DeathTime > 0 && this.World.Paused) {
                return;
            }
            
            if (!this.Fire) {
                this.World.Paused = true;
                this.PowerUpTime = 18;
                Enjine.Resources.PlaySound("powerup");
                this.SetLarge(true, true);
            } else {
                this.GetCoin();
                Enjine.Resources.PlaySound("coin");
            }
        };

        Mario.Character.prototype.GetMushroom = function() {
            if (this.DeathTime > 0 && this.World.Paused) {
                return;
            }
            
            if (!this.Large) {
                this.World.Paused = true;
                this.PowerUpTime = 18;
                Enjine.Resources.PlaySound("powerup");
                this.SetLarge(true, false);
            } else {
                this.GetCoin();
                Enjine.Resources.PlaySound("coin");
            }
        };

        Mario.Character.prototype.Kick = function(shell) {
            if (this.DeathTime > 0 && this.World.Paused) {
                return;
            }
            
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Shift)) {
                this.Carried = shell;
                shell.Carried = true;
            } else {
                Enjine.Resources.PlaySound("kick");
                this.InvulnerableTime = 1;
            }
        };

        Mario.Character.prototype.Get1Up = function() {
            Enjine.Resources.PlaySound("1up");
            this.Lives++;
            if (this.Lives === 99) {
                this.Lives = 99;
            }
        };

        Mario.Character.prototype.GetCoin = function() {
            this.Coins++;
            if (this.Coins === 100) {
                this.Coins = 0;
                this.Get1Up();
            }
        };

        Mario.LevelRenderer = function(level, width, height) {
            this.Width = width;
            this.Height = height;
            this.Level = level;
            this.TilesY = ((height / 16) | 0) + 1;
            this.Delta = 0;
            this.Tick = 0;
            this.Bounce = 0;
            this.AnimTime = 0;
            
            this.Background = Mario.SpriteCuts.GetLevelSheet();
        };

        Mario.LevelRenderer.prototype = new Enjine.Drawable();

        Mario.LevelRenderer.prototype.Update = function(delta) {
            this.AnimTime += delta;
            this.Tick = this.AnimTime | 0;
            this.Bounce += delta * 30;
            this.Delta = delta;
        };

        Mario.LevelRenderer.prototype.Draw = function(context, camera) {
            this.DrawStatic(context, camera);
            this.DrawDynamic(context, camera);
        };

        Mario.LevelRenderer.prototype.DrawStatic = function(context, camera) {
            var x = 0, y = 0, b = 0, frame = null, xTileStart = (camera.X / 16) | 0, xTileEnd = ((camera.X + this.Width) / 16) | 0;
            
            for (x = xTileStart; x < xTileEnd + 1; x++) {
                for (y = 0; y < this.TilesY; y++) {
                    b = this.Level.GetBlock(x, y) & 0xff;
                    if ((Mario.Tile.Behaviors[b] & Mario.Tile.Animated) === 0) {
                        frame = this.Background[b % 16][(b / 16) | 0];
                        context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, ((x << 4) - camera.X) | 0, (y << 4) | 0, frame.Width, frame.Height);
                    }
                }
            }
        };

        Mario.LevelRenderer.prototype.DrawDynamic = function(context, camera) {
            var x = 0, y = 0, b = 0, animTime = 0, yo = 0, frame = null;
            for (x = (camera.X / 16) | 0; x <= ((camera.X + this.Width) / 16) | 0; x++) {
                for (y = (camera.Y / 16) | 0; y <= ((camera.Y + this.Height) / 16) | 0; y++) {
                    b = this.Level.GetBlock(x, y);
                    
                    if (((Mario.Tile.Behaviors[b & 0xff]) & Mario.Tile.Animated) > 0) {
                        animTime = ((this.Bounce / 3) | 0) % 4;
                        if ((((b % 16) / 4) | 0) === 0 && ((b / 16) | 0) === 1) {
                            animTime = ((this.Bounce / 2 + (x + y) / 8) | 0) % 20;
                            if (animTime > 3) {
                                animTime = 0;
                            }
                        }
                        if ((((b % 16) / 4) | 0) === 3 && ((b / 16) | 0) === 0) {
                            animTime = 2;
                        }
                        yo = 0;
                        if (x >= 0 && y >= 0 && x < this.Level.Width && y < this.Level.Height) {
                            yo = this.Level.Data[x][y];
                        }
                        if (yo > 0) {
                            yo = (Math.sin((yo - this.Delta) / 4 * Math.PI) * 8) | 0;
                        }
                        frame = this.Background[(((b % 16) / 4) | 0) * 4 + animTime][(b / 16) | 0];
                        context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, (x << 4) - camera.X, (y << 4) - camera.Y - yo, frame.Width, frame.Height);
                    }
                }
            }
        };

        Mario.LevelRenderer.prototype.DrawExit0 = function(context, camera, bar) {
            var y = 0, yh = 0, frame = null;
            for (y = this.Level.ExitY - 8; y < this.Level.ExitY; y++) {
                frame = this.Background[12][y === this.Level.ExitY - 8 ? 4 : 5];
                context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, (this.Level.ExitX << 4) - camera.X - 16, (y << 4) - camera.Y, frame.Width, frame.Height);
            }
            
            if (bar) {
                yh = this.Level.ExitY * 16 - (3 * 16) - (Math.sin(this.AnimTime) * 3 * 16) - 8;// - ((Math.sin(((this.Bounce + this.Delta) / 20) * 0.5 + 0.5) * 7 * 16) | 0) - 8;
                frame = this.Background[12][3];
                context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, (this.Level.ExitX << 4) - camera.X - 16, yh - camera.Y, frame.Width, frame.Height);
                frame = this.Background[13][3];
                context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, (this.Level.ExitX << 4) - camera.X, yh - camera.Y, frame.Width, frame.Height);
            }
        };

        Mario.LevelRenderer.prototype.DrawExit1 = function(context, camera) {
            var y = 0, frame = null;
            for (y = this.Level.ExitY - 8; y < this.Level.ExitY; y++) {
                frame = this.Background[13][y === this.Level.ExitY - 8 ? 4 : 5];
                context.drawImage(Enjine.Resources.Images["map"], frame.X, frame.Y, frame.Width, frame.Height, (this.Level.ExitX << 4) - camera.X + 16, (y << 4) - camera.Y, frame.Width, frame.Height);
            }
        };

        Mario.LevelGenerator = function(width, height) {
            this.Width = width;
            this.Height = height;
            this.Odds = [];
            this.TotalOdds = 0;
            this.Difficulty = 0;
            this.Type = 0;
        };

        Mario.LevelGenerator.prototype = {
            CreateLevel: function(type, difficulty) {
                var i = 0, length = 0, floor = 0, x = 0, y = 0, ceiling = 0, run = 0, level = null;
                
                this.Type = type;
                this.Difficulty = difficulty;
                this.Odds[Mario.Odds.Straight] = 20;
                this.Odds[Mario.Odds.HillStraight] = 10;
                this.Odds[Mario.Odds.Tubes] = 2 + difficulty;
                this.Odds[Mario.Odds.Jump] = 2 * difficulty;
                this.Odds[Mario.Odds.Cannon] = -10 + 5 * difficulty;
                
                if (this.Type !== Mario.LevelType.Overground) {
                    this.Odds[Mario.Odds.HillStraight] = 0;
                }
                
                for (i = 0; i < this.Odds.length; i++) {
                    if (this.Odds[i] < 0) {
                        this.Odds[i] = 0;
                    }
                    this.TotalOdds += this.Odds[i];
                    this.Odds[i] = this.TotalOdds - this.Odds[i];
                }
                
                level = new Mario.Level(this.Width, this.Height);
                length += this.BuildStraight(level, 0, level.Width, true);
                while (length < level.Width - 64) {
                    length += this.BuildZone(level, length, level.Width - length);
                }
                
                floor = this.Height - 1 - (Math.random() * 4) | 0;
                level.ExitX = length + 8;
                level.ExitY = floor;
                
                for (x = length; x < level.Width; x++) {
                    for (y = 0; y < this.Height; y++) {
                        if (y >= floor) {
                            level.SetBlock(x, y, 1 + 9 * 16);
                        }
                    }
                }
                
                if (type === Mario.LevelType.Castle || type === Mario.LevelType.Underground) {
                    for (x = 0; x < level.Width; x++) {
                        if (run-- <= 0 && x > 4) {
                            ceiling = (Math.random() * 4) | 0;
                            run = ((Math.random() * 4) | 0) + 4;
                        }
                        for (y = 0; y < level.Height; y++) {
                            if ((x > 4 && y <= ceiling) || x < 1) {
                                level.SetBlock(x, y, 1 + 9 * 16);
                            }
                        }
                    }
                }
                
                this.FixWalls(level);
                
                return level;
            },
            
            BuildZone: function(level, x, maxLength) {
                var t = (Math.random() * this.TotalOdds) | 0, type = 0, i = 0;
                for (i = 0; i < this.Odds.length; i++) {
                    if (this.Odds[i] <= t) {
                        type = i;
                    }
                }
                
                switch (type) {
                    case Mario.Odds.Straight:
                        return this.BuildStraight(level, x, maxLength, false);
                    case Mario.Odds.HillStraight:
                        return this.BuildHillStraight(level, x, maxLength);
                    case Mario.Odds.Tubes:
                        return this.BuildTubes(level, x, maxLength);
                    case Mario.Odds.Jump:
                        return this.BuildJump(level, x, maxLength);
                    case Mario.Odds.Cannons:
                        return this.BuildCannons(level, x, maxLength);
                }
                return 0;
            },
            
            BuildJump: function(level, xo, maxLength) {
                var js = ((Math.random() * 4) | 0) + 2, jl = ((Math.random() * 2) | 0) + 2, length = js * 2 + jl, x = 0, y = 0,
                    hasStairs = ((Math.random() * 3) | 0) === 0, floor = this.Height - 1 - ((Math.random() * 4) | 0);
                
                for (x = xo; x < xo + length; x++) {
                    if (x < xo + js || x > xo + length - js - 1) {
                        for (y = 0; y < this.Height; y++) {
                            if (y >= floor) {
                                level.SetBlock(x, y, 1 + 9 * 16);
                            } else if (hasStairs) {
                                if (x < xo + js) {
                                    if (y >= floor - (x - xo) + 1) {
                                        level.SetBlock(x, y, 9);
                                    }
                                } else {
                                    if (y >= floor - ((xo + length) - x) + 2) {
                                        level.SetBlock(x, y, 9);
                                    }
                                }
                            }
                        }
                    }
                }
                
                return length;
            },
            
            BuildCannons: function(level, xo, maxLength) {
                alert("cannons");
                var length = ((Math.random() * 10) | 0) + 2, floor = this.Height - 1 - (Math.random() * 4) | 0,
                    xCannon = xo + 1 + (Math.random() * 4) | 0, x = 0, y = 0, cannonHeight = 0;
                    
                if (length > maxLength) {
                    length = maxLength;
                }
                
                for (x = xo; x < xo + length; x++) {
                    if (x > xCannon) {
                        xCannon += 2 * (Math.random() * 4) | 0;
                    }
                    if (xCannon === xo + length - 1) {
                        xCannon += 10;
                    }
                    cannonHeight = floor - ((Math.random() * 4) | 0) - 1;
                    
                    for (y = 0; y < this.Height; y++) {
                        if (y >= floor) {
                            level.SetBlock(x, y, 1 + 9 * 16);
                        } else {
                            if (x === xCannon && y >= cannonHeight) {
                                if (y === cannonHeight) {
                                    level.SetBlock(x, y, 14);
                                } else if (y === cannonHeight + 1) {
                                    level.SetBlock(x, y, 14 + 16);
                                } else {
                                    level.SetBlock(x, y, 14 + 2 * 16);
                                }
                            }
                        }
                    }
                }
                
                return length;
            },
            
            BuildHillStraight: function(level, xo, maxLength) {
                var length = ((Math.random() * 10) | 0) + 10, floor = this.Height - 1 - (Math.random() * 4) | 0,
                    x = 0, y = 0, h = floor, keepGoing = true, l = 0, xxo = 0, occupied = [], xx = 0, yy = 0;
                
                if (length > maxLength) {
                    length = maxLength;
                }
                
                for (x = xo; x < xo + length; x++) {
                    for (y = 0; y < this.Height; y++) {
                        if (y >= floor) {
                            level.SetBlock(x, y, 1 + 9 * 16);
                        }
                    }
                }
                
                this.AddEnemyLine(level, xo + 1, xo + length - 1, floor - 1);
                
                while (keepGoing) {
                    h = h - 2 - (Math.random() * 3) | 0;
                    if (h <= 0) {
                        keepGoing = false;
                    } else {
                        l = ((Math.random() * 5) | 0) + 3;
                        xxo = ((Math.random() * (length - l - 2)) | 0) + xo + 1;
                        
                        if (occupied[xxo - xo] || occupied[xxo - xo + l] || occupied[xxo - xo - 1] || occupied[xxo - xo + l + 1]) {
                            keepGoing = false;
                        } else {
                            occupied[xxo - xo] = true;
                            occupied[xxo - xo + l] = true;
                            this.AddEnemyLine(level, xxo, xxo + l, h - 1);
                            if (((Math.random() * 4) | 0) === 0) {
                                this.Decorate(level, xxo - 1, xxo + l + 1, h);
                                keepGoing = false;
                            }
                            
                            for (x = xxo; x < xxo + l; x++) {
                                for (y = h; y < floor; y++) {
                                    xx = 5;
                                    yy = 9;
                                    if (x === xxo) {
                                        xx = 4;
                                    }
                                    if (x === xxo + l - 1) {
                                        xx = 6;
                                    }
                                    if (y === h) {
                                        yy = 8;
                                    }
                                    
                                    if (level.GetBlock(x, y) === 0) {
                                        level.SetBlock(x, y, xx + yy * 16);
                                    } else {
                                        if (level.GetBlock(x, y) === (4 + 8 * 16)) {
                                            level.SetBlock(x, y, 4 + 11 * 16);
                                        }
                                        if (level.GetBlock(x, y) === (6 + 8 * 16)) {
                                            level.SetBlock(x, y, 6 + 11 * 16);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                return length;
            },
            
            AddEnemyLine: function(level, x0, x1, y) {
                var x = 0, type = 0;
                for (x = x0; x < x1; x++) {
                    if (((Math.random() * 35) | 0) < this.Difficulty + 1) {
                        type = (Math.random() * 4) | 0;
                        if (this.Difficulty < 1) {
                            type = Mario.Enemy.Goomba;
                        } else if (this.Difficulty < 3) {
                            type = (Math.random() * 3) | 0;
                        }
                        level.SetSpriteTemplate(x, y, new Mario.SpriteTemplate(type, ((Math.random() * 35) | 0) < this.Difficulty));
                    }
                }
            },
            
            BuildTubes: function(level, xo, maxLength) {
                var length = ((Math.random() * 10) | 0) + 5, floor = this.Height - 1 - (Math.random() * 4) | 0,
                    xTube = xo + 1 + (Math.random() * 4) | 0, tubeHeight = floor - ((Math.random() * 2) | 0) - 2,
                    x = 0, y = 0, xPic = 0;
                
                if (length > maxLength) {
                    length = maxLength;
                }
                
                for (x = xo; x < xo + length; x++) {
                    if (x > xTube + 1) {
                        xTube += 3 + ((Math.random() * 4) | 0);
                        tubeHeight = floor - ((Math.random() * 2) | 0) - 2;
                    }
                    if (xTube >= xo + length - 2) {
                        xTube += 10;
                    }
                    
                    if (x === xTube && ((Math.random() * 11) | 0) < this.Difficulty + 1) {
                        level.SetSpriteTemplate(x, tubeHeight, new Mario.SpriteTemplate(Mario.Enemy.Flower, false));
                    }
                    
                    for (y = 0; y < this.Height; y++) {
                        if (y >= floor) {
                            level.SetBlock(x, y, 1 + 9 * 16);
                        } else {
                            if ((x === xTube || x === xTube + 1) && y >= tubeHeight) {
                                xPic = 10 + x - xTube;
                                if (y === tubeHeight) {
                                    level.SetBlock(x, y, xPic);
                                } else {
                                    level.SetBlock(x, y, xPic + 16);
                                }
                            }
                        }
                    }
                }
                
                return length;
            },
            
            BuildStraight: function(level, xo, maxLength, safe) {
                var length = ((Math.random() * 10) | 0) + 2, floor = this.Height - 1 - ((Math.random() * 4) | 0), x = 0, y = 0;
                
                if (safe) {
                    length = 10 + ((Math.random() * 5) | 0);
                }
                if (length > maxLength) {
                    length = maxLength;
                }
                
                for (x = xo; x < xo + length; x++) {
                    for (y = 0; y < this.Height; y++) {
                        if (y >= floor) {
                            level.SetBlock(x, y, 1 + 9 * 16);
                        }
                    }
                }
                
                if (!safe) {
                    if (length > 5) {
                        this.Decorate(level, xo, xo + length, floor);
                    }
                }
                
                return length;
            },
            
            Decorate: function(level, x0, x1, floor) {
                if (floor < 1) {
                    return;
                }
                
                var rocks = true, s = (Math.random() * 4) | 0, e = (Math.random() * 4) | 0, x = 0;
                
                this.AddEnemyLine(level, x0 + 1, x1 - 1, floor - 1);
                
                if (floor - 2 > 0) {
                    if ((x1 - 1 - e) - (x0 + 1 + s) > 1) {
                        for (x = x0 + 1 + s; x < x1 - 1 - e; x++) {
                            level.SetBlock(x, floor - 2, 2 + 2 * 16);
                        }
                    }
                }
                
                s = (Math.random() * 4) | 0;
                e = (Math.random() * 4) | 0;
                
                if (floor - 4 > 0) {
                    if ((x1 - 1 - e) - (x0 + 1 + s) > 2) {
                        for (x = x0 + 1 + s; x < x1 - 1 - e; x++) {
                            if (rocks) {
                                if (x !== x0 + 1 && x !== x1 - 2 && ((Math.random() * 3) | 0) === 0) {
                                    if (((Math.random() * 4) | 0) === 0) {
                                        level.SetBlock(x, floor - 4, 4 + 2 + 16);
                                    } else {
                                        level.SetBlock(x, floor - 4, 4 + 1 + 16);
                                    }
                                } else if (((Math.random() * 4) | 0) === 0) {
                                    if (((Math.random() * 4) | 0) === 0) {
                                        level.SetBlock(x, floor - 4, 2 + 16);
                                    } else {
                                        level.SetBlock(x, floor - 4, 1 + 16);
                                    }
                                } else {
                                    level.SetBlock(x, floor - 4, 16);
                                }
                            }
                        }
                    }
                }
            },
            
            FixWalls: function(level) {
                var blockMap = [], x = 0, y = 0, xx = 0, yy = 0, blocks = 0;
                
                for (x = 0; x < this.Width + 1; x++) {
                    blockMap[x] = [];
                
                    for (y = 0; y < this.Height + 1; y++) {
                        blocks = 0;
                        for (xx = x - 1; xx < x + 1; xx++) {
                            for (yy = y - 1; yy < y + 1; yy++) {
                                if (level.GetBlockCapped(xx, yy) === (1 + 9 * 16)) {
                                    blocks++;
                                }
                            }
                        }
                        blockMap[x][y] = blocks === 4;
                    }
                }
                
                this.Blockify(level, blockMap, this.Width + 1, this.Height + 1);
            },
            
            Blockify: function(level, blocks, width, height) {
                var to = 0, b = [], x = 0, y = 0, xx = 0, yy = 0, i = 0, _xx = 0, _yy = 0;
                
                for (i = 0; i < 2; i++) {
                    b[i] = [];
                }
                
                if (this.Type === Mario.LevelType.Castle) {
                    to = 8;
                } else if (this.Type === Mario.LevelType.Underground) {
                    to = 12;
                }
                
                for (x = 0; x < width; x++) {
                    for (y = 0; y < height; y++) {
                        for (xx = x; xx <= x + 1; xx++) {
                            for (yy = y; yy <= y + 1; yy++) {
                                _xx = xx;
                                _yy = yy;
                                if (_xx < 0) {
                                    _xx = 0;
                                }
                                if (_yy < 0) {
                                    _yy = 0;
                                }
                                if (_xx > width - 1) {
                                    _xx = width - 1;
                                }
                                if (_yy > height - 1) {
                                    _yy = height - 1;
                                }
                                
                                b[xx - x][yy - y] = blocks[_xx][_yy];
                            }
                        }
                        
                        if (b[0][0] === b[1][0] && b[0][1] === b[1][1]) {
                            if (b[0][0] === b[0][1]) {
                                if (b[0][0]) {
                                    level.SetBlock(x, y, 1 + 9 * 16 + to);
                                }
                            } else {
                                if (b[0][0]) {
                                    level.SetBlock(x, y, 1 + 10 * 16 + to);
                                } else {
                                    level.SetBlock(x, y, 1 + 8 * 16 + to);
                                }
                            }
                        } else if (b[0][0] === b[0][1] && b[1][0] === b[1][1]) {
                            if (b[0][0]) {
                                level.SetBlock(x, y, 2 + 9 * 16 + to);
                            } else {
                                level.SetBlock(x, y, 9 * 16 + to);
                            }
                        } else if (b[0][0] === b[1][1] && b[0][1] === b[1][0]) {
                            level.SetBlock(x, y, 1 + 9 * 16 + to);
                        } else if (b[0][0] === b[1][0]) {
                            if (b[0][0]) {
                                if (b[0][1]) {
                                    level.SetBlock(x, y, 3 + 10 * 16 + to);
                                } else {
                                    level.SetBlock(x, y, 3 + 11 * 16 + to);
                                }
                            } else {
                                if (b[0][1]) {
                                    level.SetBlock(x, y, 2 + 8 * 16 + to);
                                } else {
                                    level.SetBlock(x, y, 8 * 16 + to);
                                }
                            }
                        } else if (b[0][1] === b[1][1]) {
                            if (b[0][1]) {
                                if (b[0][0]) {
                                    level.SetBlock(x, y, 3 + 9 * 16 + to);
                                } else {
                                    level.SetBlock(x, y, 3 + 8 * 16 + to);
                                }
                            } else {
                                if (b[0][0]) {
                                    level.SetBlock(x, y, 2 + 10 * 16 + to);
                                } else {
                                    level.SetBlock(x, y, 10 * 16 + to);
                                }
                            }
                        } else {
                            level.SetBlock(x, y, 1 + 16 * to);
                        }
                    }
                }
            }
        };

        Mario.SpriteTemplate = function(type, winged) {
            this.Type = type;
            this.Winged = winged;
            this.LastVisibleTick = -1;
            this.IsDead = false;
            this.Sprite = null;
        };

        Mario.SpriteTemplate.prototype = {
            Spawn: function(world, x, y, dir) {
                if (this.IsDead) {
                    return;
                }
                
                if (this.Type === Mario.Enemy.Flower) {
                    this.Sprite = new Mario.FlowerEnemy(world, x * 16 + 15, y * 16 + 24);
                } else {
                    this.Sprite = new Mario.Enemy(world, x * 16 + 8, y * 16 + 15, dir, this.Type, this.Winged);
                }
                this.Sprite.SpriteTemplate = this;
                world.AddSprite(this.Sprite);
            }
        };
  
        Mario.Enemy = function(world, x, y, dir, type, winged) {
            this.GroundInertia = 0.89;
            this.AirInertia = 0.89;
            this.RunTime = 0;
            this.OnGround = false;
            this.MayJump = false;
            this.JumpTime = 0;
            this.XJumpSpeed = 0;
            this.YJumpSpeed = 0;
            this.Width = 4;
            this.Height = 24;
            this.DeadTime = 0;
            this.FlyDeath = false;
            this.WingTime = 0;
            this.NoFireballDeath = false;
            
            this.X = x;
            this.Y = y;
            this.World = world;
            
            this.Type = type;
            this.Winged = winged;
            
            this.Image = Enjine.Resources.Images["enemies"];
            
            this.XPicO = 8;
            this.YPicO = 31;
            this.AvoidCliffs = this.Type === Mario.Enemy.RedKoopa;
            this.NoFireballDeath = this.Type === Mario.Enemy.Spiky;
            
            this.YPic = this.Type;
            if (this.YPic > 1) {
                this.Height = 12;
            }
            this.Facing = dir;
            if (this.Facing === 0) {
                this.Facing = 1;
            }
            
            this.PicWidth = 16;
        };

        Mario.Enemy.prototype = new Mario.NotchSprite();

        Mario.Enemy.prototype.CollideCheck = function() {
            if (this.DeadTime !== 0) {
                return;
            }
            
            var xMarioD = Mario.MarioCharacter.X - this.X, yMarioD = Mario.MarioCharacter.Y - this.Y;
                
            if (xMarioD > -this.Width * 2 - 4 && xMarioD < this.Width * 2 + 4) {
                if (yMarioD > -this.Height && yMarioD < Mario.MarioCharacter.Height) {
                    if (this.Type !== Mario.Enemy.Spiky && Mario.MarioCharacter.Ya > 0 && yMarioD <= 0 && (!Mario.MarioCharacter.OnGround || !Mario.MarioCharacter.WasOnGround)) {
                        Mario.MarioCharacter.Stomp(this);
                        if (this.Winged) {
                            this.Winged = false;
                            this.Ya = 0;
                        } else {
                            this.YPicO = 31 - (32 - 8);
                            this.PicHeight = 8;
                            
                            if (this.SpriteTemplate !== null) {
                                this.SpriteTemplate.IsDead = true;
                            }
                            
                            this.DeadTime = 10;
                            this.Winged = false;
                            
                            if (this.Type === Mario.Enemy.RedKoopa) {
                                this.World.AddSprite(new Mario.Shell(this.World, this.X, this.Y, 0));
                            } else if (this.Type === Mario.Enemy.GreenKoopa) {
                                this.World.AddSprite(new Mario.Shell(this.World, this.X, this.Y, 1));
                            }
                        }
                    } else {
                        Mario.MarioCharacter.GetHurt();
                    }
                }
            }
        };

        Mario.Enemy.prototype.Move = function() {
            var i = 0, sideWaysSpeed = 1.75, runFrame = 0;

            this.WingTime++;
            if (this.DeadTime > 0) {
                this.DeadTime--;
                
                if (this.DeadTime === 0) {
                    this.DeadTime = 1;
                    for (i = 0; i < 8; i++) {
                        this.World.AddSprite(new Mario.Sparkle(this.World, ((this.X + Math.random() * 16 - 8) | 0) + 4, ((this.Y - Math.random() * 8) | 0) + 4, Math.random() * 2 - 1, Math.random() * -1, 0, 1, 5));
                    }
                    this.World.RemoveSprite(this);
                }
                
                if (this.FlyDeath) {
                    this.X += this.Xa;
                    this.Y += this.Ya;
                    this.Ya *= 0.95;
                    this.Ya += 1;
                }
                return;
            }
            
            if (this.Xa > 2) {
                this.Facing = 1;
            }
            if (this.Xa < -2) {
                this.Facing = -1;
            }
            
            this.Xa = this.Facing * sideWaysSpeed;
            
            this.MayJump = this.OnGround;
            
            this.XFlip = this.Facing === -1;
            
            this.RunTime += Math.abs(this.Xa) + 5;
            
            runFrame = ((this.RunTime / 20) | 0) % 2;
            
            if (!this.OnGround) {
                runFrame = 1;
            }
            
            if (!this.SubMove(this.Xa, 0)) {
                this.Facing = -this.Facing;
            }
            this.OnGround = false;
            this.SubMove(0, this.Ya);
            
            this.Ya *= this.Winged ? 0.95 : 0.85;
            if (this.OnGround) {
                this.Xa *= this.GroundInertia;
            } else {
                this.Xa *= this.AirInertia;
            }
            
            if (!this.OnGround) {
                if (this.Winged) {
                    this.Ya += 0.6;
                } else {
                    this.Ya += 2;
                }
            } else if (this.Winged) {
                this.Ya = -10;
            }
            
            if (this.Winged) {
                runFrame = ((this.WingTime / 4) | 0) % 2;
            }
            
            this.XPic = runFrame;
        };

        Mario.Enemy.prototype.SubMove = function(xa, ya) {
            var collide = false;
            
            while (xa > 8) {
                if (!this.SubMove(8, 0)) {
                    return false;
                }
                xa -= 8;
            }
            while (xa < -8) {
                if (!this.SubMove(-8, 0)) {
                    return false;
                }
                xa += 8;
            }
            while (ya > 8) {
                if (!this.SubMove(0, 8)) {
                    return false;
                }
                ya -= 8;
            }
            while (ya < -8) {
                if (!this.SubMove(0, -8)) {
                    return false;
                }
                ya += 8;
            }
            
            if (ya > 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                }
            }
            if (ya < 0) {
                if (this.IsBlocking(this.X + xa, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
            }
            
            if (xa > 0) {
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
                
                if (this.AvoidCliffs && this.OnGround && !this.World.Level.IsBlocking(((this.X + this.Xa + this.Width) / 16) | 0, ((this.Y / 16) + 1) | 0, this.Xa, 1)) {
                    collide = true;
                }
            }
            if (xa < 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
                
                if (this.AvoidCliffs && this.OnGround && !this.World.Level.IsBlocking(((this.X + this.Xa - this.Width) / 16) | 0, ((this.Y / 16) + 1) | 0, this.Xa, 1)) {
                    collide = true;
                }
            }
            
            if (collide) {
                if (xa < 0) {
                    this.X = (((this.X - this.Width) / 16) | 0) * 16 + this.Width;
                    this.Xa = 0;
                }
                if (xa > 0) {
                    this.X = (((this.X + this.Width) / 16 + 1) | 0) * 16 - this.Width - 1;
                    this.Xa = 0;
                }
                if (ya < 0) {
                    this.Y = (((this.Y - this.Height) / 16) | 0) * 16 + this.Height;
                    this.JumpTime = 0;
                    this.Ya = 0;
                }
                if (ya > 0) {
                    this.Y = (((this.Y - 1) / 16 + 1) | 0) * 16 - 1;
                    this.OnGround = true;
                }
                
                return false;
            } else {
                this.X += xa;
                this.Y += ya;
                return true;
            }
        };

        Mario.Enemy.prototype.IsBlocking = function(x, y, xa, ya) {
            x = (x / 16) | 0;
            y = (y / 16) | 0;
            
            if (x === (this.X / 16) | 0 && y === (this.Y / 16) | 0) {
                return false;
            }
            
            return this.World.Level.IsBlocking(x, y, xa, ya);
        };

        Mario.Enemy.prototype.ShellCollideCheck = function(shell) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xd = shell.X - this.X, yd = shell.Y - this.Y;
            if (xd > -16 && xd < 16) {
                if (yd > -this.Height && yd < shell.Height) {
                    Enjine.Resources.PlaySound("kick");
                    
                    this.Xa = shell.Facing * 2;
                    this.Ya = -5;
                    this.FlyDeath = true;
                    if (this.SpriteTemplate !== null) {
                        this.SpriteTemplate.IsDead = true;
                    }
                    this.DeadTime = 100;
                    this.Winged = false;
                    this.YFlip = true;
                    return true;
                }
            }
            return false;
        };

        Mario.Enemy.prototype.FireballCollideCheck = function(fireball) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xd = fireball.X - this.X, yd = fireball.Y - this.Y;
            if (xd > -16 && xd < 16) {
                if (yd > -this.Height && yd < fireball.Height) {
                    if (this.NoFireballDeath) {
                        return true;
                    }
                
                    Enjine.Resources.PlaySound("kick");
                    
                    this.Xa = fireball.Facing * 2;
                    this.Ya = -5;
                    this.FlyDeath = true;
                    if (this.SpriteTemplate !== null) {
                        this.SpriteTemplate.IsDead = true;
                    }
                    this.DeadTime = 100;
                    this.Winged = false;
                    this.YFlip = true;
                    return true;
                }
            }
        };

        Mario.Enemy.prototype.BumpCheck = function(xTile, yTile) {
            if (this.DeadTime !== 0) {
                return;
            }
            
            if (this.X + this.Width > xTile * 16 && this.X - this.Width < xTile * 16 + 16 && yTile === ((this.Y - 1) / 16) | 0) {
                Enjine.Resources.PlaySound("kick");
                
                this.Xa = -Mario.MarioCharacter.Facing * 2;
                this.Ya = -5;
                this.FlyDeath = true;
                if (this.SpriteTemplate !== null) {
                    this.SpriteTemplate.IsDead = true;
                }
                this.DeadTime = 100;
                this.Winged = false;
                this.YFlip = true;
            }
        };

        Mario.Enemy.prototype.SubDraw = Mario.NotchSprite.prototype.Draw;

        Mario.Enemy.prototype.Draw = function(context, camera) {
            var xPixel = 0, yPixel = 0;
            
            if (this.Winged) {
                xPixel = ((this.XOld + (this.X - this.XOld) * this.Delta) | 0) - this.XPicO;
                yPixel = ((this.YOld + (this.Y - this.YOld) * this.Delta) | 0) - this.YPicO;
                
                if (this.Type !== Mario.Enemy.RedKoopa && this.Type !== Mario.Enemy.GreenKoopa) {
                    this.XFlip = !this.XFlip;
                    context.save();
                    context.scale(this.XFlip ? -1 : 1, this.YFlip ? -1 : 1);
                    context.translate(this.XFlip ? -320 : 0, this.YFlip ? -240 : 0);
                    context.drawImage(this.Image, (((this.WingTime / 4) | 0) % 2) * 16, 4 * 32, 16, 32,
                        this.XFlip ? (320 - xPixel - 24) : xPixel - 8, this.YFlip ? (240 - yPixel - 32) : yPixel - 8, 16, 32);
                    context.restore();
                    this.XFlip = !this.XFlip;
                }
            }
            
            this.SubDraw(context, camera);
            
            if (this.Winged) {
                xPixel = ((this.XOld + (this.X - this.XOld) * this.Delta) | 0) - this.XPicO;
                yPixel = ((this.YOld + (this.Y - this.YOld) * this.Delta) | 0) - this.YPicO;
                
                if (this.Type === Mario.Enemy.RedKoopa && this.Type === Mario.Enemy.GreenKoopa) {
                    context.save();
                    context.scale(this.XFlip ? -1 : 1, this.YFlip ? -1 : 1);
                    context.translate(this.XFlip ? -320 : 0, this.YFlip ? -240 : 0);
                    context.drawImage(this.Image, (((this.WingTime / 4) | 0) % 2) * 16, 4 * 32, 16, 32,
                        this.XFlip ? (320 - xPixel - 24) : xPixel - 8, this.YFlip ? (240 - yPixel) : yPixel - 8, 16, 32);
                    context.restore();
                } else {
                    context.save();
                    context.scale(this.XFlip ? -1 : 1, this.YFlip ? -1 : 1);
                    context.translate(this.XFlip ? -320 : 0, this.YFlip ? -240 : 0);
                    context.drawImage(this.Image, (((this.WingTime / 4) | 0) % 2) * 16, 4 * 32, 16, 32,
                        this.XFlip ? (320 - xPixel - 24) : xPixel - 8, this.YFlip ? (240 - yPixel - 32) : yPixel - 8, 16, 32);
                    context.restore();
                }
            }
        };

        //Static variables
        Mario.Enemy.RedKoopa = 0;
        Mario.Enemy.GreenKoopa = 1;
        Mario.Enemy.Goomba = 2;
        Mario.Enemy.Spiky = 3;
        Mario.Enemy.Flower = 4;

        Mario.Fireball = function(world, x, y, facing) {
            this.GroundInertia = 0.89;
            this.AirInertia = 0.89;
            
            this.Image = Enjine.Resources.Images["particles"];
            
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Facing = facing;
            
            this.XPicO = 4;
            this.YPicO = 4;
            this.YPic = 3;
            this.XPic = 4;
            this.Height = 8;
            this.Width = 4;
            this.PicWidth = this.PicHeight = 8;
            this.Ya = 4;
            this.Dead = false;
            this.DeadTime = 0;
            this.Anim = 0;
            this.OnGround = false;
        };

        Mario.Fireball.prototype = new Mario.NotchSprite();

        Mario.Fireball.prototype.Move = function() {
            var i = 0, sideWaysSpeed = 8;
            
            if (this.DeadTime > 0) {
                for (i = 0; i < 8; i++) {
                    this.World.AddSprite(new Mario.Sparkle(this.World, ((this.X + Math.random() * 8 - 4) | 0) + 4, ((this.Y + Math.random() * 8 - 4) | 0) + 2, Math.random() * 2 - 1 * this.Facing, Math.random() * 2 - 1, 0, 1, 5));
                }
                this.World.RemoveSprite(this);
                return;
            }
            
            if (this.Facing != 0) {
                this.Anim++;
            }
            
            if (this.Xa > 2) {
                this.Facing = 1;
            }
            if (this.Xa < -2) {
                this.Facing = -1;
            }
            
            this.Xa = this.Facing * sideWaysSpeed;
            
            this.World.CheckFireballCollide(this);
            
            this.FlipX = this.Facing === -1;
            
            this.XPic = this.Anim % 4;
            
            if (!this.SubMove(this.Xa, 0)) {
                this.Die();
            }
            
            this.OnGround = false;
            this.SubMove(0, this.Ya);
            if (this.OnGround) {
                this.Ya = -10;
            }
            
            this.Ya *= 0.95;
            if (this.OnGround) {
                this.Xa *= this.GroundInertia;
            } else {
                this.Xa *= this.AirInertia;
            }
            
            if (!this.OnGround) {
                this.Ya += 1.5;
            }
        };

        Mario.Fireball.prototype.SubMove = function(xa, ya) {
            var collide = false;
            
            while (xa > 8) {
                if (!this.SubMove(8, 0)) {
                    return false;
                }
                xa -= 8;
            }
            while (xa < -8) {
                if (!this.SubMove(-8, 0)) {
                    return false;
                }
                xa += 8;
            }
            while (ya > 8) {
                if (!this.SubMove(0, 8)) {
                    return false;
                }
                ya -= 8;
            }
            while (ya < -8) {
                if (!this.SubMove(0, -8)) {
                    return false;
                }
                ya += 8;
            }
            
            if (ya > 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                }
            }
            if (ya < 0) {
                if (this.IsBlocking(this.X + xa, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
            }
            
            if (xa > 0) {
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            if (xa < 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            
            if (collide) {
                if (xa < 0) {
                    this.X = (((this.X - this.Width) / 16) | 0) * 16 + this.Width;
                    this.Xa = 0;
                }
                if (xa > 0) {
                    this.X = (((this.X + this.Width) / 16 + 1) | 0) * 16 - this.Width - 1;
                    this.Xa = 0;
                }
                if (ya < 0) {
                    this.Y = (((this.Y - this.Height) / 16) | 0) * 16 + this.Height;
                    this.Ya = 0;
                }
                if (ya > 0) {
                    this.Y = (((this.Y - 1) / 16 + 1) | 0) * 16 - 1;
                    this.OnGround = true;
                }
                
                return false;
            } else {
                this.X += xa;
                this.Y += ya;
                return true;
            }
        };

        Mario.Fireball.prototype.IsBlocking = function(x, y, xa, ya) {
            x = (x / 16) | 0;
            y = (y / 16) | 0;
            
            if (x === (this.X / 16) | 0 && y === (this.Y / 16) | 0) {
                return false;
            }
            
            return this.World.Level.IsBlocking(x, y, xa, ya);
        };

        Mario.Fireball.prototype.Die = function() {
            this.Dead = true;
            this.Xa = -this.Facing * 2;
            this.Ya = -5;
            this.DeadTime = 100;
        };

        Mario.Sparkle = function(world, x, y, xa, ya) {
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Xa = xa;
            this.Ya = ya;
            this.XPic = (Math.random() * 2) | 0;
            this.YPic = 0;
            
            this.Life = 10 + ((Math.random() * 5) | 0);
            this.XPicStart = this.XPic;
            this.XPicO = 4;
            this.YPicO = 4;
            
            this.PicWidth = 8;
            this.PicHeight = 8;
            this.Image = Enjine.Resources.Images["particles"];
        };

        Mario.Sparkle.prototype = new Mario.NotchSprite();

        Mario.Sparkle.prototype.Move = function() {
            if (this.Life > 10) {
                this.XPic = 7;
            } else {
                this.XPic = (this.XPicStart + (10 - this.Life) * 0.4) | 0;
            }
            
            if (this.Life-- < 0) {
                this.World.RemoveSprite(this);
            }
            
            this.X += this.Xa;
            this.Y += this.Ya;
        };

        Mario.CoinAnim = function(world, x, y) {
            this.World = world;
            this.Life = 10;
            this.Image = Enjine.Resources.Images["map"];
            this.PicWidth = this.PicHeight = 16;
            this.X = x * 16;
            this.Y = y * 16 - 16;
            this.Xa = 0;
            this.Ya = -6;
            this.XPic = 0;
            this.YPic = 2;
        };

        Mario.CoinAnim.prototype = new Mario.NotchSprite();

        Mario.CoinAnim.prototype.Move = function() {
            var x = 0, y = 0;
            if (this.Life-- < 0) {
                this.World.RemoveSprite(this);
                for (x = 0; x < 2; x++) {
                    for (y = 0; y < 2; y++) {
                        this.World.AddSprite(new Mario.Sparkle(this.World, (this.X + x * 8 + Math.random() * 8) | 0, (this.Y + y * 8 + Math.random() * 8) | 0, 0, 0, 0, 2, 5));
                    }
                }
            }
            
            this.XPic = this.Life & 3;
            this.X += this.Xa;
            this.Y += this.Ya;
            this.Ya += 1;
        };

        Mario.Mushroom = function(world, x, y) {
            this.RunTime = 0;
            this.GroundInertia = 0.89;
            this.AirInertia = 0.89;
            this.OnGround = false;
            this.Width = 4;
            this.Height = 24;
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Image = Enjine.Resources.Images["items"];
            this.XPicO = 8;
            this.YPicO = 15;
            this.YPic = 0;
            this.Height = 12;
            this.Facing = 1;
            this.PicWidth = this.PicHeight = 16;
            this.Life = 0;
        };

        Mario.Mushroom.prototype = new Mario.NotchSprite();

        Mario.Mushroom.prototype.CollideCheck = function() {
            var xMarioD = Mario.MarioCharacter.X - this.X, yMarioD = Mario.MarioCharacter.Y - this.Y;
            if (xMarioD > -16 && xMarioD < 16) {
                if (yMarioD > -this.Height && yMarioD < Mario.MarioCharacter.Height) {
                    Mario.MarioCharacter.GetMushroom();
                    this.World.RemoveSprite(this);
                }
            }
        };

        Mario.Mushroom.prototype.Move = function() {
            if (this.Life < 9) {
                this.Layer = 0;
                this.Y--;
                this.Life++;
                return;
            }
            
            var sideWaysSpeed = 1.75;
            this.Layer = 1;
            
            if (this.Xa > 2) {
                this.Facing = 1;
            }
            if (this.Xa < -2) {
                this.Facing = -1;
            }
            
            this.Xa = this.Facing * sideWaysSpeed;
            
            this.XFlip = this.Facing === -1;
            this.RunTime += Math.abs(this.Xa) + 5;
            
            if (!this.SubMove(this.Xa, 0)) {
                this.Facing = -this.Facing;
            }
            this.OnGround = false;
            this.SubMove(0, this.Ya);
            
            this.Ya *= 0.85;
            if (this.OnGround) {
                this.Xa *= this.GroundInertia;
            } else {
                this.Xa *= this.AirInertia;
            }
            
            if (!this.OnGround) {
                this.Ya += 2;
            }
        };

        Mario.Mushroom.prototype.SubMove = function(xa, ya) {
            var collide = false;
            
            while (xa > 8) {
                if (!this.SubMove(8, 0)) {
                    return false;
                }
                xa -= 8;
            }
            while (xa < -8) {
                if (!this.SubMove(-8, 0)) {
                    return false;
                }
                xa += 8;
            }
            while (ya > 8) {
                if (!this.SubMove(0, 8)) {
                    return false;
                }
                ya -= 8;
            }
            while (ya < -8) {
                if (!this.SubMove(0, -8)) {
                    return false;
                }
                ya += 8;
            }
            
            if (ya > 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                }
            }
            if (ya < 0) {
                if (this.IsBlocking(this.X + xa, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
            }
            
            if (xa > 0) {
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            if (xa < 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            
            if (collide) {
                if (xa < 0) {
                    this.X = (((this.X - this.Width) / 16) | 0) * 16 + this.Width;
                    this.Xa = 0;
                }
                if (xa > 0) {
                    this.X = (((this.X + this.Width) / 16 + 1) | 0) * 16 - this.Width - 1;
                    this.Xa = 0;
                }
                if (ya < 0) {
                    this.Y = (((this.Y - this.Height) / 16) | 0) * 16 + this.Height;
                    this.JumpTime = 0;
                    this.Ya = 0;
                }
                if (ya > 0) {
                    this.Y = (((this.Y - 1) / 16 + 1) | 0) * 16 - 1;
                    this.OnGround = true;
                }
                
                return false;
            } else {
                this.X += xa;
                this.Y += ya;
                return true;
            }
        };

        Mario.Mushroom.prototype.IsBlocking = function(x, y, xa, ya) {
            x = (x / 16) | 0;
            y = (y / 16) | 0;
            
            if (x === (this.X / 16) | 0 && y === (this.Y / 16) | 0) {
                return false;
            }
            
            return this.World.Level.IsBlocking(x, y, xa, ya);
        };

        Mario.Mushroom.prototype.BumpCheck = function(x, y) {
            if (this.X + this.Width > x * 16 && this.X - this.Width < x * 16 - 16 && y === ((y - 1) / 16) | 0) {
                this.Facing = -Mario.MarioCharacter.Facing;
                this.Ya = -10;
            }
        };

        Mario.Particle = function(world, x, y, xa, ya, xPic, yPic) {
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Xa = xa;
            this.Ya = ya;
            this.XPic = (Math.random() * 2) | 0;
            this.YPic = 0;
            this.XPicO = 4;
            this.YPicO = 4;
            
            this.PicWidth = 8;
            this.PicHeight = 8;
            this.Life = 10;
            
            this.Image = Enjine.Resources.Images["particles"];
        };

        Mario.Particle.prototype = new Mario.NotchSprite();

        Mario.Particle.prototype.Move = function() {
            if (this.Life - this.Delta < 0) {
                this.World.RemoveSprite(this);
            }
            this.Life -= this.Delta;
            
            this.X += this.Xa;
            this.Y += this.Ya;
            this.Ya *= 0.95;
            this.Ya += 3;
        };

        Mario.FireFlower = function(world, x, y) {
            this.Width = 4;
            this.Height = 24;
            
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Image = Enjine.Resources.Images["items"];
            
            this.XPicO = 8;
            this.YPicO = 15;
            this.XPic = 1;
            this.YPic = 0;
            this.Height = 12;
            this.Facing = 1;
            this.PicWidth = this.PicHeight = 16;
            
            this.Life = 0;
        };

        Mario.FireFlower.prototype = new Mario.NotchSprite();

        Mario.FireFlower.prototype.CollideCheck = function() {
            var xMarioD = Mario.MarioCharacter.X - this.X, yMarioD = Mario.MarioCharacter.Y - this.Y;
            if (xMarioD > -16 && xMarioD < 16) {
                if (yMarioD > -this.Height && yMarioD < Mario.MarioCharacter.Height) {
                    Mario.MarioCharacter.GetFlower();
                    this.World.RemoveSprite(this);
                }
            }
        };

        Mario.FireFlower.prototype.Move = function() {
            if (this.Life < 9) {
                this.Layer = 0;
                this.Y--;
                this.Life++;
                return;
            }
        };

        Mario.BulletBill = function(world, x, y, dir) {
            this.Image = Enjine.Resources.Images["enemies"];
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Facing = dir;
            
            this.XPicO = 8;
            this.YPicO = 31;
            this.Height = 12;
            this.Width = 4;
            this.PicWidth = 16;
            this.YPic = 5;
            this.XPic = 0;
            this.Ya = -5;
            this.DeadTime = 0;
            this.Dead = false;
            this.Anim = 0;
        };

        Mario.BulletBill.prototype = new Mario.NotchSprite();

        Mario.BulletBill.prototype.CollideCheck = function() {
            if (this.Dead) {
                return;
            }
            
            var xMarioD = Mario.MarioCharacter.X - this.X, yMarioD = Mario.MarioCharacter.Y - this.Y;
            if (xMarioD > -16 && xMarioD < 16) {
                if (yMarioD > -this.Height && yMarioD < this.World.Mario.Height) {
                    if (Mario.MarioCharacter.Y > 0 && yMarioD <= 0 && (!Mario.MarioCharacter.OnGround || !Mario.MarioCharacter.WasOnGround)) {
                        Mario.MarioCharacter.Stomp(this);
                        this.Dead = true;
                        
                        this.Xa = 0;
                        this.Ya = 1;
                        this.DeadTime = 100;
                    } else {
                        Mario.MarioCharacter.GetHurt();
                    }
                }
            }
        };

        Mario.BulletBill.prototype.Move = function() {
            var i = 0, sideWaysSpeed = 4;
            if (this.DeadTime > 0) {
                this.DeadTime--;
                
                if (this.DeadTime === 0) {
                    this.DeadTime = 1;
                    for (i = 0; i < 8; i++) {
                        this.World.AddSprite(new Mario.Sparkle(((this.X + Math.random() * 16 - 8) | 0) + 4, ((this.Y + Math.random() * 8) | 0) + 4, Math.random() * 2 - 1, Math.random() * -1, 0, 1, 5));
                    }
                    this.World.RemoveSprite(this);
                }
                
                this.X += this.Xa;
                this.Y += this.Ya;
                this.Ya *= 0.95;
                this.Ya += 1;
                
                return;
            }
            
            this.Xa = this.Facing * sideWaysSpeed;
            this.XFlip = this.Facing === -1;
            this.Move(this.Xa, 0);
        };

        Mario.BulletBill.prototype.SubMove = function(xa, ya) {
            this.X += xa;
            return true;
        };

        Mario.BulletBill.prototype.FireballCollideCheck = function(fireball) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xD = fireball.X - this.X, yD = fireball.Y - this.Y;
            if (xD > -16 && xD < 16) {
                if (yD > -this.Height && yD < fireball.Height) {
                    return true;
                }
            }
            return false;
        };

        Mario.BulletBill.prototype.ShellCollideCheck = function(shell) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xD = shell.X - this.X, yD = shell.Y - this.Y;
            if (xD > -16 && xD < 16) {
                if (yD > -this.Height && yD < shell.Height) {
                    Enjine.Resources.PlaySound("kick");
                    this.Dead = true;
                    this.Xa = 0;
                    this.Ya = 1;
                    this.DeadTime = 100;
                    return true;
                }
            }
            return false;
        };

        Mario.FlowerEnemy = function(world, x, y) {
            this.Image = Enjine.Resources.Images["enemies"];
            this.World = world;
            this.X = x;
            this.Y = y;
            this.Facing = 1;
            this.Type = Mario.Enemy.Spiky;
            this.Winged = false;
            this.NoFireballDeath = false;
            this.XPic = 0;
            this.YPic = 6;
            this.YPicO = 24;
            this.Height = 12;
            this.Width = 2;
            this.YStart = y;
            this.Ya = -8;
            this.Y -= 1;
            this.Layer = 0;
            this.JumpTime = 0;
            this.Tick = 0;
            
            var i = 0;
            for (i = 0; i < 4; i++) {
                this.Move();
            }
        };

        Mario.FlowerEnemy.prototype = new Mario.Enemy();

        Mario.FlowerEnemy.prototype.Move = function() {
            var i = 0, xd = 0;
            if (this.DeadTime > 0) {
                this.DeadTime--;
                
                if (this.DeadTime === 0) {
                    this.DeadTime = 1;
                    for (i = 0; i < 8; i++) {
                        this.World.AddSprite(new Mario.Sparkle(((this.X + Math.random() * 16 - 8) | 0)  + 4, ((this.Y + Math.random() * 8) | 0) + 4, Math.random() * 2 - 1, Math.random() * -1, 0, 1, 5));
                    }
                    this.World.RemoveSprite(this);
                }
                
                this.X += this.Xa;
                this.Y += this.Ya;
                this.Ya *= 0.95;
                this.Ya += 1;
                
                return;
            }
            
            this.Tick++;
            
            if (this.Y >= this.YStart) {
                this.YStart = this.Y;
                xd = Math.abs(Mario.MarioCharacter.X - this.X) | 0;
                this.JumpTime++;
                if (this.JumpTime > 40 && xd > 24) {
                    this.Ya = -8;
                } else {
                    this.Ya = 0;
                }
            } else {
                this.JumpTime = 0;
            }
            
            this.Y += this.Ya;
            this.Ya *= 0.9;
            this.Ya += 0.1;
            
            this.XPic = (((this.Tick / 2) | 0) & 1) * 2 + (((this.Tick / 6) | 0) & 1);
        };

        Mario.Shell = function(world, x, y, type) {
            this.World = world;
            this.X = x;
            this.Y = y;
            
            this.YPic = type;
            this.Image = Enjine.Resources.Images["enemies"];
            
            this.XPicO = 8;
            this.YPicO = 31;
            this.Width = 4;
            this.Height = 12;
            this.Facing = 0;
            this.PicWidth = 16;
            this.XPic = 4;
            this.Ya = -5;
            
            this.Dead = false;
            this.DeadTime = 0;
            this.Carried = false;
            
            this.GroundInertia = 0.89;
            this.AirInertia = 0.89;
            this.OnGround = false;
            this.Anim = 0;
        };

        Mario.Shell.prototype = new Mario.NotchSprite();

        Mario.Shell.prototype.FireballCollideCheck = function(fireball) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xD = fireball.X - this.X, yD = fireball.Y - this.Y;
            if (xD > -16 && xD < 16) {
                if (yD > -this.Height && yD < fireball.Height) {
                    if (this.Facing !== 0) {
                        return true;
                    }
                    
                    Enjine.Resources.PlaySound("kick");
                    
                    this.Xa = fireball.Facing * 2;
                    this.Ya = -5;
                    if (this.SpriteTemplate !== null) {
                        this.SpriteTemplate.IsDead = true;
                    }
                    this.DeadTime = 100;
                    this.YFlip = true;
                    
                    return true;
                }
            }
            return false;
        };

        Mario.Shell.prototype.CollideCheck = function() {
            if (this.Carried || this.Dead || this.DeadTime > 0) {
                return;
            }
            
            var xMarioD = Mario.MarioCharacter.X - this.X, yMarioD = Mario.MarioCharacter.Y - this.Y;
            if (xMarioD > -16 && xMarioD < 16) {
                if (yMarioD > -this.Height && yMarioD < Mario.MarioCharacter.Height) {
                    if (Mario.MarioCharacter.Ya > 0 && yMarioD <= 0 && (!Mario.MarioCharacter.OnGround || !Mario.MarioCharacter.WasOnGround)) {
                        Mario.MarioCharacter.Stomp(this);
                        if (this.Facing !== 0) {
                            this.Xa = 0;
                            this.Facing = 0;
                        } else {
                            this.Facing = Mario.MarioCharacter.Facing;
                        }
                    } else {
                        if (this.Facing !== 0) {
                            Mario.MarioCharacter.GetHurt();
                        } else {
                            Mario.MarioCharacter.Kick(this);
                            this.Facing = Mario.MarioCharacter.Facing;
                        }
                    }
                }
            }
        };

        Mario.Shell.prototype.Move = function() {
            var sideWaysSpeed = 11, i = 0;
            if (this.Carried) {
                this.World.CheckShellCollide(this);
                return;
            }
            
            if (this.DeadTime > 0) {
                this.DeadTime--;
                
                if (this.DeadTime === 0) {
                    this.DeadTime = 1;
                    for (i = 0; i < 8; i++) {
                        this.World.AddSprite(new Mario.Sparkle(((this.X + Math.random() * 16 - 8) | 0) + 4, ((this.Y + Math.random() * 8) | 0) + 4, Math.random() * 2 - 1, Math.random() * -1, 0, 1, 5));
                    }
                    this.World.RemoveSprite(this);
                }
                
                this.X += this.Xa;
                this.Y += this.Ya;
                this.Ya *= 0.95;
                this.Ya += 1;
                return;
            }
            
            if (this.Facing !== 0) {
                this.Anim++;
            }
            
            if (this.Xa > 2) {
                this.Facing = 1;
            }
            if (this.Xa < -2) {
                this.Facing = -1;
            }
            
            this.Xa = this.Facing * sideWaysSpeed;
            
            if (this.Facing !== 0) {
                this.World.CheckShellCollide(this);
            }
            
            this.XFlip = this.Facing === -1;
            
            this.XPic = ((this.Anim / 2) | 0) % 4 + 3;
            
            if (!this.SubMove(this.Xa, 0)) {
                Enjine.Resources.PlaySound("bump");
                this.Facing = -this.Facing;
            }
            this.OnGround = false;
            this.SubMove(0, this.Ya);
            
            this.Ya *= 0.85;
            if (this.OnGround) {
                this.Xa *= this.GroundInertia;
            } else {
                this.Xa *= this.AirInertia;
            }
            
            if (!this.OnGround) {
                this.Ya += 2;
            }
        };

        Mario.Shell.prototype.SubMove = function(xa, ya) {
            var collide = false;
            
            while (xa > 8) {
                if (!this.SubMove(8, 0)) {
                    return false;
                }
                xa -= 8;
            }
            while (xa < -8) {
                if (!this.SubMove(-8, 0)) {
                    return false;
                }
                xa += 8;
            }
            while (ya > 8) {
                if (!this.SubMove(0, 8)) {
                    return false;
                }
                ya -= 8;
            }
            while (ya < -8) {
                if (!this.SubMove(0, -8)) {
                    return false;
                }
                ya += 8;
            }
            
            if (ya > 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, 0)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                } else if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya + 1, xa, ya)) {
                    collide = true;
                }
            }
            if (ya < 0) {
                if (this.IsBlocking(this.X + xa, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                } else if (collide || this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
            }
            
            if (xa > 0) {
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa + this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            if (xa < 0) {
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - this.Height, xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya - ((this.Height / 2) | 0), xa, ya)) {
                    collide = true;
                }
                if (this.IsBlocking(this.X + xa - this.Width, this.Y + ya, xa, ya)) {
                    collide = true;
                }
            }
            
            if (collide) {
                if (xa < 0) {
                    this.X = (((this.X - this.Width) / 16) | 0) * 16 + this.Width;
                    this.Xa = 0;
                }
                if (xa > 0) {
                    this.X = (((this.X + this.Width) / 16 + 1) | 0) * 16 - this.Width - 1;
                    this.Xa = 0;
                }
                if (ya < 0) {
                    this.Y = (((this.Y - this.Height) / 16) | 0) * 16 + this.Height;
                    this.Ya = 0;
                }
                if (ya > 0) {
                    this.Y = (((this.Y - 1) / 16 + 1) | 0) * 16 - 1;
                    this.OnGround = true;
                }
                
                return false;
            } else {
                this.X += xa;
                this.Y += ya;
                return true;
            }
        };

        Mario.Shell.prototype.IsBlocking = function(x, y, xa, ya) {
            x = (x / 16) | 0;
            y = (y / 16) | 0;
            
            if (x === ((this.X / 16) | 0) && y === ((this.Y / 16) | 0)) {
                return false;
            }
            
            var blocking = this.World.Level.IsBlocking(x, y, xa, ya);
            
            if (blocking && ya === 0 && xa !== 0) {
                this.World.Bump(x, y, true);
            }
            return blocking;
        };

        Mario.Shell.prototype.BumpCheck = function(x, y) {
            if (this.X + this.Width > x * 16 && this.X - this.Width < x * 16 + 16 && y === (((this.Y - 1) / 16) | 0)) {
                this.Facing = -Mario.MarioCharacter.Facing;
                this.Ya = -10;
            }
        };

        Mario.Shell.prototype.Die = function() {
            this.Dead = true;
            this.Carried = false;
            this.Xa = -this.Facing * 2;
            this.Ya = -5;
            this.DeadTime = 100;
        };

        Mario.Shell.prototype.ShellCollideCheck = function(shell) {
            if (this.DeadTime !== 0) {
                return false;
            }
            
            var xD = shell.X - this.X, yD = shell.Y - this.Y;
            if (xD > -16 && xD < 16) {
                if (yD > -this.Height && yD < shell.Height) {
                    Enjine.Resources.PlaySound("kick");
                    if (Mario.MarioCharacter.Carried === shell || Mario.MarioCharacter.Carried === this) {
                        Mario.MarioCharacter.Carried = null;
                    }
                    this.Die();
                    shell.Die();
                    return true;
                }
            }
            return false;
        };

        Mario.Shell.prototype.Release = function(mario) {
            this.Carried = false;
            this.Facing = Mario.MarioCharacter.Facing;
            this.X += this.Facing * 8;
        };

        Mario.TitleState = function() {
            this.drawManager = null;
            this.camera = null;
            this.logoY = null;
            this.bounce = null;
            this.font = null;
        };

        Mario.TitleState.prototype = new Enjine.GameState();

        Mario.TitleState.prototype.Enter = function() {
            this.drawManager = new Enjine.DrawableManager();
            this.camera = new Enjine.Camera();

            var bgGenerator = new Mario.BackgroundGenerator(2048, 15, true, Mario.LevelType.Overground);
            var bgLayer0 = new Mario.BackgroundRenderer(bgGenerator.CreateLevel(), 320, 240, 2);
            bgGenerator.SetValues(2048, 15, false, Mario.LevelType.Overground);
            var bgLayer1 = new Mario.BackgroundRenderer(bgGenerator.CreateLevel(), 320, 240, 1);

            this.title = new Enjine.Sprite();
            this.title.Image = Enjine.Resources.Images["title"];
            this.title.X = 0, this.title.Y = 120;

            this.logo = new Enjine.Sprite();
            this.logo.Image = Enjine.Resources.Images["logo"];
            this.logo.X = 0, this.logo.Y = 0;

            this.font = Mario.SpriteCuts.CreateRedFont();
            this.font.Strings[0] = { String: "Press S to Start", X: 96, Y: 120 };

            this.logoY = 20;

            this.drawManager.Add(bgLayer0);
            this.drawManager.Add(bgLayer1);

            this.bounce = 0;

            Mario.GlobalMapState = new Mario.MapState();
            //set up the global main character variable
            Mario.MarioCharacter = new Mario.Character();
            Mario.MarioCharacter.Image = Enjine.Resources.Images["smallMario"];

        };

        Mario.TitleState.prototype.Exit = function() {
    
            
            this.drawManager.Clear();
            delete this.drawManager;
            delete this.camera;
            delete this.font;
        };

        Mario.TitleState.prototype.Update = function(delta) {
            this.bounce += delta * 2;
            this.logoY = 20 + Math.sin(this.bounce) * 10;

            this.camera.X += delta * 25;

            this.drawManager.Update(delta);
        };

        Mario.TitleState.prototype.Draw = function(context) {
            this.drawManager.Draw(context, this.camera);

            context.drawImage(Enjine.Resources.Images["title"], 0, 120);
            context.drawImage(Enjine.Resources.Images["logo"], 0, this.logoY);

            this.font.Draw(context, this.Camera);
        };

        Mario.TitleState.prototype.CheckForChange = function(context) {
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.S)) {
                context.ChangeState(Mario.GlobalMapState);
            }
        };

        Mario.LoadingState = function() {
            this.Images = [];
            this.ImagesLoaded = false;
            this.ScreenColor = 0;
            this.ColorDirection = 1;
            this.ImageIndex = 0;
            this.SoundIndex = 0;
        };

        Mario.LoadingState.prototype = new Enjine.GameState();

        Mario.LoadingState.prototype.Enter = function() {
            var i = 0;
            for (i = 0; i < 15; i++) {
                this.Images[i] = {};
            }
            
            this.Images[0].name = "background";
            this.Images[1].name = "endScene";
            this.Images[2].name = "enemies";
            this.Images[3].name = "fireMario";
            this.Images[4].name = "font";
            this.Images[5].name = "gameOverGhost";
            this.Images[6].name = "items";
            this.Images[7].name = "logo";
            this.Images[8].name = "map";
            this.Images[9].name = "mario";
            this.Images[10].name = "particles";
            this.Images[11].name = "racoonMario";
            this.Images[12].name = "smallMario";
            this.Images[13].name = "title";
            this.Images[14].name = "worldMap";

            this.Images[0].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/bgsheet.png";
            this.Images[1].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/endscene.gif";
            this.Images[2].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/enemysheet.png";
            this.Images[3].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/firemariosheet.png";
            this.Images[4].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/font.gif";
            this.Images[5].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/gameovergost.gif";
            this.Images[6].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/itemsheet.png";
            this.Images[7].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/nftbros.gif";
            this.Images[8].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/mapsheet.png";
            this.Images[9].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/mariosheet.png";
            this.Images[10].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/particlesheet.png";
            this.Images[11].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/racoonmariosheet.png";
            this.Images[12].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/smallmariosheet.png";
            this.Images[13].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/title.gif";
            this.Images[14].src = "https://raw.githubusercontent.com/CopeBears/testupload/main/imagesMario/worldmap.png";
            
            Enjine.Resources.AddImages(this.Images);
            
            var testAudio = new Audio();
            
            if (testAudio.canPlayType("audio/mp3")) {
                Enjine.Resources.AddSound("1up", "https://github.com/CopeBears/testupload/blob/main/soundsMario/1-up.mp3?raw=true", 1)
                    .AddSound("breakblock", "https://github.com/CopeBears/testupload/blob/main/soundsMario/breakblock.mp3?raw=true")
                    .AddSound("bump", "https://github.com/CopeBears/testupload/blob/main/soundsMario/bump.mp3?raw=true", 4)
                    .AddSound("cannon", "https://github.com/CopeBears/testupload/blob/main/soundsMario/cannon.mp3?raw=true")
                    .AddSound("coin", "https://github.com/CopeBears/testupload/blob/main/soundsMario/coin.mp3?raw=true", 5)
                    .AddSound("death", "https://github.com/CopeBears/testupload/blob/main/soundsMario/death.mp3?raw=true", 1)
                    .AddSound("exit", "https://github.com/CopeBears/testupload/blob/main/soundsMario/exit.mp3?raw=true", 1)
                    .AddSound("fireball", "https://github.com/CopeBears/testupload/blob/main/soundsMario/fireball.mp3?raw=true", 1)
                    .AddSound("jump", "https://github.com/CopeBears/testupload/blob/main/soundsMario/jump.mp3?raw=true")
                    .AddSound("kick", "https://github.com/CopeBears/testupload/blob/main/soundsMario/kick.mp3?raw=true")
                    .AddSound("pipe", "https://github.com/CopeBears/testupload/blob/main/soundsMario/pipe.mp3?raw=true", 1)
                    .AddSound("powerdown", "https://github.com/CopeBears/testupload/blob/main/soundsMario/powerdown.mp3?raw=true", 1)
                    .AddSound("powerup", "https://github.com/CopeBears/testupload/blob/main/soundsMario/powerup.mp3?raw=true", 1)
                    .AddSound("sprout", "https://github.com/CopeBears/testupload/blob/main/soundsMario/sprout.mp3?raw=true", 1)
                    .AddSound("stagestart", "https://github.com/CopeBears/testupload/blob/main/soundsMario/stagestart.mp3?raw=true", 1)
                    .AddSound("stomp", "https://github.com/CopeBears/testupload/blob/main/soundsMario/stomp.mp3?raw=true", 2);
            } else {
                Enjine.Resources.AddSound("1up", "https://github.com/CopeBears/testupload/blob/main/soundsMario/1-up.wav?raw=true", 1)
                    .AddSound("breakblock", "https://github.com/CopeBears/testupload/blob/main/soundsMario/breakblock.wav?raw=true")
                    .AddSound("bump", "https://github.com/CopeBears/testupload/blob/main/soundsMario/bump.wav?raw=true", 2)
                    .AddSound("cannon", "https://github.com/CopeBears/testupload/blob/main/soundsMario/cannon.wav?raw=true")
                    .AddSound("coin", "https://github.com/CopeBears/testupload/blob/main/soundsMario/coin.wav?raw=true", 5)
                    .AddSound("death", "https://github.com/CopeBears/testupload/blob/main/soundsMario/death.wav?raw=true", 1)
                    .AddSound("exit", "https://github.com/CopeBears/testupload/blob/main/soundsMario/exit.wav?raw=true", 1)
                    .AddSound("fireball", "https://github.com/CopeBears/testupload/blob/main/soundsMario/fireball.wav?raw=true", 1)
                    .AddSound("jump", "https://github.com/CopeBears/testupload/blob/main/soundsMario/jump.wav?raw=true", 1)
                    .AddSound("kick", "https://github.com/CopeBears/testupload/blob/main/soundsMario/kick.wav?raw=true", 1)
                    .AddSound("message", "https://github.com/CopeBears/testupload/blob/main/soundsMario/message.wav?raw=true", 1)
                    .AddSound("pipe", "https://github.com/CopeBears/testupload/blob/main/soundsMario/pipe.wav?raw=true", 1)
                    .AddSound("powerdown", "https://github.com/CopeBears/testupload/blob/main/soundsMario/powerdown.wav?raw=true", 1)
                    .AddSound("powerup", "https://github.com/CopeBears/testupload/blob/main/soundsMario/powerup.wav?raw=true", 1)
                    .AddSound("sprout", "https://github.com/CopeBears/testupload/blob/main/soundsMario/sprout.wav?raw=true", 1)
                    .AddSound("stagestart", "https://github.com/CopeBears/testupload/blob/main/soundsMario/stagestart.wav?raw=true", 1)
                    .AddSound("stomp", "https://github.com/CopeBears/testupload/blob/main/soundsMario/stomp.wav?raw=true", 1);
            }

            //load the array of tile behaviors
            Mario.Tile.LoadBehaviors();
        };

        Mario.LoadingState.prototype.Exit = function() {
            delete this.Images;
        };

        Mario.LoadingState.prototype.Update = function(delta) {
            if (!this.ImagesLoaded) {
                this.ImagesLoaded = true;
                var i = 0;
                for (i = 0; i < this.Images.length; i++) {
                    if (Enjine.Resources.Images[this.Images[i].name].complete !== true) {
                        this.ImagesLoaded = false;
                        break;
                    }
                }
            }
            
            this.ScreenColor += this.ColorDirection * 255 * delta;
            if (this.ScreenColor > 255) {
                this.ScreenColor = 255;
                this.ColorDirection = -1;
            } else if (this.ScreenColor < 0) {
                this.ScreenColor = 0;
                this.ColorDirection = 1;
            }
        };

        Mario.LoadingState.prototype.Draw = function(context) {
            if (!this.ImagesLoaded) {
                var color = parseInt(this.ScreenColor, 10);
                context.fillStyle = "rgb(" + color + "," + color + "," + color + ")";
                context.fillRect(0, 0, 640, 480);
            } else {
                context.fillStyle = "rgb(0, 0, 0)";
                context.fillRect(0, 0, 640, 480);
            }
        };

        Mario.LoadingState.prototype.CheckForChange = function(context) {
            if (this.ImagesLoaded) {
                //set up the global map state variable
                Mario.GlobalMapState = new Mario.MapState();
            
                context.ChangeState(new Mario.TitleState());
            }
        };

        Mario.LoseState = function() {
            this.drawManager = null;
            this.camera = null;
            this.gameOver = null;
            this.font = null;
            this.wasKeyDown = false;
        };

        Mario.LoseState.prototype = new Enjine.GameState();

        Mario.LoseState.prototype.Enter = function() {
            this.drawManager = new Enjine.DrawableManager();
            this.camera = new Enjine.Camera();
            
            this.gameOver = new Enjine.AnimatedSprite();
            this.gameOver.Image = Enjine.Resources.Images["gameOverGhost"];
            this.gameOver.SetColumnCount(9);
            this.gameOver.SetRowCount(1);
            this.gameOver.AddNewSequence("turnLoop", 0, 0, 0, 8);
            this.gameOver.PlaySequence("turnLoop", true);
            this.gameOver.FramesPerSecond = 1/15;
            this.gameOver.X = 112;
            this.gameOver.Y = 68;
            
            this.font = Mario.SpriteCuts.CreateBlackFont();
            this.font.Strings[0] = { String: "Game over!", X: 116, Y: 160 };
            
            this.drawManager.Add(this.font);
            this.drawManager.Add(this.gameOver);
        };

        Mario.LoseState.prototype.Exit = function() {
            this.drawManager.Clear();
            delete this.drawManager;
            delete this.camera;
            delete this.gameOver;
            delete this.font;
        };

        Mario.LoseState.prototype.Update = function(delta) {
            this.drawManager.Update(delta);
            if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space)) {
                this.wasKeyDown = true;
            }
        };

        Mario.LoseState.prototype.Draw = function(context) {
            this.drawManager.Draw(context, this.camera);
        };

        Mario.LoseState.prototype.CheckForChange = function(context) {
            if (this.wasKeyDown && !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space)) {
                context.ChangeState(new Mario.TitleState());
            }
        };
 
        Mario.WinState = function() {
            this.waitTime = 2;
            this.drawManager = null;
            this.camera = null;
            this.font = null;
            this.kissing = null;
            this.wasKeyDown = false;
        };

        Mario.WinState.prototype = new Enjine.GameState();

        Mario.WinState.prototype.Enter = function() {
            this.drawManager = new Enjine.DrawableManager();
            this.camera = new Enjine.Camera();
            
            this.font = Mario.SpriteCuts.CreateBlackFont();
            this.font.Strings[0] = { String: "Thank you for saving me, Mario!", X: 36, Y: 160 };
            
            this.kissing = new Enjine.AnimatedSprite();
            this.kissing.Image = Enjine.Resources.Images["endScene"];
            this.kissing.X = 112;
            this.kissing.Y = 52;
            this.kissing.SetColumnCount(2);
            this.kissing.SetRowCount(1);
            this.kissing.AddNewSequence("loop", 0, 0, 0, 1);
            this.kissing.PlaySequence("loop", true);
            this.kissing.FramesPerSecond = 1/2;
            
            this.waitTime = 2;
            
            this.drawManager.Add(this.font);
            this.drawManager.Add(this.kissing);
        };

        Mario.WinState.prototype.Exit = function() {
            this.drawManager.Clear();
            delete this.drawManager;
            delete this.camera;
        };

        Mario.WinState.prototype.Update = function(delta) {
            this.drawManager.Update(delta);
            
            if (this.waitTime > 0) {
                this.waitTime -= delta;
            } else {
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space)) {
                    this.wasKeyDown = true;
                }
            }
        };

        Mario.WinState.prototype.Draw = function(context) {
            this.drawManager.Draw(context, this.camera);
        };

        Mario.WinState.prototype.CheckForChange = function(context) {
            if (this.waitTime <= 0) {
                if (this.wasKeyDown && !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space)) {
                    context.ChangeState(new Mario.TitleState());
                }
            }
        };

        Mario.MapTile = {
            Grass: 0,
            Water: 1,
            Level: 2,
            Road: 3,
            Decoration: 4
        };

        Mario.MapState = function() {
            this.camera = new Enjine.Camera();

            this.Level = [];
            this.Data = [];
            this.XMario = 0; this.YMario = 0;
            this.XMarioA = 0; this.YMarioA = 0;
            this.MoveTime = 0;
            this.LevelId = 0;
            this.Farthest = 0;
            this.XFarthestCap = 0;
            this.YFarthestCap = 0;
            this.MapImage = document.createElement("canvas");
            this.MapImage.width = 320;
            this.MapImage.height = 240;
            this.MapContext = this.MapImage.getContext("2d");
            this.CanEnterLevel = false;
            this.EnterLevel = false;
            this.LevelDifficulty = 0;
            this.LevelType = 0;

            this.WorldNumber = -1;
            this.NextWorld();
        };

        Mario.MapState.prototype = new Enjine.GameState();

        Mario.MapState.prototype.Enter = function() {
            this.WaterSprite = new Enjine.AnimatedSprite();
            this.WaterSprite.Image = Enjine.Resources.Images["worldMap"];
            this.WaterSprite.SetColumnCount(16);
            this.WaterSprite.SetRowCount(16);
            this.WaterSprite.AddNewSequence("loop", 14, 0, 14, 3);
            this.WaterSprite.FramesPerSecond = 1/3;
            this.WaterSprite.PlaySequence("loop", true);
            this.WaterSprite.X = 0;
            this.WaterSprite.Y = 0;

            this.DecoSprite = new Enjine.AnimatedSprite();
            this.DecoSprite.Image = Enjine.Resources.Images["worldMap"];
            this.DecoSprite.SetColumnCount(16);
            this.DecoSprite.SetRowCount(16);
            this.DecoSprite.AddNewSequence("world0", 10, 0, 10, 3);
            this.DecoSprite.AddNewSequence("world1", 11, 0, 11, 3);
            this.DecoSprite.AddNewSequence("world2", 12, 0, 12, 3);
            this.DecoSprite.AddNewSequence("world3", 13, 0, 13, 3);
            this.DecoSprite.FramesPerSecond = 1/3;
            this.DecoSprite.PlaySequence("world0", true);
            this.DecoSprite.X = 0;
            this.DecoSprite.Y = 0;

            this.HelpSprite = new Enjine.AnimatedSprite();
            this.HelpSprite.Image = Enjine.Resources.Images["worldMap"];
            this.HelpSprite.SetColumnCount(16);
            this.HelpSprite.SetRowCount(16);
            this.HelpSprite.AddNewSequence("help", 7, 3, 7, 5);
            this.HelpSprite.FramesPerSecond = 1/2;
            this.HelpSprite.PlaySequence("help", true);
            this.HelpSprite.X = 0;
            this.HelpSprite.Y = 0;

            this.SmallMario = new Enjine.AnimatedSprite();
            this.SmallMario.Image = Enjine.Resources.Images["worldMap"];
            this.SmallMario.SetColumnCount(16);
            this.SmallMario.SetRowCount(16);
            this.SmallMario.AddNewSequence("small", 1, 0, 1, 1);
            this.SmallMario.FramesPerSecond = 1/3;
            this.SmallMario.PlaySequence("small", true);
            this.SmallMario.X = 0;
            this.SmallMario.Y = 0;

            this.LargeMario = new Enjine.AnimatedSprite();
            this.LargeMario.Image = Enjine.Resources.Images["worldMap"];
            this.LargeMario.SetColumnCount(16);
            this.LargeMario.SetRowCount(8);
            this.LargeMario.AddNewSequence("large", 0, 2, 0, 3);
            this.LargeMario.AddNewSequence("fire", 0, 4, 0, 5);
            this.LargeMario.FramesPerSecond = 1/3;
            this.LargeMario.PlaySequence("large", true);
            this.LargeMario.X = 0;
            this.LargeMario.Y = 0;

            this.FontShadow = Mario.SpriteCuts.CreateBlackFont();
            this.Font = Mario.SpriteCuts.CreateWhiteFont();

            //get the correct world decoration
            this.DecoSprite.PlaySequence("world" + (this.WorldNumber % 4), true);

            if (!Mario.MarioCharacter.Fire) {
                this.LargeMario.PlaySequence("large", true);
            } else {
                this.LargeMario.PlaySequence("fire", true);
            }

            this.EnterLevel = false;
            this.LevelDifficulty = 0;
            this.LevelType = 0;

            
        };

        Mario.MapState.prototype.Exit = function() {
            

            delete this.WaterSprite;
            delete this.DecoSprite;
            delete this.HelpSprite;
            delete this.SmallMario;
            delete this.LargeMario;
            delete this.FontShadow;
            delete this.Font;
        };

        Mario.MapState.prototype.NextWorld = function() {
            var generated = false;
            this.WorldNumber++;

            //The player has won, wait for CheckForChange to get called
            if (this.WorldNumber === 8) {
                return;
            }

            this.MoveTime = 0;
            this.LevelId = 0;
            this.Farthest = 0;
            this.XFarthestCap = 0;
            this.YFarthestCap = 0;

            while (!generated) {
                generated = this.GenerateLevel();
            }
            this.RenderStatic();
        };

        Mario.MapState.prototype.GenerateLevel = function() {
            var x = 0, y = 0, t0 = 0, t1 = 0, td = 0, t = 0;

            var n0 = new Mario.ImprovedNoise((Math.random() * 9223372036854775807) | 0);
            var n1 = new Mario.ImprovedNoise((Math.random() * 9223372036854775807) | 0);
            var dec = new Mario.ImprovedNoise((Math.random() * 9223372036854775807) | 0);

            var width = 320 / 16 + 1;
            var height = 240 / 16 + 1;
            this.Level = [];
            this.Data = [];

            var xo0 = Math.random() * 512;
            var yo0 = Math.random() * 512;
            var xo1 = Math.random() * 512;
            var yo1 = Math.random() * 512;

            for (x = 0; x < width; x++) {
                this.Level[x] = [];
                this.Data[x] = [];

                for (y = 0; y < height; y++) {

                    t0 = n0.PerlinNoise(x * 10 + xo0, y * 10 + yo0);
                    t1 = n1.PerlinNoise(x * 10 + xo1, y * 10 + yo1);
                    td = t0 - t1;
                    t = td * 2;

                    this.Level[x][y] = t > 0 ? Mario.MapTile.Water : Mario.MapTile.Grass;
                }
            }

            var lowestX = 9999, lowestY = 9999, i = 0;
            t = 0;

            for (i = 0; i < 100 && t < 12; i++) {
                x = ((Math.random() * (((width - 1) / 3) | 0)) | 0) * 3 + 2;
                y = ((Math.random() * (((height - 1) / 3) | 0)) | 0) * 3 + 1;
                if (this.Level[x][y] === Mario.MapTile.Grass) {
                    if (x < lowestX) {
                        lowestX = x;
                        lowestY = y;
                    }
                    this.Level[x][y] = Mario.MapTile.Level;
                    this.Data[x][y] = -1;
                    t++;
                }
            }

            this.Data[lowestX][lowestY] = -2;

            var connection = true;
            while (connection) { connection = this.FindConnection(width, height); }
            this.FindCaps(width, height);

            if (this.XFarthestCap === 0) {
                return false;
            }

            this.Data[this.XFarthestCap][this.YFarthestCap] = -2;
            this.Data[(this.XMario / 16) | 0][(this.YMario / 16) | 0] = -11;

            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    if (this.Level[x][y] === Mario.MapTile.Grass && (x !== this.XFarthestCap || y !== this.YFarthestCap - 1)) {
                        t0 = dec.PerlinNoise(x * 10 + xo0, y * 10 + yo0);
                        if (t0 > 0) {
                            this.Level[x][y] = Mario.MapTile.Decoration;
                        }
                    }
                }
            }

            return true;
        };

        Mario.MapState.prototype.FindConnection = function(width, height) {
            var x = 0, y = 0;
            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    if (this.Level[x][y] === Mario.MapTile.Level && this.Data[x][y] === -1) {
                        this.Connect(x, y, width, height);
                        return true;
                    }
                }
            }
            return false;
        };

        Mario.MapState.prototype.Connect = function(xSource, ySource, width, height) {
            var maxDistance = 10000, xTarget = 0, yTarget = 0, x = 0, y = 0,
                xd = 0, yd = 0, d = 0;

            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    if (this.Level[x][y] === Mario.MapTile.Level && this.Data[x][y] === -2) {
                        xd = Math.abs(xSource - x) | 0;
                        yd = Math.abs(ySource - y) | 0;
                        d = xd * xd + yd * yd;
                        if (d < maxDistance) {
                            xTarget = x;
                            yTarget = y;
                            maxDistance = d;
                        }
                    }
                }
            }

            this.DrawRoad(xSource, ySource, xTarget, yTarget);
            this.Level[xSource][ySource] = Mario.MapTile.Level;
            this.Data[xSource][ySource] = -2;
            return;
        };

        Mario.MapState.prototype.DrawRoad = function(x0, y0, x1, y1) {
            var xFirst = false;
            if (Math.random() > 0.5) {
                xFirst = true;
            }

            if (xFirst) {
                while (x0 > x1) {
                    this.Data[x0][y0] = 0;
                    this.Level[x0--][y0] = Mario.MapTile.Road;
                }
                while (x0 < x1) {
                    this.Data[x0][y0] = 0;
                    this.Level[x0++][y0] = Mario.MapTile.Road;
                }
            }

            while (y0 > y1) {
                this.Data[x0][y0] = 0;
                this.Level[x0][y0--] = Mario.MapTile.Road;
            }
            while (y0 < y1) {
                this.Data[x0][y0] = 0;
                this.Level[x0][y0++] = Mario.MapTile.Road;
            }

            if (!xFirst) {
                while (x0 > x1) {
                    this.Data[x0][y0] = 0;
                    this.Level[x0--][y0] = Mario.MapTile.Road;
                }
                while (x0 < x1) {
                    this.Data[x0][y0] = 0;
                    this.Level[x0++][y0] = Mario.MapTile.Road;
                }
            }
        };

        Mario.MapState.prototype.FindCaps = function(width, height) {
            var x = 0, y = 0, xCap = -1, yCap = -1, roads = 0, xx = 0, yy = 0;

            for (x = 0; x < width; x++) {
                for (y = 0; y < height; y++) {
                    if (this.Level[x][y] === Mario.MapTile.Level) {
                        roads = 0;

                        for (xx = x - 1; xx <= x + 1; xx++) {
                            for (yy = y - 1; yy <= y + 1; yy++) {
                                if (this.Level[xx][yy] === Mario.MapTile.Road) {
                                    roads++;
                                }
                            }
                        }

                        if (roads === 1) {
                            if (xCap === -1) {
                                xCap = x;
                                yCap = y;
                            }
                            this.Data[x][y] = 0;
                        } else {
                            this.Data[x][y] = 1;
                        }
                    }
                }
            }

            this.XMario = xCap * 16;
            this.YMario = yCap * 16;

            this.Travel(xCap, yCap, -1, 0);
        };

        Mario.MapState.prototype.Travel = function(x, y, dir, depth) {
            if (this.Level[x][y] !== Mario.MapTile.Road && this.Level[x][y] !== Mario.MapTile.Level) {
                return;
            }

            if (this.Level[x][y] === Mario.MapTile.Road) {
                if (this.Data[x][y] === 1) {
                    return;
                } else {
                    this.Data[x][y] = 1;
                }
            }

            if (this.Level[x][y] === Mario.MapTile.Level) {
                if (this.Data[x][y] > 0) {
                    if (this.LevelId !== 0 && ((Math.random() * 4) | 0) === 0) {
                        this.Data[x][y] = -3;
                    } else {
                        this.Data[x][y] = ++this.LevelId;
                    }
                } else if (depth > 0) {
                    this.Data[x][y] = -1;
                    if (depth > this.Farthest) {
                        this.Farthest = depth;
                        this.XFarthestCap = x;
                        this.YFarthestCap = y;
                    }
                }
            }

            if (dir !== 2) {
                this.Travel(x - 1, y, 0, depth++);
            }
            if (dir !== 3) {
                this.Travel(x, y - 1, 1, depth++);
            }
            if (dir !== 0) {
                this.Travel(x + 1, y, 2, depth++);
            }
            if (dir !== 1) {
                this.Travel(x, y + 1, 3, depth++);
            }
        };

        Mario.MapState.prototype.RenderStatic = function() {
            var x = 0, y = 0, p0 = 0, p1 = 0, p2 = 0, p3 = 0, s = 0, xx = 0, yy = 0,
                image = Enjine.Resources.Images["worldMap"], type = 0;

            //320 / 16 = 20
            for (x = 0; x < 20; x++) {
                //240 / 16 = 15
                for (y = 0; y < 15; y++) {
                    this.MapContext.drawImage(image, ((this.WorldNumber / 4) | 0) * 16, 0, 16, 16, x * 16, y * 16, 16, 16);

                    if (this.Level[x][y] === Mario.MapTile.Level) {
                        type = this.Data[x][y];
                        if (type === 0) {
                            this.MapContext.drawImage(image, 0, 7 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else if (type === -1) {
                            this.MapContext.drawImage(image, 3 * 16, 8 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else if (type === -3) {
                            this.MapContext.drawImage(image, 0, 8 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else if (type === -10) {
                            this.MapContext.drawImage(image, 16, 8 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else if (type === -11) {
                            this.MapContext.drawImage(image, 16, 7 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else if (type === -2) {
                            this.MapContext.drawImage(image, 2 * 16, 7 * 16, 16, 16, x * 16, (y - 1) * 16, 16, 16);
                            this.MapContext.drawImage(image, 2 * 16, 8 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        } else {
                            this.MapContext.drawImage(image, (type - 1) * 16, 6 * 16, 16, 16, x * 16, y * 16, 16, 16);
                        }
                    } else if (this.Level[x][y] === Mario.MapTile.Road) {
                        p0 = this.IsRoad(x - 1, y) ? 1 : 0;
                        p1 = this.IsRoad(x, y - 1) ? 1 : 0;
                        p2 = this.IsRoad(x + 1, y) ? 1 : 0;
                        p3 = this.IsRoad(x, y + 1) ? 1 : 0;
                        s = p0 + (p1 * 2) + (p2 * 4) + (p3 * 8);
                        this.MapContext.drawImage(image, s * 16, 32, 16, 16, x * 16, y * 16, 16, 16);
                    } else if (this.Level[x][y] === Mario.MapTile.Water) {
                        for (xx = 0; xx < 2; xx++) {
                            for (yy = 0; yy < 2; yy++) {
                                p0 = this.IsWater(x * 2 + (xx - 1), y * 2 + (yy - 1)) ? 0 : 1;
                                p1 = this.IsWater(x * 2 + xx, y * 2 + (yy - 1)) ? 0 : 1;
                                p2 = this.IsWater(x * 2 + (xx - 1), y * 2 + yy) ? 0 : 1;
                                p3 = this.IsWater(x * 2 + xx, y * 2 + yy) ? 0 : 1;
                                s = p0 + (p1 * 2) + (p2 * 4) + (p3 * 8) - 1;
                                if (s >= 0 && s <= 14) {
                                    this.MapContext.drawImage(image, s * 16, (4 + ((xx + yy) & 1)) * 16, 16, 16, x * 16 + xx * 8, y * 16 + yy * 8, 16, 16);
                                }
                            }
                        }
                    }
                }
            }
        };

        Mario.MapState.prototype.IsRoad = function(x, y) {
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }
            if (this.Level[x][y] === Mario.MapTile.Road) {
                return true;
            }
            if (this.Level[x][y] === Mario.MapTile.Level) {
                return true;
            }
            return false;
        };

        Mario.MapState.prototype.IsWater = function(x, y) {
            var xx = 0, yy = 0;
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }

            for (xx = 0; xx < 2; xx++) {
                for (yy = 0; yy < 2; yy++) {
                    if (this.Level[((x + xx) / 2) | 0][((y + yy) / 2) | 0] !== Mario.MapTile.Water) {
                        return false;
                    }
                }
            }

            return true;
        };

        Mario.MapState.prototype.Update = function(delta) {
            var x = 0, y = 0, difficulty = 0, type = 0;

            if (this.WorldNumber === 8) {
                return;
            }

            this.XMario += this.XMarioA;
            this.YMario += this.YMarioA;

            x = (this.XMario / 16) | 0;
            y = (this.YMario / 16) | 0;

            if (this.Level[x][y] === Mario.MapTile.Road) {
                this.Data[x][y] = 0;
            }

            if (this.MoveTime > 0) {
                this.MoveTime--;
            } else {
                this.XMarioA = 0;
                this.YMarioA = 0;

                if (this.CanEnterLevel && Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space)) {
                    if (this.Level[x][y] === Mario.MapTile.Level && this.Data[x][y] !== -11) {
                        if (this.Level[x][y] === Mario.MapTile.Level && this.Data[x][y] !== 0 && this.Data[x][y] > -10) {
                            difficulty = this.WorldNumber + 1;
                            Mario.MarioCharacter.LevelString = difficulty + "-";
                            type = Mario.LevelType.Overground;

                            if (this.Data[x][y] > 1 && ((Math.random() * 3) | 0) === 0) {
                                type = Mario.LevelType.Underground;
                            }

                            if (this.Data[x][y] < 0) {
                                if (this.Data[x][y] === -2) {
                                    Mario.MarioCharacter.LevelString += "X";
                                    difficulty += 2;
                                } else if (this.Data[x][y] === -1) {
                                    Mario.MarioCharacter.LevelString += "?";
                                } else {
                                    Mario.MarioCharacter.LevelString += "#";
                                    difficulty += 1;
                                }

                                type = Mario.LevelType.Castle;
                            } else {
                                Mario.MarioCharacter.LevelString += this.Data[x][y];
                            }

                            //TODO: stop music here
                            this.EnterLevel = true;
                            this.LevelDifficulty = difficulty;
                            this.LevelType = type;
                        }
                    }
                }

                this.CanEnterLevel = !Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Space);

                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Left)) {
                    this.TryWalking(-1, 0);
                }
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Right)) {
                    this.TryWalking(1, 0);
                }
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Up)) {
                    this.TryWalking(0, -1);
                }
                if (Enjine.KeyboardInput.IsKeyDown(Enjine.Keys.Down)) {
                    this.TryWalking(0, 1);
                }
            }

            this.WaterSprite.Update(delta);
            this.DecoSprite.Update(delta);
            this.HelpSprite.Update(delta);
            if (!Mario.MarioCharacter.Large) {
                this.SmallMario.X = this.XMario + (this.XMarioA * delta) | 0;
                this.SmallMario.Y = this.YMario + ((this.YMarioA * delta) | 0) - 6;
                this.SmallMario.Update(delta);
            } else {
                this.LargeMario.X = this.XMario + (this.XMarioA * delta) | 0;
                this.LargeMario.Y = this.YMario + ((this.YMarioA * delta) | 0) - 22;
                this.LargeMario.Update(delta);
            }
        };

        Mario.MapState.prototype.TryWalking = function(xd, yd) {
            var x = (this.XMario / 16) | 0, y = (this.YMario / 16) | 0, xt = x + xd, yt = y + yd;

            if (this.Level[xt][yt] === Mario.MapTile.Road || this.Level[xt][yt] === Mario.MapTile.Level) {
                if (this.Level[xt][yt] === Mario.MapTile.Road) {
                    if ((this.Data[xt][yt] !== 0) && (this.Data[x][y] !== 0 && this.Data[x][y] > -10)) {
                        return;
                    }
                }

                this.XMarioA = xd * 8;
                this.YMarioA = yd * 8;
                this.MoveTime = this.CalcDistance(x, y, xd, yd) * 2 + 1;
            }
        };

        Mario.MapState.prototype.CalcDistance = function(x, y, xa, ya) {
            var distance = 0;
            while (true) {
                x += xa;
                y += ya;
                if (this.Level[x][y] !== Mario.MapTile.Road) {
                    return distance;
                }
                if (this.Level[x - ya][y + xa] === Mario.MapTile.Road) {
                    return distance;
                }
                if (this.Level[x + ya][y - xa] === Mario.MapTile.Road) {
                    return distance;
                }
                distance++;
            }
        };

        Mario.MapState.prototype.Draw = function(context) {
            var x = 0, y = 0;

            if (this.WorldNumber === 8) {
                return;
            }

            context.drawImage(this.MapImage, 0, 0);

            for (y = 0; y <= 15; y++) {
                for (x = 20; x >= 0; x--) {
                    if (this.Level[x][y] === Mario.MapTile.Water) {
                        if (this.IsWater(x * 2 - 1, y * 2 - 1)) {
                            this.WaterSprite.X = x * 16 - 8;
                            this.WaterSprite.Y = y * 16 - 8;
                            this.WaterSprite.Draw(context, this.camera);
                        }
                    } else if (this.Level[x][y] === Mario.MapTile.Decoration) {
                        this.DecoSprite.X = x * 16;
                        this.DecoSprite.Y = y * 16;
                        this.DecoSprite.Draw(context, this.camera);
                    } else if (this.Level[x][y] === Mario.MapTile.Level && this.Data[x][y] === -2) {
                        this.HelpSprite.X = x * 16 + 16;
                        this.HelpSprite.Y = y * 16 - 16;
                        this.HelpSprite.Draw(context, this.camera);
                    }
                }
            }

            if (!Mario.MarioCharacter.Large) {
                this.SmallMario.Draw(context, this.camera);
            } else {
                this.LargeMario.Draw(context, this.camera);
            }

            this.Font.Strings[0] = { String: "MARIO " + Mario.MarioCharacter.Lives, X: 4, Y: 4 };
            this.FontShadow.Strings[0] = { String: "MARIO " + Mario.MarioCharacter.Lives, X: 5, Y: 5 };
            this.Font.Strings[1] = { String: "WORLD " + (this.WorldNumber + 1), X: 256, Y: 4 };
            this.FontShadow.Strings[1] = { String: "WORLD " + (this.WorldNumber + 1), X: 257, Y: 5 };

            this.FontShadow.Draw(context, this.camera);
            this.Font.Draw(context, this.camera);
        };

        Mario.MapState.prototype.LevelWon = function() {
            var x = this.XMario / 16, y = this.YMario / 16;
            if (this.Data[x][y] === -2) {
                this.NextWorld();
                return;
            }
            if (this.Data[x][y] !== -3) {
                this.Data[x][y] = 0;
            } else {
                this.Data[x][y] = -10;
            }
            this.RenderStatic();
        };

        Mario.MapState.prototype.GetX = function() {
            return 160;
        };

        Mario.MapState.prototype.GetY = function() {
            return 120;
        };

        Mario.MapState.prototype.CheckForChange = function(context) {
            if (this.WorldNumber === 8) {
                context.ChangeState(new Mario.WinState());
            }
            if (this.EnterLevel) {
                context.ChangeState(new Mario.LevelState(this.LevelDifficulty, this.LevelType));
            }
        };

        Mario.LevelState = function(difficulty, type) {
            this.LevelDifficulty = difficulty;
            this.LevelType = type;
            this.Level = null;
            this.Layer = null;
            this.BgLayer = [];

            this.Paused = false;
            this.Sprites = null;
            this.SpritesToAdd = null;
            this.SpritesToRemove = null;
            this.Camera = null;
            this.ShellsToCheck = null;
            this.FireballsToCheck = null;

            this.FontShadow = null;
            this.Font = null;

            this.TimeLeft = 0;
            this.StartTime = 0;
            this.FireballsOnScreen = 0;
            this.Tick = 0;

            this.Delta = 0;

            this.GotoMapState = false;
            this.GotoLoseState = false;
        };

        Mario.LevelState.prototype = new Enjine.GameState();

        Mario.LevelState.prototype.Enter = function() {
            var levelGenerator = new Mario.LevelGenerator(320, 15), i = 0, scrollSpeed = 0, w = 0, h = 0, bgLevelGenerator = null;
            this.Level = levelGenerator.CreateLevel(this.LevelType, this.LevelDifficulty);


            this.Paused = false;
            this.Layer = new Mario.LevelRenderer(this.Level, 320, 240);
            this.Sprites = new Enjine.DrawableManager();
            this.Camera = new Enjine.Camera();
            this.Tick = 0;

            this.ShellsToCheck = [];
            this.FireballsToCheck = [];
            this.SpritesToAdd = [];
            this.SpritesToRemove = [];

            this.FontShadow = Mario.SpriteCuts.CreateBlackFont();
            this.Font = Mario.SpriteCuts.CreateWhiteFont();

            for (i = 0; i < 2; i++) {
                scrollSpeed = 4 >> i;
                w = ((((this.Level.Width * 16) - 320) / scrollSpeed) | 0) + 320;
                h = ((((this.Level.Height * 16) - 240) / scrollSpeed) | 0) + 240;
                bgLevelGenerator = new Mario.BackgroundGenerator(w / 32 + 1, h / 32 + 1, i === 0, this.LevelType);
                this.BgLayer[i] = new Mario.BackgroundRenderer(bgLevelGenerator.CreateLevel(), 320, 240, scrollSpeed);
            }

            Mario.MarioCharacter.Initialize(this);

            this.Sprites.Add(Mario.MarioCharacter);
            this.StartTime = 1;
            this.TimeLeft = 200;

            this.GotoMapState = false;
            this.GotoLoseState = false;
        };

        Mario.LevelState.prototype.Exit = function() {

            delete this.Level;
            delete this.Layer;
            delete this.BgLayer;
            delete this.Sprites;
            delete this.Camera;
            delete this.ShellsToCheck;
            delete this.FireballsToCheck;
            delete this.FontShadow;
            delete this.Font;
        };

        Mario.LevelState.prototype.CheckShellCollide = function(shell) {
            this.ShellsToCheck.push(shell);
        };

        Mario.LevelState.prototype.CheckFireballCollide = function(fireball) {
            this.FireballsToCheck.push(fireball);
        };

        Mario.LevelState.prototype.Update = function(delta) {
            var i = 0, j = 0, xd = 0, yd = 0, sprite = null, hasShotCannon = false, xCannon = 0, x = 0, y = 0,
                dir = 0, st = null, b = 0;

            this.Delta = delta;

            this.TimeLeft -= delta;
            if ((this.TimeLeft | 0) === 0) {
                Mario.MarioCharacter.Die();
            }

            if (this.StartTime > 0) {
                this.StartTime++;
            }

            this.Camera.X = Mario.MarioCharacter.X - 160;
            if (this.Camera.X < 0) {
                this.Camera.X = 0;
            }
            if (this.Camera.X > this.Level.Width * 16 - 320) {
                this.Camera.X = this.Level.Width * 16 - 320;
            }

            this.FireballsOnScreen = 0;

            for (i = 0; i < this.Sprites.Objects.length; i++) {
                sprite = this.Sprites.Objects[i];
                if (sprite !== Mario.MarioCharacter) {
                    xd = sprite.X - this.Camera.X;
                    yd = sprite.Y - this.Camera.Y;
                    if (xd < -64 || xd > 320 + 64 || yd < -64 || yd > 240 + 64) {
                        this.Sprites.RemoveAt(i);
                    } else {
                        if (sprite instanceof Mario.Fireball) {
                            this.FireballsOnScreen++;
                        }
                    }
                }
            }

            if (this.Paused) {
                for (i = 0; i < this.Sprites.Objects.length; i++) {
                    if (this.Sprites.Objects[i] === Mario.MarioCharacter) {
                        this.Sprites.Objects[i].Update(delta);
                    } else {
                        this.Sprites.Objects[i].UpdateNoMove(delta);
                    }
                }
            } else {
                this.Layer.Update(delta);
                this.Level.Update();

                hasShotCannon = false;
                xCannon = 0;
                this.Tick++;

                for (x = ((this.Camera.X / 16) | 0) - 1; x <= (((this.Camera.X + this.Layer.Width) / 16) | 0) + 1; x++) {
                    for (y = ((this.Camera.Y / 16) | 0) - 1; y <= (((this.Camera.Y + this.Layer.Height) / 16) | 0) + 1; y++) {
                        dir = 0;

                        if (x * 16 + 8 > Mario.MarioCharacter.X + 16) {
                            dir = -1;
                        }
                        if (x * 16 + 8 < Mario.MarioCharacter.X - 16) {
                            dir = 1;
                        }

                        st = this.Level.GetSpriteTemplate(x, y);

                        if (st !== null) {
                            if (st.LastVisibleTick !== this.Tick - 1) {
                                if (st.Sprite === null || !this.Sprites.Contains(st.Sprite)) {
                                    st.Spawn(this, x, y, dir);
                                }
                            }

                            st.LastVisibleTick = this.Tick;
                        }

                        if (dir !== 0) {
                            b = this.Level.GetBlock(x, y);
                            if (((Mario.Tile.Behaviors[b & 0xff]) & Mario.Tile.Animated) > 0) {
                                if ((((b % 16) / 4) | 0) === 3 && ((b / 16) | 0) === 0) {
                                    if ((this.Tick - x * 2) % 100 === 0) {
                                        xCannon = x;
                                        for (i = 0; i < 8; i++) {
                                            this.AddSprite(new Mario.Sparkle(this, x * 16 + 8, y * 16 + ((Math.random() * 16) | 0), Math.random() * dir, 0, 0, 1, 5));
                                        }
                                        this.AddSprite(new Mario.BulletBill(this, x * 16 + 8 + dir * 8, y * 16 + 15, dir));
                                        hasShotCannon = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (hasShotCannon) {
                    Enjine.Resources.PlaySound("cannon");
                }

                for (i = 0; i < this.Sprites.Objects.length; i++) {
                    this.Sprites.Objects[i].Update(delta);
                }

                for (i = 0; i < this.Sprites.Objects.length; i++) {
                    this.Sprites.Objects[i].CollideCheck();
                }

                for (i = 0; i < this.ShellsToCheck.length; i++) {
                    for (j = 0; j < this.Sprites.Objects.length; j++) {
                        if (this.Sprites.Objects[j] !== this.ShellsToCheck[i] && !this.ShellsToCheck[i].Dead) {
                            if (this.Sprites.Objects[j].ShellCollideCheck(this.ShellsToCheck[i])) {
                                if (Mario.MarioCharacter.Carried === this.ShellsToCheck[i] && !this.ShellsToCheck[i].Dead) {
                                    Mario.MarioCharacter.Carried = null;
                                    this.ShellsToCheck[i].Die();
                                }
                            }
                        }
                    }
                }
                this.ShellsToCheck.length = 0;

                for (i = 0; i < this.FireballsToCheck.length; i++) {
                    for (j = 0; j < this.Sprites.Objects.length; j++) {
                        if (this.Sprites.Objects[j] !== this.FireballsToCheck[i] && !this.FireballsToCheck[i].Dead) {
                            if (this.Sprites.Objects[j].FireballCollideCheck(this.FireballsToCheck[i])) {
                                this.FireballsToCheck[i].Die();
                            }
                        }
                    }
                }

                this.FireballsToCheck.length = 0;
            }

            this.Sprites.AddRange(this.SpritesToAdd);
            this.Sprites.RemoveList(this.SpritesToRemove);
            this.SpritesToAdd.length = 0;
            this.SpritesToRemove.length = 0;

            this.Camera.X = (Mario.MarioCharacter.XOld + (Mario.MarioCharacter.X - Mario.MarioCharacter.XOld) * delta) - 160;
            this.Camera.Y = (Mario.MarioCharacter.YOld + (Mario.MarioCharacter.Y - Mario.MarioCharacter.YOld) * delta) - 120;
        };

        Mario.LevelState.prototype.Draw = function(context) {
            var i = 0, time = 0, t = 0;

            if (this.Camera.X < 0) {
                this.Camera.X = 0;
            }
            if (this.Camera.Y < 0) {
                this.Camera.Y = 0;
            }
            if (this.Camera.X > this.Level.Width * 16 - 320) {
                this.Camera.X = this.Level.Width * 16 - 320;
            }
            if (this.Camera.Y > this.Level.Height * 16 - 240) {
                this.Camera.Y = this.Level.Height * 16 - 240;
            }

            for (i = 0; i < 2; i++) {
                this.BgLayer[i].Draw(context, this.Camera);
            }

            context.save();
            context.translate(-this.Camera.X, -this.Camera.Y);
            for (i = 0; i < this.Sprites.Objects.length; i++) {
                if (this.Sprites.Objects[i].Layer === 0) {
                    this.Sprites.Objects[i].Draw(context, this.Camera);
                }
            }
            context.restore();

            this.Layer.Draw(context, this.Camera);
            this.Layer.DrawExit0(context, this.Camera, Mario.MarioCharacter.WinTime === 0);

            context.save();
            context.translate(-this.Camera.X, -this.Camera.Y);
            for (i = 0; i < this.Sprites.Objects.length; i++) {
                if (this.Sprites.Objects[i].Layer === 1) {
                    this.Sprites.Objects[i].Draw(context, this.Camera);
                }
            }
            context.restore();

            this.Layer.DrawExit1(context, this.Camera);

            this.DrawStringShadow(context, "MARIO " + Mario.MarioCharacter.Lives, 0, 0);
            this.DrawStringShadow(context, "00000000", 0, 1);
            this.DrawStringShadow(context, "COIN", 14, 0);
            this.DrawStringShadow(context, " " + Mario.MarioCharacter.Coins, 14, 1);
            this.DrawStringShadow(context, "WORLD", 24, 0);
            this.DrawStringShadow(context, " " + Mario.MarioCharacter.LevelString, 24, 1);
            this.DrawStringShadow(context, "TIME", 34, 0);
            time = this.TimeLeft | 0;
            if (time < 0) {
                time = 0;
            }
            this.DrawStringShadow(context, " " + time, 34, 1);

            if (this.StartTime > 0) {
                t = this.StartTime + this.Delta - 2;
                t = t * t * 0.6;
                this.RenderBlackout(context, 160, 120, t | 0);
            }

            if (Mario.MarioCharacter.WinTime > 0) {
                
                t = Mario.MarioCharacter.WinTime + this.Delta;
                t = t * t * 0.2;

                if (t > 900) {
                    //TODO: goto map state with level won
                    Mario.GlobalMapState.LevelWon();
                    this.GotoMapState = true;
                }

                this.RenderBlackout(context, ((Mario.MarioCharacter.XDeathPos - this.Camera.X) | 0), ((Mario.MarioCharacter.YDeathPos - this.Camera.Y) | 0), (320 - t) | 0);
            }

            if (Mario.MarioCharacter.DeathTime > 0) {
            
                t = Mario.MarioCharacter.DeathTime + this.Delta;
                t = t * t * 0.1;

                if (t > 900) {
                    //TODO: goto map with level lost
                    Mario.MarioCharacter.Lives--;
                    this.GotoMapState = true;
                    if (Mario.MarioCharacter.Lives <= 0) {
                        this.GotoLoseState = true;
                    }
                }

                this.RenderBlackout(context, ((Mario.MarioCharacter.XDeathPos - this.Camera.X) | 0), ((Mario.MarioCharacter.YDeathPos - this.Camera.Y) | 0), (320 - t) | 0);
            }
        };

        Mario.LevelState.prototype.DrawStringShadow = function(context, string, x, y) {
            this.Font.Strings[0] = { String: string, X: x * 8 + 4, Y: y * 8 + 4 };
            this.FontShadow.Strings[0] = { String: string, X: x * 8 + 5, Y: y * 8 + 5 };
            this.FontShadow.Draw(context, this.Camera);
            this.Font.Draw(context, this.Camera);
        };

        Mario.LevelState.prototype.RenderBlackout = function(context, x, y, radius) {
            if (radius > 320) {
                return;
            }

            var xp = [], yp = [], i = 0;
            for (i = 0; i < 16; i++) {
                xp[i] = x + (Math.cos(i * Math.PI / 15) * radius) | 0;
                yp[i] = y + (Math.sin(i * Math.PI / 15) * radius) | 0;
            }
            xp[16] = 0;
            yp[16] = y;
            xp[17] = 0;
            yp[17] = 240;
            xp[18] = 320;
            yp[18] = 240;
            xp[19] = 320;
            yp[19] = y;

            context.fillStyle = "#000";
            context.beginPath();
            context.moveTo(xp[19], yp[19]);
            for (i = 18; i >= 0; i--) {
                context.lineTo(xp[i], yp[i]);
            }
            context.closePath();
            context.fill();

            for (i = 0; i < 16; i++) {
                xp[i] = x - (Math.cos(i * Math.PI / 15) * radius) | 0;
                yp[i] = y - (Math.sin(i * Math.PI / 15) * radius) | 0;
            }
            //cure a strange problem where the circle gets cut
            yp[15] += 5;

            xp[16] = 320;
            yp[16] = y;
            xp[17] = 320;
            yp[17] = 0;
            xp[18] = 0;
            yp[18] = 0;
            xp[19] = 0;
            yp[19] = y;

            context.fillStyle = "#000";
            context.beginPath();
            context.moveTo(xp[0], yp[0]);
            for (i = 0; i <= xp.length - 1; i++) {
                context.lineTo(xp[i], yp[i]);
            }
            context.closePath();
            context.fill();
        };

        Mario.LevelState.prototype.AddSprite = function(sprite) {
            this.Sprites.Add(sprite);
        };

        Mario.LevelState.prototype.RemoveSprite = function(sprite) {
            this.Sprites.Remove(sprite);
        };

        Mario.LevelState.prototype.Bump = function(x, y, canBreakBricks) {
            var block = this.Level.GetBlock(x, y), xx = 0, yy = 0;

            if ((Mario.Tile.Behaviors[block & 0xff] & Mario.Tile.Bumpable) > 0) {
                this.BumpInto(x, y - 1);
                this.Level.SetBlock(x, y, 4);
                this.Level.SetBlockData(x, y, 4);

                if ((Mario.Tile.Behaviors[block & 0xff] & Mario.Tile.Special) > 0) {
                    Enjine.Resources.PlaySound("sprout");
                    if (!Mario.MarioCharacter.Large) {
                        this.AddSprite(new Mario.Mushroom(this, x * 16 + 8, y * 16 + 8));
                    } else {
                        this.AddSprite(new Mario.FireFlower(this, x * 16 + 8, y * 16 + 8));
                    }
                } else {
                    Mario.MarioCharacter.GetCoin();
                    Enjine.Resources.PlaySound("coin");
                    this.AddSprite(new Mario.CoinAnim(this, x, y));
                }
            }

            if ((Mario.Tile.Behaviors[block & 0xff] & Mario.Tile.Breakable) > 0) {
                this.BumpInto(x, y - 1);
                if (canBreakBricks) {
                    Enjine.Resources.PlaySound("breakblock");
                    this.Level.SetBlock(x, y, 0);
                    for (xx = 0; xx < 2; xx++) {
                        for (yy = 0; yy < 2; yy++) {
                            this.AddSprite(new Mario.Particle(this, x * 16 + xx * 8 + 4, y * 16 + yy * 8 + 4, (xx * 2 - 1) * 4, (yy * 2 - 1) * 4 - 8));
                        }
                    }
                }
            }
        };

        Mario.LevelState.prototype.BumpInto = function(x, y) {
            var block = this.Level.GetBlock(x, y), i = 0;
            if (((Mario.Tile.Behaviors[block & 0xff]) & Mario.Tile.PickUpable) > 0) {
                Mario.MarioCharacter.GetCoin();
                Enjine.Resources.PlaySound("coin");
                this.Level.SetBlock(x, y, 0);
                this.AddSprite(new Mario.CoinAnim(x, y + 1));
            }

            for (i = 0; i < this.Sprites.Objects.length; i++) {
                this.Sprites.Objects[i].BumpCheck(x, y);
            }
        };

        Mario.LevelState.prototype.CheckForChange = function(context) {
            if (this.GotoLoseState) {
                context.ChangeState(new Mario.LoseState());
            }
            else {
                if (this.GotoMapState) {
                    context.ChangeState(Mario.GlobalMapState);
                }
            }
        };
    
    // Define a namespace to contain the code for our game within a single global variable
document.querySelector('#frogger').addEventListener('click', () => {  
    document.querySelector('#startScreen').style.display = 'none'
    
    var Frogger = (function() {

        // Locate the main <canvas> element on the page
        var canvas = document.getElementById("canvas-frogger"),
            // Get a reference to the <canvas> element's 2-D drawing surface context
            drawingSurface = canvas.getContext("2d"),

            // Locate the background <canvas> element on the page
            backgroundCanvas = document.getElementById("background-canvas"),

            // Get a reference to the background <canvas> element's 2-D drawing surface context
            backgroundDrawingSurface = backgroundCanvas.getContext("2d"),

            
            // Get a reference to the <canvas> element's width and height, in pixels
            drawingSurfaceWidth = 960,
            drawingSurfaceHeight = 1280;

        return {

            // Expose the <canvas> element, its 2-D drawing surface context, its width and
            // its height for use in other code modules
            canvas: canvas,
            drawingSurface: drawingSurface,
            drawingSurfaceWidth: drawingSurfaceWidth,
            drawingSurfaceHeight: drawingSurfaceHeight,

            // Expose the background <canvas> element's 2-D drawing surface context
            backgroundDrawingSurface: backgroundDrawingSurface,

            // Define an object containing references to directions the characters in our game can
            // move in. We define it here globally for use across our whole code base
            direction: {
                UP: "up",
                DOWN: "down",
                LEFT: "left",
                RIGHT: "right"
            },

            // Define the observer design pattern methods subscribe() and publish() to allow
            // application-wide communication without the need for tightly-coupled modules. See
            // Chapter 5 for more information on this design pattern.
            observer: (function() {
                var events = {};

                return {
                    subscribe: function(eventName, callback) {

                        if (!events.hasOwnProperty(eventName)) {
                            events[eventName] = [];
                        }

                        events[eventName].push(callback);
                    },

                    publish: function(eventName) {
                        var data = Array.prototype.slice.call(arguments, 1),
                            index = 0,
                            length = 0;

                        if (events.hasOwnProperty(eventName)) {
                            length = events[eventName].length;

                            for (; index < length; index++) {
                                events[eventName][index].apply(this, data);
                            }
                        }
                    }
                };
            }()),

            // Define a method to determine whether two obstacles on the game board intersect
            // each other on the horizontal axis. By passing in two objects, each with a 'left'
            // and 'right' property indicating the left-most and right-most position of each
            // obstacle in pixels on the game board, we establish whether the two intersect
            // each other - if they do, and they are both on the same row as each other on the
            // game board, this can be considered a collision between these two obstacles
            intersects: function(position1, position2) {
                var doesIntersect = false;

                if ((position1.left > position2.left && position1.left < position2.right) ||
                    (position1.right > position2.left && position1.left < position2.right)) {
                    doesIntersect = true;
                }

                return doesIntersect;
            }
        };
    }());

    // Create a simple cross-browser polyfill for modern browsers' requestAnimationFrame()
    // method to enable smooth, power-efficient animations. Credit to Paul Irish via
    // http://bit.ly/req_anim_frame
    window.requestAnimationFrame = (function(){
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback){
            window.setTimeout(callback, 1000 / 60);
        };
    })();

    // Define the game logic module which keeps track of the game state, the players's score,
    // the number of lives remaining, handles collisions between the player's character and
    // other obstacles and ensures the game graphics are drawn onto the <canvas> at the
    // right moment. This module contains the brains behind the game play and instructs other
    // code modules to do the heavy lifting through the use of the observer design pattern.
    (function(Frogger) {

        // Define a variable to hold the current player's score
        var _score = 0,

            // Define and initialize a variable to hold the high score achieved in the game
            _highScore = 1000,

            // Define the number of lives the player has remaining before the game is over
            _lives = 5,

            // Define the number of milliseconds the player has to get their character to
            // the goal (60 seconds). If they take too long, they will lose a life
            _timeTotal = 60000,

            // Define a variable to store the current time remaining for the player to reach
            // the goal
            _timeRemaining = _timeTotal,

            // Define the refresh rate of the graphics on the <canvas> element (one draw every
            // 33 milliseconds = 30 frames per second). Attempting to redraw too frequently
            // can cause the browser to slow down so choose this value carefully to maintain a
            // good balance between fluid animation and smooth playability
            _refreshRate = 33.333,

            // Define a variable to store the number of times the player's character has
            // reached the goal
            _timesAtGoal = 0,

            // Define a variable to indicate the number of times the player's character needs
            // to reach the goal for the game to be won
            _maxTimesAtGoal = 5,

            // Define a Boolean variable to indicate whether the player's movement is currently
            // frozen in place
            _isPlayerFrozen = false,

            // Define a variable to store the last time the game loop ran - this helps keep
            // the animation running smoothly at the defined refresh rate
            _lastTimeGameLoopRan = (new Date()).getTime();

        // Define a function to be called to count down the time remaining for the player to
        // reach the goal without forfeiting a life
        function countDown() {
            if (_timeRemaining > 0) {

                // This function will be called as frequently as the _refreshRate variable
                // dictates so we reduce the number of milliseconds remaining by the
                // _refreshRate value for accurate timing
                _timeRemaining -= _refreshRate;

                // Publish the fact that the remaining time has changed, passing along the
                // new time remaining as a percentage - which will help when we come to display
                // the remaining time on the game board itself
                Frogger.observer.publish("time-remaining-change", _timeRemaining / _timeTotal);
            } else {

                // If the remaining time reaches zero, we take one of the player's remaining
                // lives
                loseLife();
            }
        }

        // Define a function to be called when all the player's lives have gone and the game
        // is declared over
        function gameOver() {

            // Pause the player's movements as they are no longer in the game
            freezePlayer();

            // Inform other code modules in this application that the game is over
            Frogger.observer.publish("game-over");
        }

        // Define a function to be called when the player has reached the goal
        function gameWon() {

            // Inform other code modules that the game has been won
            Frogger.observer.publish("game-won");
        }

        // Define a function to be called when the player loses a life
        function loseLife() {

            // Decrease the number of lives the player has remaining
            _lives--;

            // Pause the player's movements
            freezePlayer();

            // Inform other code modules that the player has lost a life
            Frogger.observer.publish("player-lost-life");

            if (_lives === 0) {

                // Declare the game to be over if the player has no lives remaining
                gameOver();
            } else {

                // If there are lives remaining, wait 2000 milliseconds (2 seconds) before
                // resetting the player's character and other obstacles to their initial
                // positions on the game board
                setTimeout(reset, 2000);
            }
        }

        // Define a function to be called when the player's character is required to be frozen
        // in place, such as when the game is over or when the player has lost a life
        function freezePlayer() {

            // Set the local variable to indicate the frozen state
            _isPlayerFrozen = true;

            // Inform other code modules - including that which controls the player's
            // character - that the player is now be frozen
            Frogger.observer.publish("player-freeze");
        }

        // Define a function to be called when the player's character is free to move after
        // being previously frozen in place
        function unfreezePlayer() {

            // Set the local variable to indicate the new state
            _isPlayerFrozen = false;

            // Inform other code modules that the player's character is now free to move around
            // the game board
            Frogger.observer.publish("player-unfreeze");
        }

        // Define a function to increase the player's score by a specific amount and update
        // the high score accordingly
        function increaseScore(increaseBy) {

            // Increase the score by the supplied amount (or by 0 if no value is provided)
            _score += increaseBy || 0;

            // Inform other code modules that the player's score has changed, passing along
            // the new score
            Frogger.observer.publish("score-change", _score);

            // If the player's new score beats the current high score then update the high
            // score to reflect the player's new score and inform other code modules of a
            // change to the high score, passing along the new high score value
            if (_score > _highScore) {
                _highScore = _score;
                Frogger.observer.publish("high-score-change", _highScore);
            }
        }

        // Define a function to execute once the player reaches the designated goal
        function playerAtGoal() {

            // When the player reaches the goal, increase their score by 1000 points
            increaseScore(1000);

            // Increment the value indicating the total number of times the player's character
            // has reached the goal
            _timesAtGoal++;

            // Freeze the player's character movement temporarily to acknowledge they have
            // reached the goal
            freezePlayer();

            if (_timesAtGoal < _maxTimesAtGoal) {

                // The player must enter the goal a total of 5 times, as indicated by the
                // _maxTimesAtGoal value. If the player has not reached the goal this many
                // times yet, then reset the player's character position and obstacles on the
                // game board after a delay of 2000 milliseconds (2 seconds)
                setTimeout(reset, 2000);
            } else {

                // If the player has reached the goal 5 times, the game has been won!
                gameWon();
            }
        }

        // Define a function to execute when the player moves their character on the game
        // board, increasing their score by 20 points when they do
        function playerMoved() {
            increaseScore(20);
        }

        // Define a function to be called when the game board needs to be reset, such as when
        // the player loses a life
        function reset() {

            // Reset the variable storing the current time remaining to its initial value
            _timeRemaining = _timeTotal;

            // Release the player's character if it has been frozen in place
            unfreezePlayer();

            // Inform other code modules to reset themselves to their initial conditions
            Frogger.observer.publish("reset");
        }

        // The game loop executes on an interval at a rate dictated by value of the
        // _refreshRate variable (once every 50 milliseconds), in which the game board is
        // redrawn with the character and obstacles drawn at their relevant positions on
        // the board and any collisions between the player's character and any obstacles
        // are detected
        function gameLoop() {

            // Calculate how many milliseconds have passed since the last time the game loop
            // was called
            var currentTime = (new Date()).getTime(),
                timeDifference = currentTime - _lastTimeGameLoopRan;

            // Execute this function again when the next animation frame is ready for use by
            // the browser - keeps the game loop looping
            window.requestAnimationFrame(gameLoop);

            // If the number of milliseconds passed exceeds the defined refresh rate, draw
            // the obstacles in the updated position on the game board and check for collisions
            if (timeDifference >= _refreshRate) {

                // Clear the <canvas> element's drawing surface - erases everything on the
                // game board so we can redraw the player's character and obstacles in their
                // new positions
                Frogger.drawingSurface.clearRect(0, 0, Frogger.drawingSurfaceWidth, Frogger.drawingSurfaceHeight);

                if (!_isPlayerFrozen) {

                    // As long as the player's character is not frozen in place, ensure the
                    // timer is counting down, putting pressure on the player to reach the
                    // goal in time
                    countDown();

                    // Inform other code modules to check the player has not collided with an
                    // obstacle on the game board
                    Frogger.observer.publish("check-collisions");
                }

                // Now on our empty canvas we draw our game board and the obstacles upon it in
                // their respective positions
                Frogger.observer.publish("render-base-layer");

                // After the game board and obstacles, we draw the player's character so that
                // it is always on top of anything else on the <canvas> drawing surface
                Frogger.observer.publish("render-character");

                // Store the current time for later comparisons to keep the frame rate smooth
                _lastTimeGameLoopRan = currentTime;
            }
        }

        // Define a function to kick-start the application and run the game loop, which renders
        // each frame of the game graphics and checks for collisions between the player's
        // character and any obstacles on the game board
        function start() {

            // Inform other code modules of the initial state of the game's high score
            Frogger.observer.publish("high-score-change", _highScore);

            // Start the game loop running
            gameLoop();
        }

        // Execute the start() function to kick off the game loop once the "game-load" event
        // is fired. We'll trigger this event after we've configured the rest of our code
        // modules for the game
        Frogger.observer.subscribe("game-load", start);

        // Execute the playerAtGoal() function when another code module informs us that the
        // player has reached the goal
        Frogger.observer.subscribe("player-at-goal", playerAtGoal);

        // Execute the playerMoved() function when we have been informed that the player has
        // moved their character
        Frogger.observer.subscribe("player-moved", playerMoved);

        // Execute the loseLife() function when we are informed by another code base that the
        // player's character has collided with an obstacle on the game board
        Frogger.observer.subscribe("collision", loseLife);

    // Pass the global Frogger variable into the module so it can be accessed locally,
    // improving performance and making its dependency clear
    }(Frogger));

    // Define a "class" for creating images to place on the game board. All the individual
    // images are stored together in a single large image file called a Sprite Map. By knowing
    // the position within this sprite file of the image to display, together with its width
    // and height, we can pull out the individual images for display. By only loading in a
    // single image file we improve the loading performance of the game
    Frogger.ImageSprite = function(startPositionLeft, startPositionTop) {

        // Each instance stores its starting position on the game board so it can later be
        // reset to its initial position if necessary
        this.startLeft = startPositionLeft || 0;
        this.startTop = startPositionTop || 0;

        // Initialize an object property to later store any animations for this image
        this.animations = {};

        // Set this image to its initial state for display
        this.reset();
    };

    // Define a "class" for assigning animations to an ImageSprite instance to allow any image
    // on the game board to appear to animate. An animation is a sequence of images which will
    // be displayed in order over a fixed time period to give the impression of movement
    Frogger.Animation = function(options) {
        options = options || {};

        // Store the rate to move between the images in the animation sequence, in milliseconds
        // - defaults to a rate of 150 milliseconds
        this.rate = options.rate || 150;

        // Store a Boolean value to indicate whether this animation is to loop or play once
        this.loop = options.loop || false;

        // Store the supplied position in pixels from the left-hand side of the spite map image
        // where the first image in this animation sequence is located
        this.spriteLeft = options.spriteLeft || 0;

        // Store the animation sequence which indicates a multiple of the image with as an
        // offset from the spriteLeft value. A sequence value of [0, 1, 2] would indicate there
        // are three images in this animation sequence located at the position stored in the
        // spriteLeft property, that position + the width of the sprite image, and that
        // position + double the width of the sprite image, respectively. It is therefore
        // expected that an animation sequence of images are stored horizontally beside each
        // other in order within the sprite map image file
        this.sequence = options.sequence || [];
    };

    // Define and initialize properties and methods to be inherited by each instance of the
    // Frogger.Animation "class"
    Frogger.Animation.prototype = {

        // Define a value to indicate the current frame shown from the animation sequence.
        // As the sequence property is an Array, this is effectively an index within that Array
        frame: 0,

        // Define a property to indicate whether the animation is currently playing - that is
        // that the frame index of the animation sequence is being actively incremented at the
        // rate supplied at initiation time
        playing: false,

        // Define a property to store a timer indicator to start and stop the incrementing of
        // the frame index on demand
        timer: null,

        // Define a function to start playing the animation - essentially incrementing the
        // frame index on a timer at the rate supplied upon instantiation
        play: function() {
            var that = this;

            // If the animation is not currently playing, then reset it to its initial state
            if (!this.playing) {
                this.reset();
                this.playing = true;
            }

            // Increment the current frame index of the animation on a timer at a rate given
            // by the supplied value upon instantiation, storing a reference to the timer in
            // the timer property so that it can be stopped at a later time
            this.timer = setInterval(function() {
                that.incrementFrame();
            }, this.rate);
        },

        // Define a function to rewind the current frame index of the animation sequence back
        // to the start
        reset: function() {
            this.frame = 0;
        },

        // Define a function to increment the current frame index of the animation sequence
        incrementFrame: function() {

            // Only increment the current frame if the animation should be playing
            if (this.playing) {

                // Increment the current frame index of the animation sequence
                this.frame++;

                // If we have reached the end of the animation sequence, stop the animation if
                // it was not intended to loop, otherwise reset the current frame index of the
                // animation back to the start
                if (this.frame === this.sequence.length - 1) {
                    if (!this.loop) {
                        this.stop();
                    } else {
                        this.reset();
                    }
                }
            }
        },

        // Define a function to return the value stored in the animation sequence at the
        // current frame index. This value will be used later on to correctly identify which
        // individual image from the large sprite map to display within the <canvas> element
        getSequenceValue: function() {
            return this.sequence[this.frame];
        },

        // Define a function to return the number of pixels from the left-hand edge of the
        // sprite map of the first frame of this animation. This is used in conjunction with
        // the current value of the animation sequence and the image width to decide which
        // image to display within the <canvas> element
        getSpriteLeft: function() {
            return this.spriteLeft;
        },

        // Define a function to stop the timer from incrementing the current frame index, and
        // hence stop the animation from playing
        stop: function() {

            // Terminate the timer
            clearInterval(this.timer);

            // Indicate that the animation is no longer playing
            this.playing = false;
        }
    };

    // Define and initialize properties and methods to be inherited by each instance of the
    // Frogger.ImageSprite "class" to enable individual images from a larger sprite map to be
    // drawn onto the <canvas> element
    Frogger.ImageSprite.prototype = {

        // Define properties to store the current position in pixels of the image on the
        // game board from the top and left-hand edges
        top: 0,
        left: 0,

        // Define properties to store the initial position in pixels of the images on the game
        // board from the top and left-hand edges so that the image can be returned to its
        // initial position at a later stage if needed
        startLeft: 0,
        startTop: 0,

        // Define a property containing a reference to a new <img> tag holding the single
        // large sprite map image. Because this is an object, it will be shared across all
        // instances of the Frogger.ImageSprite "class", saving on memory usage
        sprite: (function() {
            var img = document.createElement("img");
            img.src = "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/FroggerImages/spritemap.png";
            return img;
        }()),

        // Define properties to define the default width and height, in pixels, of an
        // individual image within the large sprite map image file
        width: 80,
        height: 80,

        // Define properties denoting the location of the top and left positions, in pixels,
        // of the individual image within the large sprite map image. Together with the width
        // and height properties, we are able to pull out an individual image from the sprite
        // map to display within the <canvas> element
        spriteTop: 0,
        spriteLeft: 0,

        // Declare no animations by default
        animations: null,

        // Define a property indicating the name of the currently playing animation, if any
        currentAnimation: "",

        // Define a property to indicate whether the individual image represented by this
        // object instance is currently hidden from display
        isHidden: false,

        // Define a function to reset this image back to its initial position and to reset any
        // associated animation of that image
        reset: function() {

            // Reset the top and left position of the image on the game board back to its
            // initial position defined upon instantiation
            this.left = this.startLeft;
            this.top = this.startTop;

            // Reset any associated animations to their initial state
            this.resetAnimation();

            // Declare this image no longer to be hidden
            this.isHidden = false;
        },

        // Define a function to associate one or more animation with this image - data is
        // passed in as an object literal with each key representing the name of the animation
        registerAnimation: function(animations) {
            var key,
                animation;

            // Loop through the supplied object literal data indicating the animations to
            // register
            for (key in animations) {
                animation = animations[key];

                // Create instances of the Frogger.Animation "class" for each item in the
                // supplied data object. Each item's data is passed to the "class" upon
                // instantiation to define its animation sequence, animation rate, and other
                // initial properties
                this.animations[key] = new Frogger.Animation(animation);
            }
        },

        // Define a function to reset any currently playing animation back to its initial state
        resetAnimation: function() {
            if (this.animations[this.currentAnimation]) {

                // If an animation is currently playing, then call its reset() method to
                // restore it to its initial state
                this.animations[this.currentAnimation].reset();
            }

            // Once reset, there should be no currently playing animation
            this.currentAnimation = "";
        },

        // Define a function to play a specific animation sequence by name. The name must
        // correspond with one provided to the registerAnimation() method previously
        playAnimation: function(name) {

            // Set the current animation to the provided name
            this.currentAnimation = name;

            if (this.animations[this.currentAnimation]) {

                // If an animation is found by the supplied name, then call its play() method
                // to begin incrementing its current frame index using its internal timer
                this.animations[this.currentAnimation].play();
            }
        },

        // Define a function to draw the individual image onto the <canvas> element at the
        // supplied left and top positions, in pixels. If an animation is currently playing,
        // ensure the correct image is displayed based on that animation's current sequence
        // value
        renderAt: function(left, top) {

            // Locate the animation that is currently playing, if any
            var animation = this.animations[this.currentAnimation],

                // If an animation is playing, get its current sequence value based on its
                // internal frame index. If no animation is playing, assume a sequence value
                // of 0. This value will be multiplied by the width of the individual image
                // within the sprite map to identify the exact image to show based on the
                // animation's current frame index
                sequenceValue = animation ? animation.getSequenceValue() : 0,

                // If an animation is playing, get the location of the animation's initial
                // frame as an offset in pixels from the left-hand edge of the sprite map image.
                // We make an assumption that the top offset of the animation images is the
                // same as the main image itself represented in this object instance - meaning
                // that all frames of the animation should be positioned together with the main
                // non-animating image on the same row of the sprite map image
                animationSpriteLeft = animation ? animation.getSpriteLeft() : 0,

                // Calculate the offset in pixels from the left-hand edge of the sprite map
                // image where the individual image to display is to be found, based on whether
                // an animation is currently playing or not. If no animation is playing, the
                // offset will be the same as that stored in the spriteLeft property of this
                // object instance
                spriteLeft = this.spriteLeft + animationSpriteLeft + (this.width * sequenceValue);

            // If the image is not currently to be considered hidden, then extract the individual
            // image from the sprite map and draw it onto the <canvas> drawing surface at the
            // top and left positions, in pixels, as provided to this method, when called
            if (!this.isHidden) {
                Frogger.drawingSurface.drawImage(this.sprite, spriteLeft, this.spriteTop, this.width, this.height, left, top, this.width, this.height);
            }
        },

        // Define a function to set the stored left and top offset positions, in pixels,
        // indicating where on the game board the image should be displayed. These values are
        // then used in the renderAt() method to draw the image at this position
        moveTo: function(left, top) {
            this.left = left || 0;

            // Since most images are moved left and right in this game, rather than up and down,
            // we let the top offset value be optional
            if (typeof top !== "undefined") {
                this.top = top || 0;
            }
        },

        // Define a function return the width of the individual image we are extracting from
        // the large sprite map image
        getWidth: function() {
            return this.width;
        },

        // Define a function to return the left and right positions, in pixels, of the image
        // which we can use later to perform collision detection with other obstacles on the
        // game board
        getPosition: function() {
            return {
                left: this.left,

                // The right position is derived as the left position plus the width of the
                // individual image
                right: this.left + this.width
            };
        },

        // Define a function to hide this image from the game board by effectively stopping
        // the drawing of the image to the <canvas> within the renderAt() method
        hide: function() {
            this.isHidden = true;
        }
    };

    // Define a code module to define the parameters of the game board itself, the number of
    // rows and columns within the grid, along with their relative positions in pixels, and
    // the bounds within which the player's character may move
    (function(Frogger) {

        // Define the width and height of each square on the game board grid, in pixels. The
        // game board is divided into rows with different obstacles on each, and columns within
        // which the player's character can move
        var _grid = {
                width: 80,
                height: 80
            },

            // Define the number of rows on the game board. The top two rows contain the score,
            // the next two contain the home base the player is attempting to reach. There then
            // follow five rows of water-based obstacles before reaching a 'safe' row where the
            // player's character may take refuge without obstacles. There then follow five rows
            // of road-based obstacles before another 'safe' row, which is where the player's
            // character starts its game from. The final row holds the remaining time and number
            // of lives remaining. There are 17 rows, therefore, though since we start counting
            // rows at position 0, the total number of rows is said to be 16 using the grid
            // square defined previously
            _numRows = 16,

            // Define the number of columns on the game board, from left to right, based on the
            // game board grid defined previously. The total number of columns is 12 but since
            // we count position 0 as a column, we represent the number as 11 instead
            _numColumns = 11,

            // Define the limits of movement of the player's character on the game board in
            // pixels, returning the left-, right-, top- and bottom-most positions the
            // character can be placed. This is to ensure the player is not able to move
            // their character onto the parts of the game board that show the score, the time
            // remaining, etc.
            _characterBounds = {
                left: 0,
                right: _numColumns * _grid.width,
                top: 2 * _grid.height,
                bottom: (_numRows - 2) * _grid.height
            },

            // Define an array containing the pixel positions of each of the 17 rows as
            // measured from the left-most edge of the game board - each is essentially a
            // multiple of the grid width. This allows easy access to pixel positions by
            // row number.
            _rows = (function() {
                var output = [],
                    index = 0,
                    length = _numRows;

                for (; index < length; index++) {
                    output.push(index * _grid.width);
                }

                return output;
            }()),

            // Define an array containing the pixel positions of each of the 12 columns as
            // measured from the top-most edge of the game board - each is essentially a
            // multiple of the grid height. This allows easy access to pixel positions by
            // column number.
            _columns = (function() {
                var output = [],
                    index = 0,
                    length = _numColumns;

                for (; index < length; index++) {
                    output.push(index * _grid.height);
                }

                return output;
            }());

        // Listen for the "game-load" event, which will be fired once all our code modules
        // are configured
        Frogger.observer.subscribe("game-load", function() {

            // Publish the "game-board-initialize" event, passing along relevant information
            // about the game board for other code modules to use to ensure they draw their
            // images to the correct place on the board, and allow the character to only
            // move between certain limits as defined in this code module
            Frogger.observer.publish("game-board-initialize", {

                // Pass across the number of rows and columns the board consists of
                numRows: _numRows,
                numColumns: _numColumns,

                // Pass across arrays representing the pixel positions of each of the rows
                // and columns on the board to simplify the drawing of images onto the <canvas>
                // element in the correct place
                rows: _rows,
                columns: _columns,

                // Pass across the width and height of each grid square on the game board
                grid: {
                    width: _grid.width,
                    height: _grid.height
                },

                // Pass across the object containing the left, right, top and bottom positions
                // in pixels which the player's character is allowed to move within on the
                // game board
                characterBounds: _characterBounds
            });
        });
    }(Frogger));

    // Define a code module to add text-based visuals to the game board, e.g. the score, high
    // score, and any informative text for the player about the game state, such as "Game Over"
    // or "You Win!"
    (function(Frogger) {

        // Define the text size and font name to use for the text. You can find the Arcade
        // Classic font for download for free online at http://bit.ly/arcade_font
        var _font = "67px Arcade Classic",

            // Define variables to store the current game state locally in this module
            _score = 0,
            _highScore = 0,
            _gameWon = false,
            _gameOver = false,

            // Define a variable to store the initialized data from the game board module
            // defined previously - this will be populated later with data from that module
            _gameBoard = {};

        // Define a function to render the player's score and high score to the <canvas> element
        function renderScore() {

            // Select the font face and size
            Frogger.drawingSurface.font = _font;

            // Right-align text at the position we define to draw the text at
            Frogger.drawingSurface.textAlign = "end";

            // Write the text "1-UP", right-aligned to the 4th column position and ending half
            // a row down from the top of the game board in white (hex color value #FFF)
            Frogger.drawingSurface.fillStyle = "#FFF";
            Frogger.drawingSurface.fillText("1-UP", _gameBoard.columns[3], _gameBoard.grid.height / 2);

            // Write out the current score in red (hex color value #F00) right-aligned beneath
            // the "1-UP" text previously drawn to the <canvas>
            Frogger.drawingSurface.fillStyle = "#F00";
            Frogger.drawingSurface.fillText(_score, _gameBoard.columns[3], _gameBoard.grid.height);

            // Write the text "HI-SCORE", right-aligned to the 8th column position and ending
            // half a row down from the top of the game board in white (hex color value #FFF)
            Frogger.drawingSurface.fillStyle = "#FFF";
            Frogger.drawingSurface.fillText("HI-SCORE", _gameBoard.columns[8], _gameBoard.grid.height / 2);

            // Write out the current high score in red (hex color value #F00) right-aligned
            // beneath the "HI-SCORE" text previously drawn to the <canvas>
            Frogger.drawingSurface.fillStyle = "#F00";
            Frogger.drawingSurface.fillText(_highScore, _gameBoard.columns[8], _gameBoard.grid.height);
        }

        // Define a function to render the text "GAME OVER" to the <canvas>. This will only be
        // called when the game is over
        function renderGameOver() {

            // Use the Arcade Classic font as previously defined, and write the text centered
            // around the given drawing position in white
            Frogger.drawingSurface.font = _font;
            Frogger.drawingSurface.textAlign = "center";
            Frogger.drawingSurface.fillStyle = "#FFF";

            // Write the text center aligned within the <canvas> and at the 9th row position
            // from the top of the game board
            Frogger.drawingSurface.fillText("GAME OVER", Frogger.drawingSurfaceWidth / 2, _gameBoard.rows[9]);
        }

        // Define a function to render the text "YOU WIN!" to the <canvas> which will be called
        // when the player has won the game by reaching the home base position five times
        function renderGameWon() {

            // Use the Arcade Classic font as previously defined, and write the text centered
            // around the given drawing position in yellow (hex value #FF0)
            Frogger.drawingSurface.font = _font;
            Frogger.drawingSurface.textAlign = "center";
            Frogger.drawingSurface.fillStyle = "#FF0";

            // Write the text center aligned within the <canvas> and at the 9th row position
            // from the top of the game board
            Frogger.drawingSurface.fillText("YOU WIN!", Frogger.drawingSurfaceWidth / 2, _gameBoard.rows[9]);
        }

        // Define a function to render the "TIME" label in the bottom-right corner of the
        // game board
        function renderTimeLabel() {

            // Use the Arcade Classic font as previously defined, and write the text centered
            // around the given drawing position in yellow (hex value #FF0)
            Frogger.drawingSurface.font = _font;
            Frogger.drawingSurface.textAlign = "end";
            Frogger.drawingSurface.fillStyle = "#FF0";

            // Write the text right aligned within the <canvas> and in the bottom right corner
            // of the game board
            Frogger.drawingSurface.fillText("TIME", Frogger.drawingSurfaceWidth, Frogger.drawingSurfaceHeight);
        }

        // Define a function to render the text-based visuals to the game board as appropriate
        // depending on the current game state - we'll connect this up later to be called
        // once on every cycle of the game loop
        function render() {
            renderScore();
            renderTimeLabel();

            // Only render the "GAME OVER" text if the game is actually over
            if (_gameOver) {
                renderGameOver();
            }

            // Only render the "YOU WIN!" text if the players has won the game
            if (_gameWon) {
                renderGameWon();
            }
        }

        // When the game logic publishes a message declaring that the player has won the game,
        // set the local variable to indicate this also so that the "YOU WIN!" text will be
        // drawn onto the <canvas> during any following execution of the game loop
        Frogger.observer.subscribe("game-won", function() {
            _gameWon = true;
        });

        // When the game logic module publishes a message indicating that the game has been
        // lost, set the local variable to reflect this fact so that the "GAME OVER" text gets
        // written to the <canvas> element on the next cycle around the game loop
        Frogger.observer.subscribe("game-over", function() {
            _gameOver = true;
        });

        // Reset the local variables indicating the game state if the game logic has forced
        // a game state reset to occur
        Frogger.observer.subscribe("reset", function() {
            _gameOver = false;
            _gameWon = false;
        });

        // Update the local score variable when the player's score changes throughout the
        // course of the game. The updated score will then be written onto the <canvas> on
        // the next cycle of the game loop
        Frogger.observer.subscribe("score-change", function(newScore) {
            _score = newScore;
        });

        // Update the local high score variable when the game's high score changes throughout
        // the course of the game. The updated high score will then be drawn to the <canvas>
        // on the next cycle of the game loop
        Frogger.observer.subscribe("high-score-change", function(newHighScore) {
            _highScore = newHighScore;
        });

        // Subscribe to the "game-board-initialize" event fired by the previous code module,
        // storing the game board properties and settings in a local variable
        Frogger.observer.subscribe("game-board-initialize", function(gameBoard) {
            _gameBoard = gameBoard;

            // Start listening to the "render-base-layer" event, fired from within the game
            // loop, and execute the render() function when it occurs, drawing the text onto
            // the game board in the appropriate position for each cycle of the game loop
            Frogger.observer.subscribe("render-base-layer", render);
        });
    }(Frogger));

    // Define a code module to draw the game board background image to the background <canvas>
    // element. We will draw the image once only since it is static and will not change - all
    // graphical elements that could change are drawn to the main <canvas> element instead.
    (function(Frogger) {

        // To draw an image file onto the <canvas> we need to create a new <img> element to
        // contain the image first
        var _background = document.createElement("img");

        // Once the image has loaded, draw the image onto the background <canvas> element's
        // drawing surface, starting at the top-left corner and covering the full width and
        // height of the drawing surface
        _background.addEventListener("load", function() {
            Frogger.backgroundDrawingSurface.drawImage(_background, 0, 0, Frogger.drawingSurfaceWidth, Frogger.drawingSurfaceHeight);
        }, false);

        // Setting the "src" attribute of the <img> causes the file to load immediately, which
        // is why it was essential to configure our "load" event handler first. We load the
        // file named "gameboard.gif" which contains the background of the game board. This
        // will only be drawn once since we are not within the game loop at this point. By
        // splitting the background out into a separate element, we avoid needing to redraw
        // the background each time the game loop executes since it is static.
        _background.src = "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/FroggerImages/gameboard.gif";
    }(Frogger));

    // Define a code module to show the number of lives the player has remaining, and how much
    // time remains before automatically losing a life, within the <canvas> element
    (function(Frogger) {

        // Define an array, to be populated later, which will represent the number of lives the
        // player has remaining
        var _lives = [],

            // Define a variable indicating the time remaining on the countdown before the
            // player automatically loses a life, represented as a percentage, starting at
            // 100% and counting down to 0
            _timeRemainingAsPercentage = 100,

            // Define a variable for storing the game board properties and settings
            _gameBoard;

        // Define a subclass of Frogger.ImageSprite to represent the individual image found
        // at position 720px from the left and 80px from the top of the sprite map image which
        // is 40px wide by 40px tall and depicts a small frog to be used to denote a remaining
        // life
        function Life(left, top) {

            // The left and top parameters indicate the starting position of this instance of
            // the Life "class". We pass those parameters directly onto the parent
            // Frogger.ImageSprite() constructor function
            Frogger.ImageSprite.call(this, left, top);
        }

        // Inherit properties and methods from the Frogger.ImageSprite "class"
        Life.prototype = new Frogger.ImageSprite();
        Life.prototype.constructor = Life;

        // Set the dimensions and location of the remaining life image from within the larger
        // sprite map image file
        Life.prototype.spriteLeft = 720;
        Life.prototype.spriteTop = 80;
        Life.prototype.width = 40;
        Life.prototype.height = 40;

        // Define a function to be executed when the game board has initialized, passing along
        // the properties and settings from the game board code module
        function initialize(gameBoard) {

            // Define a variable representing the position from the top of the game board
            // to display the remaining lives
            var lifePositionTop;

            // Store the game board properties and settings in a local variable within this
            // code module
            _gameBoard = gameBoard;

            // Set the lifePositionTop variable to the appropriate position in the bottom-left
            // corner of the game board
            lifePositionTop = (_gameBoard.numRows - 1) * _gameBoard.grid.height;

            // Define five lives for the player by populating the _lives array with five
            // instances of the Life "class", each one initialized with its starting position
            // from left to right along the bottom-left corner of the game board
            _lives = [

                // Each life is displayed at the same position from the top of the game board
                // and each spaced horizontally according to the width of the individual
                // image so they sit right beside each other
                new Life(0, lifePositionTop),
                new Life(1 * Life.prototype.width, lifePositionTop),
                new Life(2 * Life.prototype.width, lifePositionTop),
                new Life(3 * Life.prototype.width, lifePositionTop),
                new Life(4 * Life.prototype.width, lifePositionTop)
            ];

            // Listen for the "render-base-layer" event fired from within the game loop and
            // execute the render() function, defined further down, when it is called
            Frogger.observer.subscribe("render-base-layer", render);
        }

        // Define a function to render the number of lives remaining on the game board
        function renderLives() {
            var index = 0,
                length = _lives.length,
                life;

            // Loop through the number of remaining lives stored in the _lives array, and
            // call the renderAt() method of each of the Life "class" instances contained
            // within, drawing the life on the game board at the appropriate position
            for (; index < length; index++) {
                life = _lives[index];

                life.renderAt(life.left, life.top);
            }
        }

        // Define a function to render the time remaining as a green rectangular bar along the
        // bottom edge of the game board
        function renderTimeRemaining() {

            // Define the width of the rectangle. When full, this will be the width of 10
            // columns on the game board. As the time remaining decreases, the width will
            // decrease accordingly
            var rectangleWidth = _timeRemainingAsPercentage * _gameBoard.rows[10],

                // Define the height of the rectangle, which will always be half of one grid
                // square on the game board
                rectangleHeight = _gameBoard.grid.height / 2,

                // Define the left-hand edge, in pixels, where the rectangle should be drawn
                // from on the <canvas>. Since the countdown should appear to be decreasing
                // from the left to the right, this will be the inverse of the time remaining
                // percentage, multiplied by the full width of the rectangle
                rectangleLeft = (1 - _timeRemainingAsPercentage) * _gameBoard.rows[10],

                // Define the top edge, in pixels, where the rectangle should be drawn from
                // on the <canvas> element. This will be the bottom edge of the game board so
                // we need to subtract the desired height of the rectangle from the height
                // of the game board itself
                rectangleTop = Frogger.drawingSurfaceHeight - rectangleHeight;

            // Set the drawing context to draw in green (hex color #0F0)
            Frogger.drawingSurface.fillStyle = "#0F0";

            // Draw the rectangle on the game board at the given positions
            Frogger.drawingSurface.fillRect(rectangleLeft, rectangleTop, rectangleWidth, rectangleHeight);
        }

        // Define a function to draw the remaining lives and time remaining on the game board,
        // executed when the "render-base-layer" event is fired from within the game loop
        function render() {
            renderLives();
            renderTimeRemaining();
        }

        // When the game logic module informs us that the player has lost a life, we remove
        // the last entry from the _lives array, which removes the right-most life image from
        // the bottom-left corner of the canvas, indicating the correct number of lives
        // remaining
        Frogger.observer.subscribe("player-lost-life", function() {
            _lives.pop();
        });

        // When the game logic module informs us that the time remaining for the player to
        // reach the goal has changed, we store the new value returned as a percentage
        Frogger.observer.subscribe("time-remaining-change", function(newTimeRemainingPercentage) {
            _timeRemainingAsPercentage = newTimeRemainingPercentage;
        });

        // When the game board initializes its properties and settings, execute the
        // initialize() function
        Frogger.observer.subscribe("game-board-initialize", initialize);
    }(Frogger));

    // Define a namespace to store the individual obstacles and images to place on the game
    // board as "classes" representing the individual images from the sprite map for each
    Frogger.Image = (function(Frogger) {

        // Define a race car obstacle whose starting position on the x-axis can be set when
        // instantiated
        function RaceCar(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The race car is defined as the image found in the sprite map at position 0px x 80px
        // respectively from the left and top edges of the sprite map image file
        RaceCar.prototype = new Frogger.ImageSprite();
        RaceCar.prototype.constructor = RaceCar;
        RaceCar.prototype.spriteLeft = 0;
        RaceCar.prototype.spriteTop = 80;

        // Define a bulldozer obstacle
        function Bulldozer(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The bulldozer is the image found at position 80px x 80px within the sprite map
        Bulldozer.prototype = new Frogger.ImageSprite();
        Bulldozer.prototype.constructor = Bulldozer;
        Bulldozer.prototype.spriteLeft = 80;
        Bulldozer.prototype.spriteTop = 80;

        // Define a turbo race car obstacle
        function TurboRaceCar(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The turbo race car is the image found at position 160px x 80px within the sprite map
        TurboRaceCar.prototype = new Frogger.ImageSprite();
        TurboRaceCar.prototype.constructor = TurboRaceCar;
        TurboRaceCar.prototype.spriteLeft = 160;
        TurboRaceCar.prototype.spriteTop = 80;

        // Define a road car obstacle
        function RoadCar(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The road car is the image found at position 240px x 80px within the sprite map
        RoadCar.prototype = new Frogger.ImageSprite();
        RoadCar.prototype.constructor = RoadCar;
        RoadCar.prototype.spriteLeft = 240;
        RoadCar.prototype.spriteTop = 80;

        // Define a truck obstacle
        function Truck(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The truck is the image found at position 320px x 80px within the sprite map, with a
        // width of 122px as opposed to the standard 80px width of the other individual images
        Truck.prototype = new Frogger.ImageSprite();
        Truck.prototype.constructor = Truck;
        Truck.prototype.spriteLeft = 320;
        Truck.prototype.spriteTop = 80;
        Truck.prototype.width = 122;

        // Define a short log obstacle
        function ShortLog(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The short log is the image found at position 0px x 160px within the sprite map, with
        // a width of 190px
        ShortLog.prototype = new Frogger.ImageSprite();
        ShortLog.prototype.constructor = ShortLog;
        ShortLog.prototype.spriteLeft = 0;
        ShortLog.prototype.spriteTop = 160;
        ShortLog.prototype.width = 190;

        // Define a medium log obstacle
        function MediumLog(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The medium log is the image found at position 0px x 240px within the sprite map,
        // with a width of 254px
        MediumLog.prototype = new Frogger.ImageSprite();
        MediumLog.prototype.constructor = MediumLog;
        MediumLog.prototype.spriteLeft = 0;
        MediumLog.prototype.spriteTop = 240;
        MediumLog.prototype.width = 254;

        // Define a long log obstacle
        function LongLog(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The long log is the image found at position 240px x 160px within the sprite map,
        // with a width of 392px
        LongLog.prototype = new Frogger.ImageSprite();
        LongLog.prototype.constructor = LongLog;
        LongLog.prototype.spriteLeft = 240;
        LongLog.prototype.spriteTop = 160;
        LongLog.prototype.width = 392;

        // Define a turtle obstacle. There are two types of turtle obstacle on the game board,
        // one representing a group of two turtles and one representing a group of three
        // turtles. Both types of turtle obstacle have some shared behavior which is defined
        // in this "class" which acts as a base for both obstacles to inherit from.
        function Turtle(left) {
            Frogger.ImageSprite.call(this, left);
        }

        Turtle.prototype = new Frogger.ImageSprite();
        Turtle.prototype.constructor = Turtle;

        // The turtles will animate and appear to dip underwater on occasion. We need to
        // know when the turtle is underwater so that if the player's character is positioned
        // above the turtle at that point, they will lose a life. This will be handled by the
        // collision detection code later, but for now we just need to create a method to
        // tell us when the turtle in underwater
        Turtle.prototype.isUnderwater = function() {
            var isUnderwater = false,

                // Get a reference to the current animation of the turtle diving underwater
                // and resurfacing
                animation = this.animations[this.currentAnimation];

            // The turtle is deemed to be underwater when it is showing the furthestmost image
            // from the sprite map in the animation sequence. This is represented by the
            // largest number in the animation frame sequence which we can get using the
            // Math.max() method in JavaScript. If the current animation sequence value matches
            // this furthestmost image in the sprite map, the turtle is underwater.
            if (animation.getSequenceValue() === Math.max.apply(Math, animation.sequence)) {
                isUnderwater = true;
            }

            return isUnderwater;
        };

        // Define an obstacle representing a group of two turtles together
        function TwoTurtles(left) {
            Turtle.call(this, left);
        }

        // Inherit from the Turtle base "class" defined previously
        TwoTurtles.prototype = new Turtle();
        TwoTurtles.prototype.constructor = TwoTurtles;

        // The group of two turtles is the image found at position 320px x 240px within the
        // sprite map, with a width of 130px
        TwoTurtles.prototype.spriteLeft = 320;
        TwoTurtles.prototype.spriteTop = 240;
        TwoTurtles.prototype.width = 130;

        // Override the reset() method to define and auto-play the animation of the turtle
        // diving and surfacing
        TwoTurtles.prototype.reset = function() {
            Turtle.prototype.reset.call(this);

            // Register the dive and surface animation which plays each frame in the sequence
            // at a frame rate of 200 milliseconds, and loops once it reaches the end of the
            // sequence. The numbers in the sequence represent the multiples of offset of the
            // width of the individual image to grab the animating image from - essentially
            // switching between a number of side-by-side images from the sprite map file to
            // give the illusion of movement
            this.registerAnimation({
                "diveAndSurface": {
                    sequence: [0, 1, 2, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    loop: true,
                    rate: 200
                }
            });

            // Play the animation straight away
            this.playAnimation("diveAndSurface");
        };

        // Define an obstacle representing a group of three turtles together
        function ThreeTurtles(left) {
            Turtle.call(this, left);
        }

        // Inherit from the Turtle base "class" defined previously
        ThreeTurtles.prototype = new Turtle();
        ThreeTurtles.prototype.constructor = ThreeTurtles;

        // The group of three turtles is the image found at position 0px x 320px within the
        // sprite map, with a width of 200px
        ThreeTurtles.prototype.spriteLeft = 0;
        ThreeTurtles.prototype.spriteTop = 320;
        ThreeTurtles.prototype.width = 200;

        // Register the dive and surface animation as before, but animating over a greater
        // number of frames and at a slower animation rate than with the group of two turtles
        ThreeTurtles.prototype.reset = function() {
            Turtle.prototype.reset.call(this);

            this.registerAnimation({
                "diveAndSurface": {
                    sequence: [0, 1, 2, 3, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    loop: true,
                    rate: 300
                }
            });

            this.playAnimation("diveAndSurface");
        };

        // Define a "class" representing the frog image displayed when the player's character
        // reaches the goal
        function GoalFrog(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // The goal frog is the image found at position 640px x 80px within the sprite map
        GoalFrog.prototype = new Frogger.ImageSprite();
        GoalFrog.prototype.constructor = GoalFrog;
        GoalFrog.prototype.spriteLeft = 640;
        GoalFrog.prototype.spriteTop = 80;

        // Override the moveTo() method so that this image cannot be moved from its place
        // on the game board once it has been placed down
        GoalFrog.prototype.moveTo = function() {};

        // Define a "class" representing the goal the player will be aiming to meet with at
        // the far end of the game board from their start position
        function Goal(left) {
            Frogger.ImageSprite.call(this, left);
        }

        // Since the goal is drawn onto the game board as part of the background <canvas>
        // we do not need to draw it again here, so we specify the image position as being
        // a transparent block from the sprite map image so effectively nothing is actually
        // drawn to the canvas. We can still take advantage of the other features of the
        // ImageSprite "class", however, to simplify collision checking later on, which
        // will tell us when the player's character has reached a goal
        Goal.prototype = new Frogger.ImageSprite();
        Goal.prototype.constructor = Goal;
        Goal.prototype.spriteLeft = 800;
        Goal.prototype.spriteTop = 320;

        // Override the moveTo() method so that the goal cannot be moved from its place
        // on the game board once it has been placed down
        Goal.prototype.moveTo = function() {};

        // Add a custom property to this "class" to denote whether the goal instance has been
        // met by the player's character
        Goal.prototype.isMet = false;

        // Expose the "classes" defined in this module to the wider code base within the
        // Frogger.Image namespace
        return {
            RaceCar: RaceCar,
            Bulldozer: Bulldozer,
            RoadCar: RoadCar,
            TurboRaceCar: TurboRaceCar,
            Truck: Truck,
            ShortLog: ShortLog,
            MediumLog: MediumLog,
            LongLog: LongLog,
            TwoTurtles: TwoTurtles,
            ThreeTurtles: ThreeTurtles,
            GoalFrog: GoalFrog,
            Goal: Goal
        };
    }(Frogger));

    // Define a code module to represent the player's character on the game board and to
    // handle its movement and behavior according to the current game state
    Frogger.Character = (function(Frogger) {

        // Define a variable to store the image representing the player's character
        var _character,

            // Define a variable to store the game board properties and settings
            _gameBoard = {},

            // Define a variable to denote the starting row of the player's character on the
            // game board
            _startRow = 14,

            // Define a variable to denote the starting columns of the player's character on
            // the game board - essentially centered
            _startColumn = 6,

            // Define a variable to store the current row the player's character has reached
            _currentRow = _startRow,

            // Define a Boolean variable to indicate whether the player's character is
            // currently frozen in place, as happens temporarily when the player loses a life
            // or reaches the goal
            _isFrozen = false;

        // Define a "class" to represent the player's frog character, inheriting from the
        // Frogger.ImageSprite "class". The left and top values passed in on instantiation
        // reflect the starting position in pixels of the player's character from the top-left
        // hand corner of the game board
        function Character(left, top) {
            Frogger.ImageSprite.call(this, left, top);

            // Register five animations to play when the player loses a life or when the
            // character is moved in any of four different directions - up, down, left or right
            this.registerAnimation({

                // When the player loses a life, switch between the three images found starting
                // at 640px from the left of the sprite map image at a rate of 350 milliseconds,
                // stopping on the last image
                "lose-life": {
                    spriteLeft: 640,
                    sequence: [0, 1, 2],
                    rate: 350
                },

                // When the player's character moves up a row on the game board, switch between
                // the two images found starting at the left-hand edge of the sprite map
                "move-up": {
                    spriteLeft: 0,
                    sequence: [1, 0]
                },

                // When the player's character moves right on the game board, switch between
                // the two images found starting at 160px from left-hand edge of the sprite map
                "move-right": {
                    spriteLeft: 160,
                    sequence: [1, 0]
                },

                // When the player's character moves down on the game board, switch between
                // the two images found starting at 320px from left-hand edge of the sprite map
                "move-down": {
                    spriteLeft: 320,
                    sequence: [1, 0]
                },

                // When the player's character moves left on the game board, switch between
                // the two images found starting at 480px from left-hand edge of the sprite map
                "move-left": {
                    spriteLeft: 480,
                    sequence: [1, 0]
                }
            });
        }

        // Inherit from the Frogger.ImageSprite "class"
        Character.prototype = new Frogger.ImageSprite();
        Character.prototype.constructor = Character;

        // Define the individual images for the player's character sprite as being found at
        // position 0px x 0px within the sprite map image file
        Character.prototype.spriteLeft = 0;
        Character.prototype.spriteTop = 0;

        // Define a method to move the character up one row on the game board
        Character.prototype.moveUp = function() {

            // Move the top position of the character up by the height of one grid square
            // on the game board
            this.top -= _gameBoard.grid.height;

            // Ensure the character does not move outside of the bounds restricting its
            // movement around the game board - we don't want it appearing on top of the
            // score at the top of the screen
            if (this.top < _gameBoard.characterBounds.top) {
                this.top = _gameBoard.characterBounds.top;
            }

            // Play the animation named "move-up", making it look like the character is moving
            this.playAnimation("move-up");

            // Keep track of the current row the character sits upon
            _currentRow--;
        };

        // Define a method to move the character down one row on the game board
        Character.prototype.moveDown = function() {

            // Move the top position of the character down by the height of one grid square
            // on the game board
            this.top += _gameBoard.grid.height;

            // Ensure the character does not move outside of the bounds restricting its
            // movement around the game board - we don't want it appearing on top of the
            // countdown timer at the base of the screen
            if (this.top > _gameBoard.characterBounds.bottom) {
                this.top = _gameBoard.characterBounds.bottom;
            } else _currentRow++; // Keep track of the current row the character sits upon. Moved to else, to prevent "moving away" when moveDown from the bottom of the screen

            // Play the animation named "move-down", making it look like the character is moving
            this.playAnimation("move-down");



        };

        // Define a method to move the character one column to the left on the game board
        Character.prototype.moveLeft = function() {

            // Move the position of the character on the game board left by the width of one
            // grid square on the game board
            this.left -= _gameBoard.grid.width;

            // Ensure the character does not move outside of the bounds restricting its
            // movement around the game board - we don't want it disappearing off the side
            if (this.left < _gameBoard.characterBounds.left) {
                this.left = _gameBoard.characterBounds.left;
            }

            // Play the animation named "move-left", making it look like the character is moving
            this.playAnimation("move-left");
        };

        // Define a method to move the character one column to the right on the game board
        Character.prototype.moveRight = function() {

            // Move the position of the character on the game board right by the width of one
            // grid square on the game board
            this.left += _gameBoard.grid.width;

            // Ensure the character does not move outside of the bounds restricting its
            // movement around the game board - we don't want it disappearing off the side
            if (this.left > _gameBoard.characterBounds.right) {
                this.left = _gameBoard.characterBounds.right;
            }

            // Play the animation named "move-right", making it look like the character is moving
            this.playAnimation("move-right");
        };

        // Define a function which returns the current position of the player's character in
        // pixels from the top of the game board
        function getTop() {

            // Look up the top position in pixels from the game board properties by the current
            // row the character is sitting upon
            return _gameBoard.rows[_currentRow];
        }

        // Define a function which hides the player's character from display
        function hide() {

            // Call the hide() method on the instance of the Character "class" that will
            // represent the player's character
            _character.hide();
        }

        // Define a function which moves the player's character in one of four possible
        // directions - up, down, left, or right
        function move(characterDirection) {

            // Only move the player's character if it is not deemed to be frozen in place
            if (!_isFrozen) {

                // Call the appropriate method on the Character instance based on the
                // direction the character is to move in
                if (characterDirection === Frogger.direction.LEFT) {
                    _character.moveLeft();
                } else if (characterDirection === Frogger.direction.RIGHT) {
                    _character.moveRight();
                } else if (characterDirection === Frogger.direction.UP) {
                    _character.moveUp();
                } else if (characterDirection === Frogger.direction.DOWN) {
                    _character.moveDown();
                }

                // Publish an event to the rest of the code modules, indicating that the
                // player's position has been moved by the player
                Frogger.observer.publish("player-moved");
            }
        }

        // Define a function to render the player's character on screen
        function render() {

            // Call the Character instance's renderAt() method, passing along its current
            // left and top position
            _character.renderAt(_character.left, _character.top);
        }

        // Define a function, to be executed when the player loses a life, which plays the
        // appropriate animation
        function loseLife() {
            _character.playAnimation("lose-life");
        }

        // Define a function to move the player's character to the given position in pixels
        // from the left-hand edge of the game board - this will be used when the character
        // is sitting on a moving object to keep the character aligned with that object
        function setPosition(left) {

            // Ensure the character does not move outside of its defined bounds on the game
            // board
            if (left > _gameBoard.characterBounds.right) {
                left = _gameBoard.characterBounds.right;
            } else if (left < _gameBoard.characterBounds.left) {
                left = _gameBoard.characterBounds.left;
            }

            // Move the character's position from the left-hand edge of the game board to match
            // the given position
            _character.moveTo(left);
        }

        // Define a function to reset the player's character's position on the game board
        function reset() {
            _character.reset();

            // Reset the local variable indicating the current row the character sits upon
            _currentRow = _startRow;
        }

        // Define a function to return the current position of the character on the game board
        function getPosition() {
            return _character.getPosition();
        }

        // Define a function to set the local _isFrozen variable to true, indicating that the
        // player's character's position on the game board should be frozen in place
        function freeze() {
            _isFrozen = true;
        }

        // Define a function to set the local _isFrozen variable to false, indicating that the
        // player's character is free to move around the game board
        function unfreeze() {
            _isFrozen = false;
        }

        // Define a function to be executed when the game board has initialized, passing along
        // the properties and settings from the game board code module
        function initialize(gameBoard) {
            _gameBoard = gameBoard;

            // Initialize an instance of the Character "class" to represent the player's
            // character, setting its start position on the game board
            _character = new Character(_gameBoard.columns[_startColumn], _gameBoard.rows[_startRow]);

            // Ensure the local render() function is executed when the "render-character"
            // event is fired from within the game loop to draw the player's character on
            // the screen
            Frogger.observer.subscribe("render-character", render);
        }

        // When the game logic module informs us that the player has lost a life, execute the
        // loseLife() function to play the appropriate animation
        Frogger.observer.subscribe("player-lost-life", loseLife);

        // When the game logic informs us the player's position needs to be reset, execute the
        // reset() function
        Frogger.observer.subscribe("reset", reset);

        // When the player has reached the goal, hide the player from the screen temporarily
        Frogger.observer.subscribe("player-at-goal", hide);

        // When the game logic tells us the player's character must stay in place on the
        // game board, we set the appropriate local variable to reflect this
        Frogger.observer.subscribe("player-freeze", freeze);

        // When the game logic tells us the player's character is free to move around the
        // game board again, we set the appropriate local variable to reflect this
        Frogger.observer.subscribe("player-unfreeze", unfreeze);

        // When the game board module initializes its properties and settings, execute the
        // initialize() function
        Frogger.observer.subscribe("game-board-initialize", initialize);

        // When the player presses the arrow keys on the keyboard, move the player's
        // character in the appropriate direction on the game board
        window.addEventListener("keydown", function(event) {

            // Define the key codes for the arrow keys
            var LEFT_ARROW = 37,
                UP_ARROW = 38,
                RIGHT_ARROW = 39,
                DOWN_ARROW = 40;

            // Execute the move() function, passing along the correct direction based on the
            // arrow key pressed. Ignore any other key presses
            if (event.keyCode === LEFT_ARROW) {
                move(Frogger.direction.LEFT);
            } else if (event.keyCode === RIGHT_ARROW) {
                move(Frogger.direction.RIGHT);
            } else if (event.keyCode === UP_ARROW) {
                move(Frogger.direction.UP);
            } else if (event.keyCode === DOWN_ARROW) {
                move(Frogger.direction.DOWN);
            }
        }, false);

        // When the player taps in certain places on the game board on their touch-sensitive
        // screen, move the player's character in the appropriate direction on the game board
        // according to where the screen has been tapped. This is useful since users with
        // touch screens are typically on mobile devices that do not have access to
        // physical keyboards to press the arrow keys to move the character.
        Frogger.canvas.addEventListener("touchstart", function(event) {

            // Get a reference to the position of the touch on the screen in pixels from the
            // top-left position of the touched element, in this case the game board
            var touchLeft = event.targetTouches[0].clientX,
                touchTop = event.targetTouches[0].clientY;

            // Execute the move() function, passing along the correct direction based on the
            // position tapped on the game board
            if (touchLeft < (Frogger.drawingSurfaceWidth / 8)) {
                move(Frogger.direction.LEFT);
            } else if (touchLeft > (3 * Frogger.drawingSurfaceWidth / 8)) {
                move(Frogger.direction.RIGHT);
            } else if (touchTop < (Frogger.drawingSurfaceHeight / 8)) {
                move(Frogger.direction.UP);
            } else if (touchTop > (3 * Frogger.drawingSurfaceHeight / 8)) {
                move(Frogger.direction.DOWN);
            }
        }, false);

        // Expose the local getTop(), getPosition() and setPosition() methods so they are
        // available to other code modules
        return {
            getTop: getTop,
            getPosition: getPosition,
            setPosition: setPosition
        };
    }(Frogger));

    // Define a code module to define the types of obstacle rows that exist on the game board,
    // representing a road-type row which will house vehicles, a water row containing log
    // obstacles, a water row containing turtle obstacles, and a goal row containing the
    // locations the player's character aims to reach to win the game
    Frogger.Row = (function() {

        // Define a base row "class" containing the shared code required for each different
        // type of specialist row on the game board
        function Row(options) {
            options = options || {};

            // Define the direction of obstacles moving on this row, defaults to moving left
            this.direction = options.direction || Frogger.direction.LEFT;

            // Define the set of obstacles to place on this row and move
            this.obstacles = options.obstacles || [];

            // Define the top position, in pixels, of where this row sits on the game board
            this.top = options.top || 0;

            // Define the speed with which obstacles on this row move in the given direction
            // as a factor of the render rate set in game loop
            this.speed = options.speed || 1;
        }

        Row.prototype = {

            // Define a method to render each of the obstacles in the correct place on the
            // current row
            render: function() {
                var index = 0,
                    length = this.obstacles.length,
                    left,
                    obstaclesItem;

                // Loop through each of the obstacles within this row
                for (; index < length; index++) {
                    obstaclesItem = this.obstacles[index];

                    // Update the left position, in pixels, of this obstacle based on its
                    // current position along with the direction and speed of movement
                    left = obstaclesItem.getPosition().left + ((this.direction === Frogger.direction.RIGHT ? 1 : -1) * this.speed);

                    // Adjust the left position such that if the obstacle falls off one edge of
                    // the game board, it then appears to return from the other edge
                    if (left < -obstaclesItem.getWidth()) {
                        left = Frogger.drawingSurfaceWidth;
                    } else if (left >= Frogger.drawingSurfaceWidth) {
                        left = -obstaclesItem.getWidth();
                    }

                    // Move the obstacle and draw it on the game board in the updated position
                    obstaclesItem.moveTo(left);
                    obstaclesItem.renderAt(left, this.top);
                }
            },

            // Define a method to return the top position, in pixels, of this row
            getTop: function() {
                return this.top;
            },

            // Define a method to detect whether the player's character is currently colliding
            // with an obstacle on this row
            isCollision: function(characterPosition) {
                var index = 0,
                    length = this.obstacles.length,
                    obstaclesItem,
                    isCollision = false;

                // Loop through each of the obstacles on this row
                for (; index < length; index++) {
                    obstaclesItem = this.obstacles[index];

                    // If the player's character touches the current obstacle, a collision
                    // has taken place and we return this fact to the calling code
                    if (Frogger.intersects(obstaclesItem.getPosition(), characterPosition)) {
                        isCollision = true;
                    }
                }

                return isCollision;
            },

            // Define a method to reset the obstacles on this row to their default state and
            // position on the game board
            reset: function() {
                var index = 0,
                    length = this.obstacles.length;

                // Loop through each of the obstacles within this row, and call their reset()
                // methods in turn
                for (; index < length; index++) {
                    this.obstacles[index].reset();
                }
            }
        };

        // Define a new "class" representing a road-type row, containing vehicle obstacles which
        // inherits from our base Row "class"
        function Road(options) {
            Row.call(this, options);
        }

        Road.prototype = new Row();
        Road.prototype.constructor = Road;

        // Define a new "class" representing a row containing logs floating on water which
        // inherits from our base Row "class"
        function Log(options) {
            Row.call(this, options);
        }

        Log.prototype = new Row();
        Log.prototype.constructor = Log;

        // Override the isCollision() method, reversing its behavior. If the player's character
        // touches a log it is safe, however it should be considered a collision if it touches
        // the water beneath rather than the obstacle itself
        Log.prototype.isCollision = function(characterPosition) {

            // Return the opposite Boolean state returned by a normal call to the isCollision()
            // method
            return !Row.prototype.isCollision.call(this, characterPosition);
        };

        // Override the render() method so that when the player's character lands on a log,
        // it gets transported along the water with the log
        Log.prototype.render = function() {

            // If the player's character is on this row, update its position based on the
            // direction and speed of motion of the log the player has landed on
            if (Frogger.Character.getTop() === this.getTop()) {
                Frogger.Character.setPosition(Frogger.Character.getPosition().left + ((this.direction === Frogger.direction.RIGHT ? 1 : -1) * this.speed));
            }

            // Call the inherited render() method to draw the log in its new position
            Row.prototype.render.call(this);

        };

        // Define a new "class" representing a row containing turtles swimming in the water
        // which inherits from our Log "class" as it shares similarities
        function Turtle(options) {
            Log.call(this, options);
        }

        Turtle.prototype = new Log();
        Turtle.prototype.constructor = Turtle;

        // Override the isCollision() method such that it behaves like the same method on
        // the Log "class" apart from when the turtle obstacle has dipped underwater, in which
        // case there will always be a collision if the player's character is on this row
        Turtle.prototype.isCollision = function(characterPosition) {
            var isCollision = Log.prototype.isCollision.call(this, characterPosition);
            return this.obstacles[0].isUnderwater() || isCollision;
        };

        // Define a new "class" representing the goal row the player's character is aiming for
        // in order to win the game, which inherits from our base Row "class"
        function Goal(options) {

            // The goals placed within this row never move so we always force the speed
            // property to be 0
            options.speed = 0;

            Row.call(this, options);
        }

        Goal.prototype = new Row();
        Goal.prototype.constructor = Goal;

        // Override the isCollision() method to detect if the player's character has reached
        // one of the available goals stored in this row
        Goal.prototype.isCollision = function(characterPosition) {
            var index = 0,
                length = this.obstacles.length,
                obstaclesItem,
                isCollision = true;

            // Loop through the goals in this row to find out if the player has reached one
            // of them
            for (; index < length; index++) {
                obstaclesItem = this.obstacles[index];
                // Skip the goal frogs appended to the row
                if (! ('isMet' in obstaclesItem)) break;

                // If this goal has not been reached before and the player's character is
                // positioned above the goal, fire the "player-at-goal" event so the game logic
                // module registers that the goal has been reached
                if (Frogger.intersects(obstaclesItem.getPosition(), characterPosition)) {
                    if (!obstaclesItem.isMet) {
                        this.obstacles[index].isMet = true;
                        Frogger.observer.publish("player-at-goal");
                        isCollision = false;

                        // Add the image of the goal-reached frog to the row within the goal
                        // reached so the user can see that they have reached this goal before
                        this.obstacles.push(new Frogger.Image.GoalFrog(obstaclesItem.getPosition().left));
                    }
                    break;
                }
            }

            return isCollision;
        };

        // Return the "classes" defined in this code module for use in the rest of our code
        return {
            Road: Road,
            Log: Log,
            Turtle: Turtle,
            Goal: Goal
        };
    }(Frogger));

    // Define a code module to add rows containing obstacles to the game board for the player
    // to avoid or make contact with in order to progress from the bottom to the top of the
    // game board in order to win the game by reaching each of the five goals without losing
    // all their lives or the allocated time running out
    (function(Frogger) {

        // Define variables to store the populated rows on the game board, and the properties
        // and settings of the game board itself
        var _rows = [],
            _gameBoard = {};

        // Define a function to be called when the game board has initialized onto which we
        // place our rows and obstacles
        function initialize(gameBoard) {
            _gameBoard = gameBoard;

            // Add elevent rows of obstacles to the game board
            _rows = [

                // Add a goal row to the 3rd row on the game board (the rows start from index
                // 0), containing five goals positioned in the respective places according to
                // the designation on the game board background image
                new Frogger.Row.Goal({
                    top: _gameBoard.rows[2],
                    obstacles: [new Frogger.Image.Goal(33, 111), new Frogger.Image.Goal(237, 315), new Frogger.Image.Goal(441, 519), new Frogger.Image.Goal(645, 723), new Frogger.Image.Goal(849, 927)]
                }),

                // Add a row of medium-length logs to the 4th row on the game board, moving
                // right at a rate of 5 pixels per each time the game loop is called to
                // render this row within the <canvas>
                new Frogger.Row.Log({
                    top: _gameBoard.rows[3],
                    direction: Frogger.direction.RIGHT,
                    speed: 5,

                    // Add three medium-sized log obstacles to the game board, spaced out evenly
                    obstacles: [new Frogger.Image.MediumLog(_gameBoard.columns[1]), new Frogger.Image.MediumLog(_gameBoard.columns[6]), new Frogger.Image.MediumLog(_gameBoard.columns[10])]
                }),

                // Add a row of turtles, grouped in twos, on the 5th row of the game board,
                // moving left (the default direction) at a rate of 6 pixels on each turn of the
                // game loop
                new Frogger.Row.Turtle({
                    top: _gameBoard.rows[4],
                    speed: 6,

                    // Add four obstacles spaced out across the width of the game board
                    obstacles: [new Frogger.Image.TwoTurtles(_gameBoard.columns[0]), new Frogger.Image.TwoTurtles(_gameBoard.columns[3]), new Frogger.Image.TwoTurtles(_gameBoard.columns[6]), new Frogger.Image.TwoTurtles(_gameBoard.columns[9])]
                }),

                // Add a row of long-length logs to the 6th row on the game board, moving right
                // at a rate of 7 pixels on each turn of the game loop
                new Frogger.Row.Log({
                    top: _gameBoard.rows[5],
                    direction: Frogger.direction.RIGHT,
                    speed: 7,

                    // Add two long-length log obstacles to this row
                    obstacles: [new Frogger.Image.LongLog(_gameBoard.columns[1]), new Frogger.Image.LongLog(_gameBoard.columns[10])]
                }),

                // Add a row of short-length logs to the 7th row of the game board, moving right
                // at a rate of 3 pixels each time the game loop is called
                new Frogger.Row.Log({
                    top: _gameBoard.rows[6],
                    direction: Frogger.direction.RIGHT,
                    speed: 3,

                    // Add three short-length logs to this row
                    obstacles: [new Frogger.Image.ShortLog(_gameBoard.columns[1]), new Frogger.Image.ShortLog(_gameBoard.columns[6]), new Frogger.Image.ShortLog(_gameBoard.columns[10])]
                }),

                // Add a row of turtles, grouped in threes, on the 8th row of the game board,
                // moving left at a rate of 5 pixels each time the game loop is called
                new Frogger.Row.Turtle({
                    top: _gameBoard.rows[7],
                    speed: 5,
                    obstacles: [new Frogger.Image.ThreeTurtles(_gameBoard.columns[0]), new Frogger.Image.ThreeTurtles(_gameBoard.columns[3]), new Frogger.Image.ThreeTurtles(_gameBoard.columns[7]), new Frogger.Image.ThreeTurtles(_gameBoard.columns[10])]
                }),

                // Add a set of truck-style vehicle obstacles to the 10th row of the game
                // board (the 9th row is considered a "safe" row that contains no obstacles)
                new Frogger.Row.Road({
                    top: _gameBoard.rows[9],
                    speed: 3,
                    obstacles: [new Frogger.Image.Truck(_gameBoard.columns[1]), new Frogger.Image.Truck(_gameBoard.columns[7])]
                }),

                // Add a set of turbo race car obstacles to the 11th row of the game board,
                // moving right at a fast rate
                new Frogger.Row.Road({
                    top: _gameBoard.rows[10],
                    direction: Frogger.direction.RIGHT,
                    speed: 12,
                    obstacles: [new Frogger.Image.TurboRaceCar(_gameBoard.columns[1]), new Frogger.Image.TurboRaceCar(_gameBoard.columns[7])]
                }),

                // Add a set of simple road car obstacles to the 12th row of the game board
                new Frogger.Row.Road({
                    top: _gameBoard.rows[11],
                    speed: 4,
                    obstacles: [new Frogger.Image.RoadCar(_gameBoard.columns[1]), new Frogger.Image.RoadCar(_gameBoard.columns[7])]
                }),

                // Add a set of bulldozer-style obstacles to the 13th row of the game board
                new Frogger.Row.Road({
                    top: _gameBoard.rows[12],
                    direction: Frogger.direction.RIGHT,
                    speed: 3,
                    obstacles: [new Frogger.Image.Bulldozer(_gameBoard.columns[1]), new Frogger.Image.Bulldozer(_gameBoard.columns[7])]
                }),

                // Add a set of race car obstacles to the 14th row of the game board, which is
                // one row above where the player's character's starting position is
                new Frogger.Row.Road({
                    top: _gameBoard.rows[13],
                    speed: 4,
                    obstacles: [new Frogger.Image.RaceCar(_gameBoard.columns[2]), new Frogger.Image.RaceCar(_gameBoard.columns[6])]
                })
            ];

            // With the rows and obstacles initialized, connect the local render() function to
            // the "render-base-layer" event fired from within the game loop to draw those
            // obstacles onto the game board
            Frogger.observer.subscribe("render-base-layer", render);
        }

        // Define a function to render each of the defined rows of obstacles onto the game board
        function render() {
            var row,
                index = 0,
                length = _rows.length;

            // Loop through each row calling its render() method, which in turn calls the
            // render() method of each of the obstacles stored within it
            for (; index < length; index++) {
                row = _rows[index];
                row.render();
            }
        }

        // Define a function to detect whether a collision has occured between the player's
        // character and the obstacles within each row
        function isCollision() {
            var collided = false,
                row,
                index = 0,
                length = _rows.length;

            // Loop through each row calling its isCollision() method, which determines
            // whether the obstacles on that row come into contact with the player's
            // character on the game board
            for (; index < length; index++) {
                row = _rows[index];

                if (Frogger.Character.getTop() === row.getTop()) {
                    collided = row.isCollision(Frogger.Character.getPosition());
                    if (collided) {
                        break;
                    }
                }
            }

            // If a collision has occured, trigger the "collision" event which the game logic
            // module uses to cause the player to lose a life
            if (collided) {
                Frogger.observer.publish("collision");
            }

            return collided;
        }

        // Define a function to reset each of the rows to reset to their initial state
        function reset() {
            var row;

            // Loop through each row calling its reset() method, which in turn calls the
            // reset() method of each of the obstacles within that row
            for (var index = 0, length = _rows.length; index < length; index++) {
                row = _rows[index];
                row.reset();
            }
        }

        // When the game logic wishes the game board to reset, call the local reset() function
        Frogger.observer.subscribe("reset", reset);

        // When the game loop wishes to check for collisions, call the local isCollision()
        // function, which will fire a "collision" event if a collision occurs
        Frogger.observer.subscribe("check-collisions", isCollision);

        // When the game board has initialized its properties and settings, call the local
        // initialize() function to place the rows and obstacles onto the game board
        Frogger.observer.subscribe("game-board-initialize", initialize);
    }(Frogger));

    // Now the code modules have been registered, kick off the game logic and start the game
    Frogger.observer.publish("game-load");
})
 
    document.querySelector('#mario').addEventListener('click', () => {
        document.querySelector('#startScreen').style.display = 'none'
        // document.querySelector('#background-canvas').style.display = 'none'
        
        new Enjine.Application().Initialize(new Mario.LoadingState(), 320, 240);
        
    })
 
    document.querySelector('#brickbreak').addEventListener('click', () => {
        document.querySelector('#startScreen').style.display = 'none'
        document.querySelector('#levels').style.display = 'block'
        // document.querySelector('#background-canvas').style.display = 'none'
        if (!Function.prototype.bind) {
      Function.prototype.bind = function(obj) {
        var slice = [].slice,
            args  = slice.call(arguments, 1),
            self  = this,
            nop   = function () {},
            bound = function () {
              return self.apply(this instanceof nop ? this : (obj || {}), args.concat(slice.call(arguments)));   
            };
        nop.prototype   = self.prototype;
        bound.prototype = new nop();
        return bound;
      };
    }

    if (!Object.create) {
      Object.create = function(base) {
        function F() {};
        F.prototype = base;
        return new F();
      }
    }

    if (!Object.construct) {
      Object.construct = function(base) {
        var instance = Object.create(base);
        if (instance.initialize)
          instance.initialize.apply(instance, [].slice.call(arguments, 1));
        return instance;
      }
    }

    if (!Object.extend) {
      Object.extend = function(destination, source) {
        for (var property in source) {
          if (source.hasOwnProperty(property))
            destination[property] = source[property];
        }
        return destination;
      };
    }

    /* NOT READY FOR PRIME TIME
    if (!window.requestAnimationFrame) {// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
      window.requestAnimationFrame = window.webkitRequestAnimationFrame || 
                                    window.mozRequestAnimationFrame    || 
                                    window.oRequestAnimationFrame      || 
                                    window.msRequestAnimationFrame     || 
                                    function(callback, element) {
                                      window.setTimeout(callback, 1000 / 60);
                                    }
    }
    */

    //=============================================================================
    // Minimal DOM Library ($)
    //=============================================================================

    Element = function() {

      var instance = {

        _extended: true,

        showIf: function(on)      { if (on) this.show(); else this.hide(); },
        show:   function()        { this.style.display = '';      },
        hide:   function()        { this.style.display = 'none';  },
        update: function(content) { this.innerHTML     = content; },

        hasClassName:    function(name)     { return (new RegExp("(^|\s*)" + name + "(\s*|$)")).test(this.className) },
        addClassName:    function(name)     { this.toggleClassName(name, true);  },
        removeClassName: function(name)     { this.toggleClassName(name, false); },
        toggleClassName: function(name, on) {
          var classes = this.className.split(' ');
          var n = classes.indexOf(name);
          on = (typeof on == 'undefined') ? (n < 0) : on;
          if (on && (n < 0))
            classes.push(name);
          else if (!on && (n >= 0))
            classes.splice(n, 1);
          this.className = classes.join(' ');
        }
      };

      var get = function(ele) {
        if (typeof ele == 'string')
          ele = document.getElementById(ele);
        if (!ele._extended)
          Object.extend(ele, instance);
        return ele;
      };

      return get;

    }();

    $ = Element;

    //=============================================================================
    // State Machine
    //=============================================================================

    StateMachine = {

      //---------------------------------------------------------------------------

      create: function(cfg) {

        var target  = cfg.target  || {};
        var events  = cfg.events;

        var n, event, name, can = {};
        for(n = 0 ; n < events.length ; n++) {
          event = events[n];
          name  = event.name;
          can[name] = (can[name] || []).concat(event.from);
          target[name] = this.buildEvent(name, event.from, event.to, target);
        }

        target.current = 'none';
        target.is      = function(state) { return this.current == state; };
        target.can     = function(event) { return can[event].indexOf(this.current) >= 0; };
        target.cannot  = function(event) { return !this.can(event); };

        if (cfg.initial) { // see "initial" qunit tests for examples
          var initial = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow single string to represent initial state, or complex object to configure { state: 'first', event: 'init', defer: true|false }
          name = initial.event || 'startup';
          can[name] = ['none'];
          event = this.buildEvent(name, 'none', initial.state, target);
          if (initial.defer)
            target[name] = event; // allow caller to trigger initial transition event
          else
            event.call(target);
        }

        return target;
      },

      //---------------------------------------------------------------------------

      buildEvent: function(name, from, to, target) {

        return function() {

          if (this.cannot(name))
            throw "event " + name + " innapropriate in current state " + this.current;

          var beforeEvent = this['onbefore' + name];
          if (beforeEvent && (false === beforeEvent.apply(this, arguments)))
            return;

          if (this.current != to) {

            var exitState = this['onleave'  + this.current];
            if (exitState)
              exitState.apply(this, arguments);

            this.current = to;

            var enterState = this['onenter' + to] || this['on' + to];
            if (enterState)
              enterState.apply(this, arguments);
          }

          var afterEvent = this['onafter'  + name] || this['on' + name];
          if (afterEvent)
            afterEvent.apply(this, arguments);
        }

      }

      //---------------------------------------------------------------------------

    };

    //=============================================================================
    // GAME
    //=============================================================================

    Game = {

      compatible: function() {
        return Object.create &&
              Object.extend &&
              Function.bind &&
              document.addEventListener && // HTML5 standard, all modern browsers that support canvas should also support add/removeEventListener
              Game.ua.hasCanvas
      },

      start: function(id, game, cfg) {
        if (Game.compatible())
          return Game.current = Object.construct(Game.Runner, id, game, cfg).game; // return the game instance, not the runner (caller can always get at the runner via game.runner)
      },

      ua: function() { // should avoid user agent sniffing... but sometimes you just gotta do what you gotta do
        var ua  = navigator.userAgent.toLowerCase();
        var key =        ((ua.indexOf("opera")   > -1) ? "opera"   : null);
            key = key || ((ua.indexOf("firefox") > -1) ? "firefox" : null);
            key = key || ((ua.indexOf("chrome")  > -1) ? "chrome"  : null);
            key = key || ((ua.indexOf("safari")  > -1) ? "safari"  : null);
            key = key || ((ua.indexOf("msie")    > -1) ? "ie"      : null);

        try {
          var re      = (key == "ie") ? "msie (\\d)" : key + "\\/(\\d\\.\\d)"
          var matches = ua.match(new RegExp(re, "i"));
          var version = matches ? parseFloat(matches[1]) : null;
        } catch (e) {}

        return {
          full:      ua, 
          name:      key + (version ? " " + version.toString() : ""),
          version:   version,
          isFirefox: (key == "firefox"),
          isChrome:  (key == "chrome"),
          isSafari:  (key == "safari"),
          isOpera:   (key == "opera"),
          isIE:      (key == "ie"),
          hasCanvas: (document.createElement('canvas').getContext),
          hasAudio:  (typeof(Audio) != 'undefined'),
          hasTouch:  ('ontouchstart' in window)
        }
      }(),

      addEvent:    function(obj, type, fn) { $(obj).addEventListener(type, fn, false);    },
      removeEvent: function(obj, type, fn) { $(obj).removeEventListener(type, fn, false); },

      windowWidth:  function() { return window.innerWidth  || /* ie */ document.documentElement.offsetWidth;  },
      windowHeight: function() { return window.innerHeight || /* ie */ document.documentElement.offsetHeight; },

      ready: function(fn) {
        if (Game.compatible())
          Game.addEvent(document, 'DOMContentLoaded', fn);
      },

      renderToCanvas: function(width, height, render, canvas) { // http://kaioa.com/node/103
        canvas = canvas || document.createElement('canvas');
        canvas.width  = width;
        canvas.height = height;
        render(canvas.getContext('2d'));
        return canvas;
      },

      loadScript: function(src, cb) {
        var head = document.getElementsByTagName('head')[0];
        var s = document.createElement('script');
        head.appendChild(s);
        if (Game.ua.isIE) {
          s.onreadystatechange = function(e) {
            if (e.currentTarget.readyState == 'loaded')
              cb(e.currentTarget);
          }
        }
        else {
          s.onload = function(e) { cb(e.currentTarget); }
        }
        s.type = 'text/javascript';
        s.src = src;
      },

      loadImages: function(sources, callback) { /* load multiple images and callback when ALL have finished loading */
        var images = {};
        var count = sources ? sources.length : 0;
        if (count == 0) {
          callback(images);
        }
        else {
          for(var n = 0 ; n < sources.length ; n++) {
            var source = sources[n];
            var image = document.createElement('img');
            images[source] = image;
            Game.addEvent(image, 'load', function() { if (--count == 0) callback(images); });
            image.src = source;
          }
        }
      },

      random: function(min, max) {
        return (min + (Math.random() * (max - min)));
      },

      randomChoice: function(choices) {
        return choices[Math.round(Game.random(0, choices.length-1))];
      },

      randomBool: function() {
        return Game.randomChoice([true, false]);
      },

      timestamp: function() { 
        return new Date().getTime();
      },

      THREESIXTY: Math.PI * 2,

      KEY: {
        BACKSPACE: 8,
        TAB:       9,
        RETURN:   13,
        ESC:      27,
        SPACE:    32,
        LEFT:     37,
        UP:       38,
        RIGHT:    39,
        DOWN:     40,
        DELETE:   46,
        HOME:     36,
        END:      35,
        PAGEUP:   33,
        PAGEDOWN: 34,
        INSERT:   45,
        ZERO:     48,
        ONE:      49,
        TWO:      50,
        A:        65,
        D:        68,
        L:        76,
        P:        80,
        Q:        81,
        TILDA:    192
      },

      //-----------------------------------------------------------------------------

      Math: {

        bound: function(box) {
          if (box.radius) {
            box.w      = 2 * box.radius;
            box.h      = 2 * box.radius;
            box.left   = box.x - box.radius;
            box.right  = box.x + box.radius;
            box.top    = box.y - box.radius;
            box.bottom = box.y + box.radius;
          }
          else {
            box.left   = box.x;
            box.right  = box.x + box.w;
            box.top    = box.y;
            box.bottom = box.y + box.h;
          }
          return box;
        },

        overlap: function(box1, box2, returnOverlap) {
          if ((box1.right < box2.left)   ||
              (box1.left  > box2.right)  ||
              (box1.top   > box2.bottom) ||
              (box1.bottom < box2.top)) {
            return false;
          }
          else {
            if (returnOverlap) {
              var left   = Math.max(box1.left,  box2.left);
              var right  = Math.min(box1.right, box2.right);
              var top    = Math.max(box1.top,   box2.top);
              var bottom = Math.min(box1.bottom, box2.bottom);
              return {x: left, y: top, w: right-left, h: bottom-top, left: left, right: right, top: top, bottom: bottom };
            }
            else {
              return true;
            }
          }
        },

        normalize: function(vec, m) {
          vec.m = this.magnitude(vec.x, vec.y);
          if (vec.m == 0) {
            vec.x = vec.y = vec.m = 0;
          }
          else {
            vec.m = vec.m / (m || 1);
            vec.x = vec.x / vec.m;
            vec.y = vec.y / vec.m;
            vec.m = vec.m / vec.m;
          }
          return vec; 
        },

        magnitude: function(x, y) {
          return Math.sqrt(x*x + y*y);
        },

        move: function(x, y, dx, dy, dt) {
          var nx = dx * dt;
          var ny = dy * dt;
          return { x: x + nx, y: y + ny, dx: dx, dy: dy, nx: nx, ny: ny };
        },

        accelerate: function(x, y, dx, dy, accel, dt) {
          var x2  = x + (dt * dx) + (accel * dt * dt * 0.5);
          var y2  = y + (dt * dy) + (accel * dt * dt * 0.5);
          var dx2 = dx + (accel * dt) * (dx > 0 ? 1 : -1);
          var dy2 = dy + (accel * dt) * (dy > 0 ? 1 : -1);
          return { nx: (x2-x), ny: (y2-y), x: x2, y: y2, dx: dx2, dy: dy2 };
        },

        intercept: function(x1, y1, x2, y2, x3, y3, x4, y4, d) {
          var denom = ((y4-y3) * (x2-x1)) - ((x4-x3) * (y2-y1));
          if (denom != 0) {
            var ua = (((x4-x3) * (y1-y3)) - ((y4-y3) * (x1-x3))) / denom;
            if ((ua >= 0) && (ua <= 1)) {
              var ub = (((x2-x1) * (y1-y3)) - ((y2-y1) * (x1-x3))) / denom;
              if ((ub >= 0) && (ub <= 1)) {
                var x = x1 + (ua * (x2-x1));
                var y = y1 + (ua * (y2-y1));
                return { x: x, y: y, d: d};
              }
            }
          }
          return null;
        },

        ballIntercept: function(ball, rect, nx, ny) {
          var pt;
          if (nx < 0) {
            pt = Game.Math.intercept(ball.x, ball.y, ball.x + nx, ball.y + ny, 
                                    rect.right  + ball.radius, 
                                    rect.top    - ball.radius, 
                                    rect.right  + ball.radius, 
                                    rect.bottom + ball.radius, 
                                    "right");
          }
          else if (nx > 0) {
            pt = Game.Math.intercept(ball.x, ball.y, ball.x + nx, ball.y + ny, 
                                    rect.left   - ball.radius, 
                                    rect.top    - ball.radius, 
                                    rect.left   - ball.radius, 
                                    rect.bottom + ball.radius,
                                    "left");
          }
          if (!pt) {
            if (ny < 0) {
              pt = Game.Math.intercept(ball.x, ball.y, ball.x + nx, ball.y + ny, 
                                      rect.left   - ball.radius, 
                                      rect.bottom + ball.radius, 
                                      rect.right  + ball.radius, 
                                      rect.bottom + ball.radius,
                                      "bottom");
            }
            else if (ny > 0) {
              pt = Game.Math.intercept(ball.x, ball.y, ball.x + nx, ball.y + ny, 
                                      rect.left   - ball.radius, 
                                      rect.top    - ball.radius, 
                                      rect.right  + ball.radius, 
                                      rect.top    - ball.radius,
                                      "top");
            }
          }
          return pt;
        }

      },

      //-----------------------------------------------------------------------------

      Runner: {

        initialize: function(id, game, cfg) {
          this.cfg          = Object.extend(game.Defaults || {}, cfg || {}); // use game defaults (if any) and extend with custom cfg (if any)
          this.fps          = this.cfg.fps || 60;
          this.interval     = 1000.0 / this.fps;
          this.canvas       = $(id);
          this.bounds       = this.canvas.getBoundingClientRect();
          this.width        = this.cfg.width  || this.canvas.offsetWidth;
          this.height       = this.cfg.height || this.canvas.offsetHeight;
          this.front        = this.canvas;
          this.front.width  = this.width;
          this.front.height = this.height;
          this.front2d      = this.front.getContext('2d');
          this.addEvents();
          this.resetStats();
          this.resize();

          this.game = Object.construct(game, this, this.cfg); // finally construct the game object itself

          if (this.cfg.state)
            StateMachine.create(Object.extend({target: this.game}, this.cfg.state));

          this.initCanvas();
        },

        start: function() { // game instance should call runner.start() when its finished initializing and is ready to start the game loop
          this.lastFrame = Game.timestamp();
          this.timer     = setInterval(this.loop.bind(this), this.interval);
        },

        stop: function() {
          clearInterval(this.timer);
        },

        loop: function() {
          this._start  = Game.timestamp(); this.update((this._start - this.lastFrame)/1000.0); // send dt as seconds
          this._middle = Game.timestamp(); this.draw();
          this._end    = Game.timestamp();
          this.updateStats(this._middle - this._start, this._end - this._middle);
          this.lastFrame = this._start;
        },

        initCanvas: function() {
          if (this.game && this.game.initCanvas)
            this.game.initCanvas(this.front2d);
        },

        update: function(dt) {
          this.game.update(dt);
        },

        draw: function() {
          this.game.draw(this.front2d);
          this.drawStats(this.front2d);
        },

        resetStats: function() {
          this.stats = {
            count:  0,
            fps:    0,
            update: 0,
            draw:   0, 
            frame:  0  // update + draw
          };
        },

        updateStats: function(update, draw) {
          if (this.cfg.stats) {
            this.stats.update = Math.max(1, update);
            this.stats.draw   = Math.max(1, draw);
            this.stats.frame  = this.stats.update + this.stats.draw;
            this.stats.count  = this.stats.count == this.fps ? 0 : this.stats.count + 1;
            this.stats.fps    = Math.min(this.fps, 1000 / this.stats.frame);
          }
        },

        strings: {
          frame:  "frame: ",
          fps:    "fps: ",
          update: "update: ",
          draw:   "draw: ",
          ms:     "ms"  
        },

        drawStats: function(ctx) {
          if (this.cfg.stats) {
            ctx.fillText(this.strings.frame  + Math.round(this.stats.count),                    this.width - 100, this.height - 60);
            ctx.fillText(this.strings.fps    + Math.round(this.stats.fps),                      this.width - 100, this.height - 50);
            ctx.fillText(this.strings.update + Math.round(this.stats.update) + this.strings.ms, this.width - 100, this.height - 40);
            ctx.fillText(this.strings.draw   + Math.round(this.stats.draw)   + this.strings.ms, this.width - 100, this.height - 30);
          }
        },

        addEvents: function() {
          Game.addEvent(document, 'keydown', this.onkeydown.bind(this));
          Game.addEvent(document, 'keyup',   this.onkeyup.bind(this));
          Game.addEvent(window,   'resize',  this.onresize.bind(this));
        },

        onresize: function() {
          this.stop();
          if (this.onresizeTimer)
            clearTimeout(this.onresizeTimer);
          this.onresizeTimer = setTimeout(this.onresizeend.bind(this), 50); // dont fire resize event until 50ms after user has stopped resizing (avoid flickering)
        },

        onresizeend: function() {
          this.resize();
          this.start();
        },

        resize: function() {
          if ((this.width != this.canvas.offsetWidth) || (this.height != this.front.offsetHeight)) {
            // console.log("CANVAS RESIZED " + this.front.offsetWidth + ", " + this.front.offsetHeight);
            this.width  = this.front.width  = this.front.offsetWidth;
            this.height = this.front.height = this.front.offsetHeight;
            if (this.game && this.game.onresize)
              this.game.onresize(this.width, this.height);
            this.initCanvas(); // when canvas is really resized, its state is reset so we need to re-initialize
          }
        },

        onkeydown: function(ev) {
          if (this.game.onkeydown)
            return this.game.onkeydown(ev.keyCode);
          else if (this.cfg.keys)
            return this.onkey(ev.keyCode, 'down');
        },

        onkeyup: function(ev) {
          if (this.game.onkeyup)
            return this.game.onkeyup(ev.keyCode);
          else if (this.cfg.keys)
            return this.onkey(ev.keyCode, 'up');
        },

        onkey: function(keyCode, mode) {
          var n, k, i, state = this.game.current; // avoid same key event triggering in 2 different states by remembering current state so that even if an earlier keyhandler changes state, the later keyhandler wont kick in.
          for(n = 0 ; n < this.cfg.keys.length ; n++) {
            k = this.cfg.keys[n];
            k.mode = k.mode || 'up';
            if ((k.key == keyCode) || (k.keys && (k.keys.indexOf(keyCode) >= 0))) {
              if (!k.state || (k.state == state)) {
                if (k.mode == mode) {
                  k.action.call(this.game);
                }
              }
            }
          }
        },

        storage: function() {
          try {
            return this.localStorage = this.localStorage || window.localStorage || {};
          }
          catch(e) { // IE localStorage throws exceptions when using non-standard port (e.g. during development)
            return this.localStorage = {};
          }
        },  

        alert: function(msg) {
          this.stop(); // alert blocks thread, so need to stop game loop in order to avoid sending huge dt values to next update
          result = window.alert(msg);
          this.start();
          return result;
        },

        confirm: function(msg) {
          this.stop(); // alert blocks thread, so need to stop game loop in order to avoid sending huge dt values to next update
          result = window.confirm(msg);
          this.start();
          return result;
        }

        //-------------------------------------------------------------------------

      } // Game.Runner
    } // Game

    Breakout = {

    Defaults: {

      fps: 60,
      stats: false,

      score: {
        lives: {
          initial: 3,
          max: 5
        }
      },

      court: {
        xchunks: 30,
        ychunks: 25
      },

      ball: {
        radius:  0.3,
        speed:   15,
        labels: {
          3: { text: 'ready...', fill: '#D82800', stroke: 'black', font: 'bold 28pt arial' },
          2: { text: 'set..',    fill: '#FC9838', stroke: 'black', font: 'bold 28pt arial' },
          1: { text: 'go!',      fill: '#80D010', stroke: 'black', font: 'bold 28pt arial' }
        }
      },

      paddle: {
        width:  6,
        height: 1,
        speed:  20
      },

      color: {
        background: 'rgba(200, 200, 200, 0.5)',
        foreground: 'green',
        border:     '#222',
        wall:       '#333',
        ball:       'black',
        paddle:     'rgb(245,111,37)',
        score:      "#EFD279",
        highscore:  "#AFD775"
      },

      state: {
        initial: 'menu',
        events: [
          { name: 'play',    from: 'menu', to: 'game' },
          { name: 'abandon', from: 'game', to: 'menu' },
          { name: 'lose',    from: 'game', to: 'menu' }
      ]},

      keys: [
        { keys: [Game.KEY.LEFT,  Game.KEY.A],      mode: 'down',  action: function() { this.paddle.moveLeft();          } },
        { keys: [Game.KEY.RIGHT, Game.KEY.D],      mode: 'down',  action: function() { this.paddle.moveRight();         } },
        { keys: [Game.KEY.LEFT,  Game.KEY.A],                     action: function() { this.paddle.stopMovingLeft();    } },
        { keys: [Game.KEY.RIGHT, Game.KEY.D],                     action: function() { this.paddle.stopMovingRight();   } },
        { keys: [Game.KEY.SPACE, Game.KEY.RETURN], state: 'menu', action: function() { this.play();                     } },
        { keys: [Game.KEY.SPACE, Game.KEY.RETURN], state: 'game', action: function() { this.ball.launchNow();           } },
        { key:  Game.KEY.ESC,                      state: 'game', action: function() { this.abandon();                  } },
        { key:  Game.KEY.UP,                       state: 'menu', action: function() { this.nextLevel();                } },
        { key:  Game.KEY.DOWN,                     state: 'menu', action: function() { this.prevLevel();                } }
      ],

      sounds: {
        brick:    'https://github.com/CopeBears/AtariFiles/blob/main/brick.mp3?raw=true',
        paddle:   'https://github.com/CopeBears/AtariFiles/blob/main/paddle.mp3?raw=true',
        go:       'https://github.com/CopeBears/AtariFiles/blob/main/go.mp3?raw=true',
        levelup:  'https://github.com/CopeBears/AtariFiles/blob/main/levelup.mp3?raw=true',
        loselife: 'https://github.com/CopeBears/AtariFiles/blob/main/loselife.mp3?raw=true',
        gameover: 'https://github.com/CopeBears/AtariFiles/blob/main/gameover.mp3?raw=true'
      }

    },


    //-----------------------------------------------------------------------------

    initialize: function(runner, cfg) {
      this.cfg     = cfg;
      this.runner  = runner;
      this.width   = runner.width;
      this.height  = runner.height;
      this.storage = runner.storage();
      this.color   = cfg.color;
      this.sound   = (this.storage.sound == "true");
      this.court   = Object.construct(Breakout.Court,  this, cfg.court);
      this.paddle  = Object.construct(Breakout.Paddle, this, cfg.paddle);
      this.ball    = Object.construct(Breakout.Ball,   this, cfg.ball);
      this.score   = Object.construct(Breakout.Score,  this, cfg.score);
      // Game.loadSounds({sounds: cfg.sounds});
    },

    onstartup: function() { // the event that fires the initial state transition occurs when Game.Runner constructs our StateMachine
      this.addEvents();
      this.runner.start(); // start the 60fps update/draw game loop
    },

    addEvents: function() {
      Game.addEvent('prev',  'click',  this.prevLevel.bind(this, false));
      Game.addEvent('next',  'click',  this.nextLevel.bind(this, false));
      Game.addEvent('sound', 'change', this.toggleSound.bind(this, false));

      Game.addEvent('instructions',     'touchstart', this.play.bind(this));
      Game.addEvent(this.runner.canvas, 'touchmove',  this.ontouchmove.bind(this));
      Game.addEvent(document.body,      'touchmove',  function(event) { event.preventDefault(); }); // prevent ipad bouncing up and down when finger scrolled
    },

    toggleSound: function() {
      this.storage.sound = this.sound = !this.sound;
    },

    update: function(dt) {
      this.court.update(dt);
      this.paddle.update(dt);
      this.ball.update(dt);
      this.score.update(dt);
    },

    draw: function(ctx) {
      ctx.save();
      ctx.clearRect(0, 0, this.width, this.height);
      ctx.fillStyle = this.color.background;
      ctx.fillRect(0, 0, this.width, this.height);
      this.court.draw(ctx);
      this.paddle.draw(ctx);
      this.ball.draw(ctx);
      this.score.draw(ctx);
      ctx.restore();
    },

    onresize: function(width, height) {
      this.width  = width;
      this.height = height;
      this.court.resize();
      this.paddle.reset();
      this.ball.reset();
    },

    onmenu: function() {
      this.resetLevel();
      this.paddle.reset();
      this.ball.reset();
      this.refreshDOM();
    },

    ongame: function() {
      this.refreshDOM();
      this.score.reset();
      this.ball.reset({launch: true});
    },

    onlose: function() {
      // this.playSound('gameover');
    },

    onleavegame: function() {
      this.score.save();
      this.score.resetLives();
    },

    onbeforeabandon: function() {
      return this.runner.confirm("Abandon game?")
    },

    loseBall: function() {
      // this.playSound('loselife');
      if (this.score.loseLife())
        this.lose();
      else {
        this.ball.reset({launch: true});
      }
    },

    winLevel: function() {
      // this.playSound('levelup');
      this.score.gainLife();
      this.nextLevel(true);
      this.ball.reset({launch: true});
    },

    hitBrick: function(brick) {
      // this.playSound('brick');
      this.court.remove(brick);
      this.score.increase(brick.score);
      this.ball.speed += 10 * (1 - (this.ball.speed / this.ball.maxspeed)); // decay curve - speed increases less the faster the ball is (otherwise game becomes impossible)
      if (this.court.empty())
        this.winLevel();
    },

    resetLevel: function() { this.setLevel(); },
    setLevel: function(level) {
      level = (typeof level == 'undefined') ? (this.storage.level ? parseInt(this.storage.level) : 0) : level;
      level = level < Breakout.Levels.length ? level : 0;
      this.court.reset(level);
      this.storage.level = this.level = level;
      this.refreshDOM();
    },

    canPrevLevel: function()      { return this.is('menu') && (this.level > 0);                          },
    canNextLevel: function()      { return this.is('menu') && (this.level < (Breakout.Levels.length-1)); },
    prevLevel:    function(force) { if (force || this.canPrevLevel()) this.setLevel(this.level - 1);     },
    nextLevel:    function(force) { if (force || this.canNextLevel()) this.setLevel(this.level + 1);     },

    initCanvas: function(ctx) { // called by Game.Runner whenever the canvas is reset (on init and on resize)
      ctx.fillStyle    = this.color.foreground;
      ctx.strokeStyle  = this.color.foreground;
      ctx.lineWidth    = 1;
      this.score.measure(ctx);  // score needs to measure itself
    },

    refreshDOM: function() {
      $('instructions').className = Game.ua.hasTouch ? 'touch' : 'keyboard';
      $('instructions').showIf(this.is('menu'));
      $('prev').toggleClassName('disabled', !this.canPrevLevel());
      $('next').toggleClassName('disabled', !this.canNextLevel());
      $('level').update(this.level + 1);
      $('sound').checked = this.sound;
    },

    /*   playSound: function(id) {
      if (soundManager && this.sound) {
        soundManager.play(id);
      }
    }, */

    ontouchmove: function(ev) {
      if (ev.targetTouches.length == 1) {
        this.paddle.place(ev.targetTouches[0].pageX - this.runner.bounds.left - this.paddle.w/2); // clientX only works in ios, not on android - must use pageX - yuck
      }
    },

    //=============================================================================



    Score: {

      initialize: function(game, cfg) {
        this.game = game;
        this.cfg  = cfg;
        this.load();
        this.reset();
      },

      reset:    function()  { this.set(0); this.resetLives(); },
      set:      function(n) { this.score = this.vscore = n; this.rerender = true; },
      increase: function(n) { this.score = this.score + n;  this.rerender = true; },
      format:   function(n) { return ("0000000" + n).slice(-7); },
      load:     function()  { this.highscore = this.game.storage.highscore ? parseInt(this.game.storage.highscore) : 1000; },
      save:     function()  { if (this.score > this.highscore) this.game.storage.highscore = this.highscore = this.score;  },

      resetLives: function()  { this.setLives(this.cfg.lives.initial);                       }, 
      setLives:   function(n) { this.lives = n; this.rerender = true;                        },
      gainLife:   function()  { this.setLives(Math.min(this.cfg.lives.max, this.lives + 1)); },
      loseLife:   function()  { this.setLives(this.lives-1); return (this.lives == 0);       },

      update: function(dt) {
        if (this.vscore < this.score) {
          this.vscore = Math.min(this.score, this.vscore + 10);
          this.rerender = true;
        }
      },

      measure: function(ctx) {
        this.left   = this.game.court.left;
        this.top    = this.game.court.top - this.game.court.wall.size*2;
        this.width  = this.game.court.width;
        this.height = this.game.court.wall.size*2;
        this.scorefont = "bold " + Math.max(9, this.game.court.wall.size - 2) + "pt arial";
        this.highfont  = ""      + Math.max(9, this.game.court.wall.size - 8) + "pt arial";
        ctx.save();
        ctx.font = this.scorefont;
        this.scorewidth = ctx.measureText(this.format(0)).width;
        ctx.font = this.highfont;
        this.highwidth  = ctx.measureText("HIGH SCORE: " + this.format(0)).width;
        ctx.restore();
        this.rerender = true;
      },

      draw: function(ctx) {
        if (this.rerender) {
          this.canvas = Game.renderToCanvas(this.width, this.height, this.render.bind(this), this.canvas);
          this.rerender = false;
        }
        ctx.drawImage(this.canvas, this.left, this.top);
      },

      render: function(ctx) {
        var text, width, paddle;
        var ishigh = this.game.is('game') && (this.score > this.highscore);

        ctx.textBaseline = "middle";
        ctx.fillStyle    = this.game.color.score;
        ctx.font         = this.scorefont;
        text             = this.format(this.vscore);
        ctx.fillText(text, 0, this.height/2);

        ctx.fillStyle = ishigh ? this.game.color.score : this.game.color.highscore;
        text          = "HIGH SCORE: " + this.format(ishigh ? this.score : this.highscore);
        ctx.font      = this.highfont;
        width         = ctx.measureText(text).width;
        ctx.fillText(text, this.width - width, this.height/2);

        paddle = {
          game: this.game,
          w:    this.game.court.chunk * 1.5,
          h:    this.game.court.chunk * 2/3
        }
        ctx.translate(this.scorewidth + 20, (this.height-paddle.h) / 2);
        for(var n = 0 ; n < this.lives ; n++) {
          this.game.paddle.render.call(paddle, ctx);
          ctx.translate(paddle.w + 5, 0);
        }

      }

    },

    //=============================================================================

    Court: {

      initialize: function(game, cfg) {
        this.game = game;
        this.cfg  = cfg;
      },
      
      reset: function(level) {
        var layout = Breakout.Levels[level];
        var line, brick, score, c, n, x, y, nx, ny = Math.min(layout.bricks.length, this.cfg.ychunks);
        this.bricks = [];
        for(y = 0 ; y < ny ; y++) {
          score = (this.cfg.ychunks - y) * 5;
          line  = layout.bricks[y] + " "; // extra space simplifies loop
          brick = null;
          nx = Math.min(line.length, this.cfg.xchunks + 1);
          for(x = 0 ; x < nx ; x++) {
            c = line[x];
            if (brick && (brick.c == c)) {
              brick.pos.x2 = x;
            }
            else if (brick && (brick.c != c)) {
              this.bricks.push(brick);
              brick = null;
            }

            if (!brick && (c != ' '))
              brick = { isbrick: true, hit: false, c: c, pos: { x1: x, x2: x, y: y }, score: score, color: layout.colors[c.toLowerCase()] };
          }
        }
        this.numbricks = this.bricks.length;
        this.numhits   = 0;
        this.resize();
      },

      resize: function() {

        this.chunk  = Math.floor(Math.min(this.game.width, this.game.height) / (Math.max(this.cfg.xchunks, this.cfg.ychunks) + 4)); // room for court plus 2 chunk wall either side
        this.width  = this.cfg.xchunks * this.chunk;
        this.height = this.cfg.ychunks * this.chunk;
        this.left   = Math.floor((this.game.width  - this.width)  / 2);
        this.top    = Math.floor((this.game.height - this.height) / 2);
        this.right  = this.left + this.width;
        this.bottom = this.top  + this.height;

        this.wall = {}
        this.wall.size  = this.chunk;
        this.wall.top   = Game.Math.bound({x: this.left - this.wall.size, y: this.top - this.wall.size*2, w: this.width + this.wall.size*2, h: this.wall.size*2               });
        this.wall.left  = Game.Math.bound({x: this.left - this.wall.size, y: this.top - this.wall.size*2, w: this.wall.size,                h: this.wall.size*2 + this.height });
        this.wall.right = Game.Math.bound({x: this.right,                 y: this.top - this.wall.size*2, w: this.wall.size,                h: this.wall.size*2 + this.height });

        for(n = 0 ; n < this.numbricks ; n++) {
          brick = this.bricks[n];
          brick.x = this.left + (brick.pos.x1 * this.chunk);
          brick.y = this.top  + (brick.pos.y  * this.chunk);
          brick.w = (brick.pos.x2 - brick.pos.x1 + 1) * this.chunk;
          brick.h = this.chunk;
          Game.Math.bound(brick);
        }

        this.rerender = true;
      },

      update: function(dt) {
      },

      draw: function(ctx) {
        if (this.rerender) {
          this.canvas = Game.renderToCanvas(this.game.width, this.game.height, this.render.bind(this), this.canvas);
          this.rerender = false;
        }
        ctx.drawImage(this.canvas, 0, 0);
      },

      render: function(ctx) {
        var n, brick;

        ctx.translate(0.5, 0.5); // crisp 1px lines for the brick borders
        ctx.strokeStyle = this.game.color.border;
        ctx.lineWidth = 1;
        for(n = 0 ; n < this.numbricks ; n++) {
          brick = this.bricks[n];
          if (!brick.hit) {
            ctx.fillStyle = brick.color;
            ctx.fillRect(brick.x, brick.y, brick.w, brick.h); 
            ctx.strokeRect(brick.x, brick.y, brick.w, brick.h);
          }
        }

        ctx.fillStyle = this.game.color.wall;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.wall.top.left,     this.wall.top.top);
        ctx.lineTo(this.wall.top.right,    this.wall.top.top);
        ctx.lineTo(this.wall.top.right,    this.wall.right.bottom);
        ctx.lineTo(this.wall.right.left,   this.wall.right.bottom);
        ctx.lineTo(this.wall.right.left,   this.wall.top.bottom);
        ctx.lineTo(this.wall.left.right,   this.wall.top.bottom);
        ctx.lineTo(this.wall.left.right,   this.wall.left.bottom);
        ctx.lineTo(this.wall.left.left,    this.wall.left.bottom);
        ctx.lineTo(this.wall.top.left,     this.wall.top.top);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();
      },

      remove: function(brick) {
        brick.hit = true;
        this.numhits++;
        this.rerender = true;
      },

      empty: function() {
        return (this.numhits == this.numbricks);
      }

    },

    //=============================================================================

    Ball: {

      initialize: function(game, cfg) {
        this.game = game;
        this.cfg  = cfg;
      },

      reset: function(options) {
        this.radius   = this.cfg.radius * this.game.court.chunk;
        this.speed    = this.cfg.speed  * this.game.court.chunk;
        this.maxspeed = this.speed * 1.5;
        this.color    = this.game.color.ball;
        this.moveToPaddle();
        this.setdir(0, 0);
        this.clearLaunch();
        this.hitTargets = [
          this.game.paddle,
          this.game.court.wall.top,
          this.game.court.wall.left,
          this.game.court.wall.right,
        ].concat(this.game.court.bricks);
        if (options && options.launch)
          this.launch();
      },

      moveToPaddle: function() {
        this.setpos(this.game.paddle.left + (this.game.paddle.w/2), this.game.court.bottom - this.game.paddle.h - this.radius);
      },

      setpos: function(x, y) {
        this.x = x;
        this.y = y;
        Game.Math.bound(this);
      },

      setdir: function(dx, dy) {
        var dir = Game.Math.normalize({ x: dx, y: dy });
        this.dx = dir.x;
        this.dy = dir.y;
        this.moving = dir.m != 0;
      },

      launch: function() {
        if (!this.moving || this.countdown) {
          this.countdown = (typeof this.countdown == 'undefined') || (this.countdown == null) ? 3 : this.countdown - 1;
          if (this.countdown > 0) {
            this.label = this.launchLabel(this.countdown);
            this.delayTimer = setTimeout(this.launch.bind(this), 1000);
            if (this.countdown == 1)
              this.setdir(1, -1); // launch on 'go'
          }
          else {
            this.clearLaunch();
          }
        }
      },

      launchNow: function() { // <space> key can override countdown launch
        if (!this.moving) {
          this.clearLaunch();
          this.setdir(1, -1);
        }
      },

      launchLabel: function(count) {
        var label       = this.cfg.labels[count];
        var ctx         = this.game.runner.front2d; // dodgy getting the context this way, should probably have a Game.Runner.ctx() method ?
        ctx.save();
        ctx.font        = label.font;
        ctx.fillStyle   = label.fill;
        ctx.strokeStyle = label.stroke;
        ctx.lineWidth   = 0.5;
        var width       = ctx.measureText(label.text).width;
        ctx.restore();
        label.x         = this.game.court.left +   (this.game.court.width - width)/2;
        label.y         = this.game.paddle.top - 60;
        return label;
      },

      clearLaunch: function() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = this.label = this.countdown = null;
        }
      },

      update: function(dt) {

        if (!this.moving)
          return this.moveToPaddle();

        var p2 = Game.Math.move(this.x, this.y, this.dx * this.speed, this.dy * this.speed, dt);

        var mCurrent, mClosest = Infinity, point, item, closest = null;
        for (var n = 0 ; n < this.hitTargets.length ; n++) {
          item = this.hitTargets[n];
          if (!item.hit) {
            point = Game.Math.ballIntercept(this, item, p2.nx, p2.ny);
            if (point) {
              mCurrent = Game.Math.magnitude(point.x - this.x, point.y - this.y);
              if (mCurrent < mClosest) {
                mClosest = mCurrent;
                closest = {item: item, point: point};
              }
            }
          }
        }

        if (closest) {

          if (closest.item.isbrick) {
            this.game.hitBrick(closest.item);
            if (!this.moving) // if hitBrick caused game to end we dont want to continue updating our state
              return;
          }

          if ((closest.item == this.game.paddle) && (closest.point.d == 'top')) {
            p2.dx = this.speed * (closest.point.x - (this.game.paddle.left + this.game.paddle.w/2)) / (this.game.paddle.w/2);
            // this.game.playSound('paddle');
          }

          this.setpos(closest.point.x, closest.point.y);

          switch(closest.point.d) {
            case 'left':
            case 'right':
              this.setdir(-p2.dx, p2.dy);
              break;

            case 'top':
            case 'bottom':
              this.setdir(p2.dx, -p2.dy);
              break;
          }

          var udt = dt * (mClosest / Game.Math.magnitude(p2.nx, p2.ny)); // how far along did we get before intercept ?
          return this.update(dt - udt);                                  // so we can update for time remaining
        }

        if ((p2.x < 0) || (p2.y < 0) || (p2.x > this.game.width) || (p2.y > this.game.height)) {
          this.game.loseBall();
        }
        else {
          this.setpos(p2.x,  p2.y);
          this.setdir(p2.dx, p2.dy);
        }

      },

      draw: function(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Game.THREESIXTY, true);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();

        if (this.label) {
          ctx.font = this.label.font;
          ctx.fillStyle = this.label.fill;
          ctx.strokeStyle = this.label.stroke;
          ctx.lineWidth = 0.5;
          ctx.fillText(this.label.text,   this.label.x, this.label.y);
          ctx.strokeText(this.label.text, this.label.x, this.label.y);
        }
      }

    },

    //=============================================================================

    Paddle: {
      initialize: function(game, cfg) {
        this.game = game;
        this.cfg  = cfg;
      },

      reset: function() {
        this.speed  = this.cfg.speed  * this.game.court.chunk;
        this.w      = this.cfg.width  * this.game.court.chunk;
        this.h      = this.cfg.height * this.game.court.chunk;
        this.minX   = this.game.court.left;
        this.maxX   = this.game.court.right - this.w;
        this.setpos(Game.random(this.minX, this.maxX), this.game.court.bottom - this.h);
        this.setdir(0);
        this.rerender = true;
      },

      setpos: function(x, y) {
        this.x      = x;
        this.y      = y;
        Game.Math.bound(this);
      },

      setdir: function(dx) {
        this.dleft  = (dx < 0 ? -dx : 0);
        this.dright = (dx > 0 ?  dx : 0);
      },

      place: function(x) {
        this.setpos(Math.min(this.maxX, Math.max(this.minX, x)), this.y);
      },

      update: function(dt) {
        var amount = this.dright - this.dleft;
        if (amount != 0)
          this.place(this.x + (amount * dt * this.speed));
      },

      draw: function(ctx) {
        if (this.rerender) {
          this.canvas = Game.renderToCanvas(this.w, this.h, this.render.bind(this));
          this.rerender = false;
        }
        ctx.drawImage(this.canvas, this.x, this.y);
      },

      render: function(ctx) {

        var gradient = ctx.createLinearGradient(0, this.h, 0, 0);
        gradient.addColorStop(0.36, 'rgb(245,111,37)');
        gradient.addColorStop(0.68, 'rgb(255,145,63)');
        gradient.addColorStop(0.84, 'rgb(255,174,95)');

        var r = this.h/2;

        ctx.fillStyle = gradient;
        ctx.strokeStyle = this.game.color.border;
        ctx.beginPath();
        ctx.moveTo(r,  0);
        ctx.lineTo(this.w - r, 0);
        ctx.arcTo(this.w, 0, this.w, r, r);
        ctx.lineTo(this.w, this.h - r);
        ctx.arcTo(this.w, this.h, this.w - r, this.h, r);
        ctx.lineTo(r, this.h);
        ctx.arcTo(0, this.h, 0, this.h - r, r);
        ctx.lineTo(0, r);
        ctx.arcTo(0, 0, r, 0, r);
        ctx.fill();
        ctx.stroke();
        ctx.closePath();

      },

      moveLeft:        function() { this.dleft  = 1; },
      moveRight:       function() { this.dright = 1; },  
      stopMovingLeft:  function() { this.dleft  = 0; },
      stopMovingRight: function() { this.dright = 0; }

    }

    //=============================================================================

    }; // Breakout

    Breakout.Colors = {

    arkanoid: {
      w: "#FCFCFC", // white
      o: "#FC7460", // orange
      l: "#3CBCFC", // light blue
      g: "#80D010", // green
      r: "#D82800", // red
      b: "#0070EC", // blue
      p: "#FC74B4", // pink
      y: "#FC9838", // yellow
      s: "#BCBCBC", // silver
      d: "#F0BC3C"  // gold
    },

    pastel: {
      y: "#FFF7A5", // yellow
      p: "#FFA5E0", // pink
      b: "#A5B3FF", // blue
      g: "#BFFFA5", // green
      o: "#FFCBA5"  // orange
    },

    vintage: {
      a: "#EFD279", // yellow
      b: "#95CBE9", // light blue
      c: "#024769", // dark blue
      d: "#AFD775", // light green
      e: "#2C5700", // grass
      f: "#DE9D7F", // red
      g: "#7F9DDE", // purple
      h: "#00572C", // dark green
      i: "#75D7AF", // mint
      j: "#694702", // brown
      k: "#E9CB95", // peach
      l: "#79D2EF"  // blue
    },

    liquidplanner: {
      a: '#62C4E7', // light blue
      b: '#00A5DE', // dark  blue
      x: '#969699', // light gray
      y: '#7B797E'  // dark  gray
    },


    };

    Breakout.Levels = [

    { colors: Breakout.Colors.pastel,
      bricks: [
        "", "", "", "", "", "",
        "yyyyyYYYYYyyyyyYYYYYyyyyyYYYYY",
        "pppppPPPPPpppppPPPPPpppppPPPPP",
        "bbbbbBBBBBbbbbbBBBBBbbbbbBBBBB",
        "gggggGGGGGgggggGGGGGgggggGGGGG",
        "oooooOOOOOoooooOOOOOoooooOOOOO"
      ]
    },

    { colors: Breakout.Colors.arkanoid,
      bricks: [
        "", "",
        "          yy      yy          ",
        "            yy  yy            ",
        "            yy  yy            ", 
        "          ssSSssSSss          ",
        "          ssSSssSSss          ",
        "        SSsswwsswwssSS        ",
        "        SSsswwsswwssSS        ",
        "      ssSSssSSssSSssSSss      ",
        "      ssSSssSSssSSssSSss      ",
        "      ss  ssSSssSSss  ss      ",
        "      ss  ss      ss  ss      ",
        "      ss  ss      ss  ss      ",
        "            ss  ss            ",
        "            ss  ss            ",
      ]
    },

    { colors: Breakout.Colors.arkanoid,
      bricks: [
        "",
        "oo",
        "ooll",
        "oollgg",
        "oollggbb",
        "oollggbbrr",
        "oollggbbrroo",
        "oollggbbrrooll",
        "oollggbbrroollgg",
        "oollggbbrroollggbb",
        "oollggbbrroollggbbrr",
        "oollggbbrroollggbbrroo",
        "oollggbbrroollggbbrrooll",
        "oollggbbrroollggbbrroollgg",
        "oollggbbrroollggbbrroollggbb",
        "ssSSssSSssSSssSSssSSssSSssSSrr"
      ]
    },

    { colors: Breakout.Colors.arkanoid,
      bricks: [
        "", "",
        "              ss              ",
        "          bbBBssggGG          ",
        "        BBbbWWwwWWGGgg        ",
        "      bbBBwwWWwwWWwwggGG      ",
        "      bbBBwwWWwwWWwwggGG      ",
        "      bbBBwwWWwwWWwwggGG      ",
        "      ss  ss  ss  ss  ss      ",
        "              ss              ",
        "              ss              ",
        "          oo  oo              ",
        "          ooOOoo              ",
        "            OO                "
      ]
    },

    { colors: Breakout.Colors.pastel,
      bricks: [
        "", "",
        "  yyYYyyYYyyYY  YYyyYYyyYYyy  ",
        "  bbBBbbBBbbBB  BBbbBBbbBBbb  ",
        "  ggGGggGGggGG  GGggGGggGGgg  ",
        "  ooOOooOOooOO  OOooOOooOOoo  ",
        "", "",
        "  yyYYyyYYyyYY  YYyyYYyyYYyy  ",
        "  bbBBbbBBbbBB  BBbbBBbbBBbb  ",
        "  ggGGggGGggGG  GGggGGggGGgg  ",
        "  ooOOooOOooOO  OOooOOooOOoo  ",
        "", "",
        "  yyYYyyYYyyYY  YYyyYYyyYYyy  ",
        "  bbBBbbBBbbBB  BBbbBBbbBBbb  ",
        "  ggGGggGGggGG  GGggGGggGGgg  ",
        "  ooOOooOOooOO  OOooOOooOOoo  "
      ]
    },

    { colors: Breakout.Colors.vintage,
      bricks: [
        "", "", "",
        "   AAaaAAaaAAaaAAaaAAaaAAaa   ",
        "    BBbbBBbbBBbbBBbbBBbbBB    ",
        "     CCccCCccCCccCCccCCcc     ",
        "      DDddDDddDDddDDddDD      ",
        "       EEeeEEeeEEeeEEee       ",
        "        FFffFFffFFffFF        ",
        "         GGggGGggGGgg         ",
        "          HHhhHHhhHH          ",
        "           IIiiIIii           ",
        "            JJjjJJ            ",
        "             KKkk             ",
        "              LL              "
      ]
    },

    { colors: Breakout.Colors.vintage,
      bricks: [
        "", "",
        "  aabbccddeeffggFFEEDDCCBBAA  ",
        "   aabbccddeeffFFEEDDCCBBAA   ",
        "    aabbccddeeffEEDDCCBBAA    ",
        "     aabbccddeeEEDDCCBBAA     ",
        "      aabbccddeeDDCCBBAA      ",
        "       aabbccddDDCCBBAA       ",
        "        aabbccddCCBBAA        ",
        "         aabbccCCBBAA         ",
        "          aabbccBBAA          ",
        "      hh   aabbCCAA   hh      ",
        "     hhHH   aabbAA   hhHH     ",
        "    hhiiHH   aaAA   hhiiHH    ",
        "   hhiiIIHH   aa   hhiiIIHH   ",
        "  hhiijjIIHH      hhiijjIIHH  ",
        " hhiijjJJIIHH    hhiijjJJIIHH "
      ]
    },
    

    { colors: Breakout.Colors.pastel,
      bricks: [
        "                              ",
        "                              ",
        "  bbBBbbBBbbBBbbBBbbBBbbBBbb  ",
        "  ooggGGggGGggGGggGGggGGggoo  ",
        "  ooggGGggGGggGGggGGggGGggoo  ",
        "  ooppPPppPPppPPppPPppPPppoo  ",
        "  ooppPPppPPppBBppPPppPPppoo  ",
        "  ooppPPppPPbbBBbbPPppPPppoo  ",
        "  ooppPPppBBbbOObbBBppPPppoo  ",
        "  ooppPPbbBBooOOooBBbbPPppoo  ",
        "  ooppBBbbOOooYYooOObbBBppoo  ",
        "  oobbBBOOooyyYYyyooOOBBbboo  ",
        "  oobbooOOYYyyYYyyYYOOoobboo  ",
        "  ooOOooyyYYyyYYyyYYyyooOOoo  ",
        "  ooOOYYyyYYyyYYyyYYyyYYOOoo  ",
        "  ooyyYYyyYYyyYYyyYYyyYYyyoo  ",
        "  ooyyYYyyYYyyYYyyYYyyYYyyoo  ",
        "  bbBBbbBBbbBBbbBBbbBBbbBBbb  "
      ]
    },

    { colors: {
        b: '#111111', // black,
        w: '#EEEEEE', // white,
        c: '#EC7150', // cherry,
        s: '#B33A2F'  // shadow,
      },

      bricks: [
        "",
        "       bBb                    ",
        "      BcCcB                   ",
        "     bCwCcsb  b               ",
        "     bCcCcsb b                ",
        "      BcCsB B                 ",
        "    BbBsSsBbB       bBb       ",
        "   bcCcbBbcCcb     BcCcB      ",
        "  bcwcCsbcwcCsb   bCwCcsb  b  ",
        "  bcCcCsbcCcCsb   bCcCcsb b   ",
        "  bcCcsSbcCcsSb    BcCsB B    ",
        "   bsSsb bsSsb   BbBsSsBbB    ",
        "    bBb   bBb   bcCcbBbcCcb   ",
        "               bcwcCsbcwcCsb  ",
        "               bcCcCsbcCcCsb  ",
        "               bcCcsSbcCcsSb  ",
        "                bsSsb bsSsb   ",
        "                 bBb   bBb    ",
        "                              ",
        "                              ",
        "                              ",
        "                              ",
      ]
    },

    { colors: {
        r: '#D80000', // red
        b: '#706800', // brown
        o: '#F8AB00', // orange
        f: '#F83800', // fire
        w: '#FFFFFF', // white
        e: '#FFE0A8'  // beige
      },

      bricks: [
        "",
        "    rRrRr                     ",
        "   RrRrRrRrR                  ",
        "   BbBoObo                    ",
        "  boboOoboOo       F    f   f ",
        "  bobBoOoboOo     f e         ",
        "  bBoOoObBbB       F  f     e ",
        "    oOoOoOo        Ff      E  ",
        "   bBrbBb        E  f fF F  f ",
        "  bBbrbBrbBb       FfFfFf  F  ",
        " bBbBrRrRbBbB     fFeFeFfFf   ",
        " oObrorRorboO    FfEeEeEfF    ",
        " oOorRrRrRoOo    FeEeWwEeFf   ",
        " oOrRrRrRrRoO   fFeFwWfEeFf   ",
        "   rRr  RrR     fFeFwWfEeFf   ",
        "  bBb    bBb    fFeEwWeEeFf   ",
        " bBbB    bBbB   fFfEeEeEfF    ",
        "                 FfFfFfFfF    ",
        "                   FfFfF      "
      ]
    },

    { colors: {
        r: '#D80000', // red
        b: '#706800', // brown
        o: '#F8AB00', // orange
        f: '#F83800', // fire
        w: '#FFFFFF', // white
        e: '#FFE0A8'  // beige
      },

      bricks: [
        "",
        "                b             ",
        "               b              ",
        "              b               ",
        "          rrrbbbrrr           ",
        "         rRrRrRrRrRr          ",
        "        rRrRrRrRrRrRr         ",
        "       rRrRrRrRrRrRrRr        ",
        "       RrRrRrRrRrRrRrR        ",
        "       rRrRrRrRrRrRrRr        ",
        "       RrRrRrRrRrRrRrR        ",
        "       rRrRrRrRrRrRrRr        ",
        "         RrRrRrRrRrR          ",
        "           rr  rr             ",
        "                              ",
        "                              ",
        "                              ",
        "                              ",
        "                              ",
      ]
    },
    ];
    Game.start('canvas', Breakout);
    })
 
        document.querySelector('#tetris').addEventListener('click', () => {
            document.querySelector('#startScreen').style.display = 'none'
            var config = {
            game: {
                board: {
                rows: 23,
                cols: 10
                },
                keys: {
                moveLeft:   37,
                moveRight:  39,
                moveDown:   40,
                rotate:     38,
                drop:       32,
                pause:      27,
                continue:   32,
                savedPiece: 83,
                }
            },
            canvas: {
                id: 'canvas',
                width: 480,
                height: 770,
                board: {
                left: 1,
                top: 1,
                border: {
                    width: 1,
                    color: 'black'
                }
                },
                cell: {
                width: 33,
                height: 33,
                border: {
                    width: 3,
                    color: 'black'
                },
                colors: [
                    'gray',       // empty
                    '#cceeff',    // O
                    '#ff6666',    // I
                    '#99ff99',    // S
                    '#ffcc66',    // Z
                    '#ff99ff',    // L
                    '#ccff99',    // J
                    '#cc99ff',    // T
                    '#aaa',       // shadow
                ]
                },
                nextPiece: {
                left: 340,
                top:  50,
                border: {
                    width: 1,
                    color: 'black'
                }
                },
                savedPiece: {
                left: 340,
                top:  450,
                border: {
                    width: 1,
                    color: 'black'
                }
                },
                score: {
                left: 350,
                top: 250,
                font: {
                    family: '28px SuperMario',
                    color: 'white'
                }
                },
                alert: {
                left: 350,
                top: 350,
                font: {
                    family: '28px SuperMario',
                    color: 'white'
                }
                }
            }
            };

            const EMPTY   = 0;
            const O       = 1;
            const I       = 2;
            const S       = 3;
            const Z       = 4;
            const L       = 5;
            const J       = 6;
            const T       = 7;
            const SHADOW  = 8;
            const PIVOT   = 1;

            let switchPieces = 'false'
            var shapes = [];

            shapes[O] = [
            { x: - 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: - 1, y: + 1 },
            { x: + 0, y: + 1 }
            ];

            shapes[I] =  [
            { x: - 2, y: + 0 },
            { x: + 0, y: + 0 },
            { x: - 1, y: + 0 },
            { x: + 1, y: + 0 }
            ];

            shapes[S] = [
            { x: + 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: + 0, y: + 1 },
            { x: - 1, y: + 1 }
            ];

            shapes[Z] = [
            { x: - 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: + 0, y: + 1 },
            { x: + 1, y: + 1 }
            ];

            shapes[L] = [
            { x: - 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: + 1, y: + 0 },
            { x: - 1, y: + 1 }
            ];

            shapes[J] = [
            { x: - 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: + 1, y: + 0 },
            { x: + 1, y: + 1 }
            ];

            shapes[T] = [
            { x: - 1, y: + 0 },
            { x: + 0, y: + 0 },
            { x: + 1, y: + 0 },
            { x: + 0, y: + 1 }
            ];

            function Timer() {
            this.timer = undefined;
            }

            Timer.prototype = {

            start: function(handler,level) {
                var timeLapse = 800 - (level * 200);

                this.timer = setTimeout(handler,timeLapse);
            },

            clear: function() {
                clearTimeout(this.timer);
            }

            };

            function GameState() {
            this.value = null;
            }

            function Board(rows, cols) {
            var i;

            this.cells = [];
            while (this.getHeight() < rows) {
                this.cells.push([]);
                i = this.cells.length - 1;
                while (this.getWidth(i) < cols) {
                this.cells[i].push(null);
                }
            }
            }

            Board.prototype = {

            getHeight: function() {
                return this.cells.length;
            },

            getWidth: function(row) {
                return this.cells[row].length;
            },

            clear: function() {
                var self = this;

                self.cells.forEach(function(row, i) {
                row.forEach(function(cell, j) {
                    self.cells[i][j] = EMPTY;
                });
                });
            },

            insertPiece: function(piece) {
                var self = this;

                piece.blocks.forEach(function(block) {
                self.cells[block.y][block.x] = piece.shape;
                });
            },

            outOfTheBox: function(row, col) {
                return (row < 0 || row >= this.getHeight() || col < 0 || col >= this.getWidth(row));
            },

            isRowFilled: function(row) {
                var i = 0;

                while (i < this.getWidth(row)) {
                if (this.cells[row][i] == EMPTY) {
                    return false;
                }
                i++;
                }
                return true;
            },

            countFilledRows: function() {
                var self = this,
                    numFilledRows = 0;

                self.cells.forEach(function(row, i) {
                if (self.isRowFilled(i)) {
                    numFilledRows++;
                }
                });
                return numFilledRows;
            },

            clearFilledRows: function() {
                var i, j, k, self = this;

                self.cells.forEach(function(row, i) {
                if (self.isRowFilled(i)) {
                    for (j = i; j >= 0; j--) {
                    for (k = 0; k < self.getWidth(i); k++) {
                        if (j > 0) {
                        self.cells[j][k] = self.cells[j-1][k];
                        } else {
                        self.cells[j][k] = EMPTY;
                        }
                    }
                    }
                }
                });
            }

            };

            function Piece(board) {
            this.board = board;
            this.shape = null;
            this.blocks = [];
            }

            Piece.prototype = {

            clone: function() {
                var clone = new Piece(this.board);

                clone.shape = this.shape;
                clone.blocks = this.blocks.map(function(block) {
                return { x: block.x, y: block.y }
                });
                return clone;
            },

            new: function(shape = undefined) {
                var self = this,
                    pivot = {
                    x: parseInt(this.board.getWidth(0) / 2),
                    y: 2
                    };

                if (shape == undefined) {
                this.shape = Math.floor(Math.random() * 7) + 1;
                } else {
                this.shape = shape;
                }
                this.blocks = [];
                shapes[this.shape].forEach(function(relative) {
                self.blocks.push({
                    x: pivot.x + relative.x,
                    y: pivot.y + relative.y
                });
                });
            },

            collides: function() {
                var x, y, i = 0;

                while (i < this.blocks.length) {
                x = this.blocks[i].x;
                y = this.blocks[i].y;
                if (this.board.outOfTheBox(y,x) || this.board.cells[y][x] != EMPTY) {
                    return true;
                }
                i++;
                }
                return false;
            },

            endFall: function() {
                var x, y, i = 0;

                while (i < this.blocks.length) {
                x = this.blocks[i].x;
                y = this.blocks[i].y + 1;
                if (this.board.outOfTheBox(y,x) || this.board.cells[y][x] != EMPTY) {
                    return true;
                }
                i++;
                }
                return false;
            },

            moveLeft: function() {
                this.blocks.forEach(function(block) {
                block.x--;
                });
                if (this.collides()) {
                this.blocks.forEach(function(block) {
                    block.x++;
                })
                }
            },

            moveRight: function() {
                this.blocks.forEach(function(block) {
                block.x++;
                });
                if (this.collides()) {
                this.blocks.forEach(function(block) {
                    block.x--;
                })
                }
            },

            moveDown: function() {
                this.blocks.forEach(function(block) {
                block.y++;
                });
                if (this.collides()) {
                this.blocks.forEach(function(block) {
                    block.y--;
                })
                }
            },

            drop: function() {
                while (!this.endFall()) {
                this.moveDown();
                }
            },

            savedPiece: function() {
                console.log('call saved piece function')
            },

            rotate: function() {
                var aux = this.clone();

                if (this.shape == O) {
                return;
                }
                this.blocks.forEach(function(block, i) {
                block.x = aux.blocks[PIVOT].x + aux.blocks[PIVOT].y - aux.blocks[i].y;
                block.y = aux.blocks[i].x - aux.blocks[PIVOT].x + aux.blocks[PIVOT].y;
                });
                if (this.collides()) {
                this.blocks = aux.blocks;
                }
            }

            };

            function Score() {
            this.lines = null;
            this.level = null;
            };

            Score.prototype = {

            reset: function() {
                this.lines = 0;
                this.level = 1;
            },

            update: function(numFilledRows) {
                this.lines += numFilledRows;
                if (this.level < 9) {
                this.level = parseInt(this.lines / 20) + 1;
                }
            }

            };

            function Canvas(params) {
            this.config = params.config;
            this.canvas = document.querySelector("canvas");
            this.canvas.width = this.config.width;
            this.canvas.height = this.config.height;
            this.ctx = this.canvas.getContext('2d');


            this.bindings = params.bindings;
            this.ctx.translate(0.5, 0.5);
            }

            Canvas.prototype = {

            drawCell: function(left, top, color) {
                var width = this.config.cell.width,
                    height = this.config.cell.height;

                this.ctx.fillStyle = this.config.cell.colors[color];
                this.ctx.fillRect(left,top,width,height);
                if (color != SHADOW) {
                if (color == EMPTY) {
                    this.ctx.strokeStyle = this.config.cell.colors[EMPTY];
                } else {
                    this.ctx.strokeStyle = this.config.cell.border.color;
                }
                this.ctx.lineWidth = this.config.cell.border.width;
                this.ctx.strokeRect(left,top,width,height);
                }
            },

            drawBoard: function() {
                var self = this,
                    left = self.config.board.left,
                    top = self.config.board.top,
                    width = self.config.cell.width * self.bindings.board.getWidth(0),
                    height = self.config.cell.height * self.bindings.board.getHeight();

                self.ctx.lineWidth = self.config.cell.border.width;
                self.ctx.strokeStyle = self.config.cell.border.color;
                self.ctx.fillStyle = self.config.cell.colors[EMPTY];
                self.ctx.fillRect(left,top,width,height);
                self.ctx.strokeRect(left,top,width,height);
                self.bindings.board.cells.forEach(function(row, i) {
                row.forEach(function(cell, j) {
                    if (cell != EMPTY) {
                    left = self.config.board.left + self.config.cell.width * j,
                    top = self.config.board.top + self.config.cell.height * i;
                    self.drawCell(left,top,cell);
                    }
                });
                });
            },

            drawShadow: function() {
                var self = this,
                    left,
                    top,
                    shadow = self.bindings.piece.clone();

                shadow.drop();
                shadow.blocks.forEach(function(block) {
                left = self.config.board.left + self.config.cell.width * block.x;
                top = self.config.board.top + self.config.cell.height * block.y;
                self.drawCell(left,top,SHADOW);
                });
            },

            drawPiece: function() {
                var  self = this,
                    left,
                    top;

                self.drawShadow();
                self.bindings.piece.blocks.forEach(function(block) {
                left = self.config.board.left + self.config.cell.width * block.x;
                top = self.config.board.top + self.config.cell.height * block.y;
                self.drawCell(left,top,self.bindings.piece.shape);
                });
            },

            drawNextPiece: function() {
                var self = this,
                    left = self.config.nextPiece.left,
                    top = self.config.nextPiece.top,
                    width = self.config.cell.width * 4,
                    height = self.config.cell.height * 4,
                    pivot = { x: 2, y: 1 };

                self.ctx.lineWidth = self.config.cell.border.width;
                self.ctx.strokeStyle = self.config.cell.border.color;
                self.ctx.fillStyle = self.config.cell.colors[EMPTY];
                self.ctx.fillRect(left,top,width,height);
                self.ctx.strokeRect(left,top,width,height);
                shapes[self.bindings.nextPiece.shape].forEach(function(relative) {
                left = self.config.nextPiece.left + self.config.cell.width * (pivot.x + relative.x);
                top = self.config.nextPiece.top + self.config.cell.height * (pivot.y + relative.y);
                self.drawCell(left,top,self.bindings.nextPiece.shape);
                });
            },

            drawSavedPiece: function() {
                var self = this,
                    left = self.config.savedPiece.left,
                    top = self.config.savedPiece.top,
                    width = self.config.cell.width * 4,
                    height = self.config.cell.height * 4,
                    pivot = { x: 2, y: 1 };

                self.ctx.lineWidth = self.config.cell.border.width;
                self.ctx.strokeStyle = self.config.cell.border.color;
                self.ctx.fillStyle = self.config.cell.colors[EMPTY];
                self.ctx.fillRect(left,top,width,height);
                self.ctx.strokeRect(left,top,width,height);
                shapes[self.bindings.savedPiece.shape].forEach(function(relative) {
                left = self.config.savedPiece.left + self.config.cell.width * (pivot.x + relative.x);
                top = self.config.savedPiece.top + self.config.cell.height * (pivot.y + relative.y);
                self.drawCell(left,top,self.bindings.savedPiece.shape);
                });
            },

            drawScore: function() {
                var left = this.config.score.left,
                    top = this.config.score.top;

                this.ctx.fillStyle = this.config.score.font.color;
                this.ctx.font = this.config.score.font.family;
                this.ctx.fillText("Lines: " + this.bindings.score.lines,left+10,top);
                this.ctx.fillText("Level: " + this.bindings.score.level,left+10,top + 25);
                this.ctx.fillText("Saved Piece", left-10, canvas.height + top + 40);
                this.ctx.fillText("  (s to use)", left-10, canvas.height + top + 10);
            },

            drawAlert: function(message) {
                var left = this.config.alert.left,
                    top = this.config.alert.top;

                this.ctx.fillStyle = this.config.alert.font.color;
                this.ctx.font = this.config.alert.font.family;
                this.ctx.fillText(message,left,top);
            },

            clear: function() {
                var left = 0,
                    top = 0,
                    width = this.canvas.width,
                    height = this.canvas.height;

                this.ctx.clearRect(left,top,width,height);
            },

            render: function() {
                this.clear();
                this.drawBoard(this.bindings.board);
                this.drawPiece(this.bindings.piece);
                this.drawNextPiece(this.bindings.piece);
                this.drawSavedPiece(this.bindings.piece);
                this.drawScore(this.bindings.score);
                switch (this.bindings.gameState.value) {
                case 'playing':
                    // Do nothing...
                    break;
                case 'paused':
                    this.drawAlert('Game Paused');
                    break;
                case 'game-over':
                    this.drawAlert('Game Over');
                    break;
                }
            }

            };

            (function(config) {
            var board = new Board(config.game.board.rows,config.game.board.cols),
                piece = new Piece(board),
                nextPiece = new Piece(board),
                savedPiece = new Piece(board),
                score = new Score(),
                timer = new Timer(),
                gameState = new GameState(),
                canvas = new Canvas({
                    config: config.canvas,
                    bindings: {
                    board: board,
                    piece: piece,
                    nextPiece: nextPiece,
                    savedPiece: savedPiece,
                    score: score,
                    gameState: gameState
                    }
                });

            init();

            function init() {
                loadAssets().then(startGame);
                window.addEventListener('keydown', function(event) {
                onKeydown(event);
                });
            }

            function loadAssets() {
                return document.fonts.load('0pt SuperMario');
            }

            function pauseGame() {
                timer.clear();
                gameState.value = 'paused';
                canvas.render();
            }

            function reanudeGame() {
                timer.start(updateGame,score.level);
                gameState.value = 'playing';
                canvas.render();
            }

            function startGame() {
                board.clear();
                piece.new();
                nextPiece.new();
                savedPiece.new();
                score.reset();
                gameState.value = 'playing';
                canvas.render();
                timer.start(updateGame,score.level);
            }

            function finishGame() {
                timer.clear();
                gameState.value = 'game-over';
                canvas.render();
            }

            function updateGame() {
                if (piece.endFall()) {
                board.insertPiece(piece);
                if (board.countFilledRows() > 0) {
                    score.update(board.countFilledRows());
                    board.clearFilledRows();
                }
                piece.new(nextPiece.shape);
                nextPiece.new();
                if (piece.collides()) {
                    finishGame();
                }
                } else {
                piece.moveDown();
                }
                canvas.render();
                if (gameState.value == 'playing') {
                timer.start(updateGame,score.level);
                console.log(savedPiece)
                if (switchPieces =='true') {
                    var temp_shape = piece.shape
                    var temp_blocks = piece.blocks

                    piece.shape = savedPiece.shape
                    piece.blocks = savedPiece.blocks

                    savedPiece.shape = temp_shape
                    savedPiece.blocks = temp_blocks

                    switchPieces = 'false'
                }
                }
            }

            function onKeydown(event) {
                var key = event.keyCode;

                switch (gameState.value) {
                case 'playing':
                    switch (key) {
                    case config.game.keys.moveLeft:
                        piece.moveLeft();
                        break;
                    case config.game.keys.moveRight:
                        piece.moveRight();
                        break;
                    case config.game.keys.moveDown:
                        piece.moveDown();
                        break;
                    case config.game.keys.rotate:
                        piece.rotate();
                        break;
                    case config.game.keys.drop:
                        piece.drop();
                        break;
                    case config.game.keys.pause:
                        pauseGame();
                        break;
                    case config.game.keys.savedPiece:
                        piece.savedPiece();
                        switchPieces = 'true'
                        break;
                    }
                    break;
                case 'paused':
                    if (key == config.game.keys.continue) {
                    reanudeGame();
                    }
                    break;
                case 'game-over':
                    if (key == config.game.keys.continue) {
                    startGame();
                    }
                    break;
                }
                canvas.render();
            }
            })(config);
        })

         document.querySelector('#flappybird').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'
                const RAD = Math.PI/180;
                const scrn = document.getElementById('canvasFlappy');
                const sctx = scrn.getContext("2d");
                scrn.tabIndex = 1;
                scrn.addEventListener("click",()=>{
                    switch (state.curr) {
                        case state.getReady :
                            state.curr = state.Play;
                            SFX.start.play();
                            break;
                        case state.Play :
                            bird.flap();
                            break;
                        case state.gameOver :
                            state.curr = state.getReady;
                            bird.speed = 0;
                            bird.y = 100;
                            pipe.pipes=[];
                            UI.score.curr = 0;
                            SFX.played=false;
                            break;
                    }
                })

                scrn.onkeydown = function keyDown(e) {
                    if (e.keyCode == 32 || e.keyCode == 87 || e.keyCode == 38)   // Space Key or W key or arrow up
                    {
                        switch (state.curr) {
                            case state.getReady :
                                state.curr = state.Play;
                                SFX.start.play();
                                break;
                            case state.Play :
                                bird.flap();
                                break;
                            case state.gameOver :
                                state.curr = state.getReady;
                                bird.speed = 0;
                                bird.y = 100;
                                pipe.pipes=[];
                                UI.score.curr = 0;
                                SFX.played=false;
                                break;
                        }
                    }
                }

                let spawnRate = 160
                let gap = 110
                let frames = 0;
                let dx = 2;
                const state = {
                    curr : 0,
                    getReady : 0,
                    Play : 1,
                    gameOver : 2,

                }
                const SFX = {
                    start : new Audio(),
                    flap : new Audio(),
                    score : new Audio(),
                    hit : new Audio(),
                    die : new Audio(),
                    played : false
                }
                const gnd = {
                    sprite : new Image(),
                    x : 0,
                    y :0,
                    draw : function() {
                        this.y = parseFloat(scrn.height-this.sprite.height);
                        sctx.drawImage(this.sprite,this.x,this.y);
                    },
                    update : function() {
                        if(state.curr != state.Play) return;
                        this.x -= dx;
                        this.x = this.x % (this.sprite.width/2);    
                    }
                };
                const bg = {
                    sprite : new Image(),
                    x : 0,
                    y :0,
                    draw : function() {
                        y = parseFloat(scrn.height-this.sprite.height);
                        sctx.drawImage(this.sprite,this.x,y);
                    }
                };
                const pipe = {
                    top : {sprite : new Image()},
                    bot : {sprite : new Image()},
                    gap: gap,
                    moved: true,
                    pipes : [],
                    draw : function(){
                        for(let i = 0;i<this.pipes.length;i++)
                        {
                            let p = this.pipes[i];
                            sctx.drawImage(this.top.sprite,p.x,p.y)
                            sctx.drawImage(this.bot.sprite,p.x,p.y+parseFloat(this.top.sprite.height)+gap)
                        }
                    },
                    update : function(){
                        if(state.curr!=state.Play) return;
                        if(frames%spawnRate==0)
                        {
                            this.pipes.push({x:parseFloat(scrn.width),y:-210*Math.min(Math.random()+1,1.8)});
                        }
                        this.pipes.forEach(pipe=>{
                            pipe.x -= dx;
                        })

                        if(this.pipes.length&&this.pipes[0].x < -this.top.sprite.width)
                        {
                            this.pipes.shift();
                            this.moved = true;
                        }

                    }

                };
                const bird = {
                    animations :
                        [
                            {sprite : new Image()},
                            {sprite : new Image()},
                            {sprite : new Image()},
                            {sprite : new Image()},
                        ],
                    rotatation : 0,
                    x : 50,
                    y :100,
                    speed : 0,
                    gravity : .125,
                    thrust : 3.6,
                    frame:0,
                    draw : function() {
                        let h = this.animations[this.frame].sprite.height;
                        let w = this.animations[this.frame].sprite.width;
                        sctx.save();
                        sctx.translate(this.x,this.y);
                        sctx.rotate(this.rotatation*RAD);
                        sctx.drawImage(this.animations[this.frame].sprite,-w/2,-h/2);
                        sctx.restore();
                    },
                    update : function() {
                        let r = parseFloat( this.animations[0].sprite.width)/2;
                        switch (state.curr) {
                            case state.getReady :
                                this.rotatation = 0;
                                this.y +=(frames%10==0) ? Math.sin(frames*RAD) :0;
                                this.frame += (frames%10==0) ? 1 : 0;
                                break;
                            case state.Play :
                                this.frame += (frames%5==0) ? 1 : 0;
                                this.y += this.speed;
                                this.setRotation()
                                this.speed += this.gravity;
                                if(this.y + r  >= gnd.y||this.collisioned())
                                {
                                    state.curr = state.gameOver;
                                    // pipe.gap == 130
                                }
                                
                                break;
                            case state.gameOver : 
                                this.frame = 1;
                                if(this.y + r  < gnd.y) {
                                    this.y += this.speed;
                                    this.setRotation()
                                    this.speed += this.gravity*2;
                                }
                                else {
                                this.speed = 0;
                                this.y=gnd.y-r;
                                this.rotatation=90;
                                if(!SFX.played) {
                                    SFX.die.play();
                                    SFX.played = true;
                                }
                                }
                                
                                break;
                        }
                        this.frame = this.frame%this.animations.length;       
                    },
                    flap : function(){
                        if(this.y > 0)
                        {
                            SFX.flap.play();
                            this.speed = -this.thrust;
                        }
                    },
                    setRotation : function(){
                        if(this.speed <= 0)
                        {
                            
                            this.rotatation = Math.max(-25, -25 * this.speed/(-1*this.thrust));
                        }
                        else if(this.speed > 0 ) {
                            this.rotatation = Math.min(90, 90 * this.speed/(this.thrust*2));
                        }
                    },
                    collisioned : function(){
                        if(!pipe.pipes.length) return;
                        let bird = this.animations[0].sprite;
                        let x = pipe.pipes[0].x;
                        let y = pipe.pipes[0].y;
                        let r = bird.height/4 +bird.width/4;
                        let roof = y + parseFloat(pipe.top.sprite.height);
                        let floor = roof + pipe.gap;
                        let w = parseFloat(pipe.top.sprite.width);
                        if(this.x + r>= x)
                        {
                            if(this.x + r < x + w)
                            {
                                if(this.y - r <= roof || this.y + r>= floor)
                                {
                                    SFX.hit.play();
                                    return true;
                                }

                            }
                            else if(pipe.moved)
                            {
                                UI.score.curr++;
                                SFX.score.play();
                                pipe.moved = false;
                            }

                            
                                
                        }
                    }
                };
                const UI = {
                    getReady : {sprite : new Image()},
                    gameOver : {sprite : new Image()},
                    tap : [{sprite : new Image()},
                        {sprite : new Image()}],
                    score : {
                        curr : 0,
                        best : 0,
                    },
                    x :0,
                    y :0,
                    tx :0,
                    ty :0,
                    frame : 0,
                    draw : function() {
                        switch (state.curr) {
                            case state.getReady :
                                this.y = parseFloat(scrn.height-this.getReady.sprite.height)/2;
                                this.x = parseFloat(scrn.width-this.getReady.sprite.width)/2;
                                this.tx = parseFloat(scrn.width - this.tap[0].sprite.width)/2;
                                this.ty = this.y + this.getReady.sprite.height- this.tap[0].sprite.height;
                                sctx.drawImage(this.getReady.sprite,this.x,this.y);
                                sctx.drawImage(this.tap[this.frame].sprite,this.tx,this.ty)
                                break;
                            case state.gameOver :
                                this.y = parseFloat(scrn.height-this.gameOver.sprite.height)/2;
                                this.x = parseFloat(scrn.width-this.gameOver.sprite.width)/2;
                                this.tx = parseFloat(scrn.width - this.tap[0].sprite.width)/2;
                                this.ty = this.y + this.gameOver.sprite.height- this.tap[0].sprite.height;
                                sctx.drawImage(this.gameOver.sprite,this.x,this.y);
                                sctx.drawImage(this.tap[this.frame].sprite,this.tx,this.ty)
                                pipe.gap == 140
                                frames == 0
                                console.log('you lose')
                                break;
                        }
                        this.drawScore();
                    },
                    drawScore : function() {
                            sctx.fillStyle = "#FFFFFF";
                            sctx.strokeStyle = "#000000";
                        switch (state.curr) {
                            case state.Play :
                                sctx.lineWidth = "2";
                                sctx.font = "35px Times New Roman";
                                sctx.fillText(this.score.curr,scrn.width/2-5,50);
                                sctx.strokeText(this.score.curr,scrn.width/2-5,50);
                                break;
                            case state.gameOver :
                                    sctx.lineWidth = "2";
                                    sctx.font = "40px Times New Roman";
                                    let sc = `SCORE :     ${this.score.curr}`;
                                   /*  try {
                                        this.score.best = Math.max(this.score.curr,localStorage.getItem("best"));
                                        localStorage.setItem("best",this.score.best);
                                        let bs = `BEST  :     ${this.score.best}`;
                                        sctx.fillText(sc,scrn.width/2-80,scrn.height/2+0);
                                        sctx.strokeText(sc,scrn.width/2-80,scrn.height/2+0);
                                        sctx.fillText(bs,scrn.width/2-80,scrn.height/2+30);
                                        sctx.strokeText(bs,scrn.width/2-80,scrn.height/2+30);
                                    }
                                    catch(e) {
                                        sctx.fillText(sc,scrn.width/2-85,scrn.height/2+15);
                                        sctx.strokeText(sc,scrn.width/2-85,scrn.height/2+15);
                                    } */
                                    
                                break;
                        }
                    },
                    update : function() {
                        if(state.curr == state.Play) return;
                        this.frame += (frames % 10==0) ? 1 :0;
                        this.frame = this.frame % this.tap.length;
                    }

                };

                gnd.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/ground.png";
                bg.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/BG.png";
                pipe.top.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/toppipe.png";
                pipe.bot.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/botpipe.png";
                UI.gameOver.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/go.png";
                UI.getReady.sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/getready.png";
                UI.tap[0].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/t0.png";
                UI.tap[1].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/t1.png";
                bird.animations[0].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/b0.png";
                bird.animations[1].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/b1.png";
                bird.animations[2].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/b2.png";
                bird.animations[3].sprite.src="https://raw.githubusercontent.com/CopeBears/AtariFiles/main/b2.png";
                SFX.start.src = "https://github.com/CopeBears/AtariFiles/blob/main/sfx/start.wav?raw=true"
                SFX.flap.src = "https://github.com/CopeBears/AtariFiles/blob/main/sfx/flap.wav?raw=true"
                SFX.score.src = "https://github.com/CopeBears/AtariFiles/blob/main/sfx/score.wav?raw=true"
                SFX.hit.src = "https://github.com/CopeBears/AtariFiles/blob/main/sfx/hit.wav?raw=true"
                SFX.die.src = "https://github.com/CopeBears/AtariFiles/blob/main/sfx/die.wav?raw=true"

                gameLoop();

                function gameLoop()
                { 
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                    frames++;

                    if(frames % 2500 ==0 && gap > 80 && state.curr == 1) {
                        gap -= 3
                        console.log(gap)
                    }

                    if(frames % 2000 ==0 && spawnRate > 60 && state.curr == 1) {
                        spawnRate -= 10
                    }

                  
                    if(state.curr == 2 && gap < 110){
                        gap = 110
                        frames = 0
                        console.log('gameover')
                    } 

                }

                function update()
                {
                bird.update();  
                gnd.update();
                pipe.update();
                UI.update();
                }
                function draw()
                {
                    sctx.fillStyle = "#30c0df";
                    sctx.fillRect(0,0,scrn.width,scrn.height)
                    bg.draw();
                    pipe.draw();
                    
                    bird.draw();
                    gnd.draw();
                    UI.draw();
                }

        })

        document.querySelector('#snake').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'   
            document.querySelector('#snake-container').style.display = 'block'      
            document.querySelector('#canvas1').style.display = 'block'   
/*             let dom_replay = document.querySelector("#replay");
        let dom_score = document.querySelector("#score");
        let dom_canvas = document.createElement("canvas");
        document.querySelector("#canvas-snake").appendChild(dom_canvas); */

        
        let dom_score = document.querySelector("#score");
        let dom_canvas = document.querySelector("canvas");
        let CTX = dom_canvas.getContext("2d");

        // let foodColor = "hsl(98,100%,50%)"
        const W = (dom_canvas.width = 800);
        const H = (dom_canvas.height = 800);

        let snake,
        food,
        currentHue,
        lastHue = 'white',
        cells = 20,
        cellSize,
        isGameOver = false,
        tails = [],
        score = 00,
       /*  maxScore = window.localStorage.getItem("maxScore") || undefined, */
        particles = [],
        splashingParticleCount = 20,
        cellsCount,
        requestID;

        let helpers = {
        Vec: class {
            constructor(x, y) {
            this.x = x;
            this.y = y;
            }
            add(v) {
            this.x += v.x;
            this.y += v.y;
            return this;
            }
            mult(v) {
            if (v instanceof helpers.Vec) {
                this.x *= v.x;
                this.y *= v.y;
                return this;
            } else {
                this.x *= v;
                this.y *= v;
                return this;
            }
            }
        },
        isCollision(v1, v2) {
            return v1.x == v2.x && v1.y == v2.y;
        },
        garbageCollector() {
            for (let i = 0; i < particles.length; i++) {
            if (particles[i].size <= 0) {
                particles.splice(i, 1);
            }
            }
        },
        drawGrid() {
            CTX.lineWidth = 1.1;
            CTX.strokeStyle = "#232332";
            CTX.shadowBlur = 0;
            for (let i = 1; i < cells; i++) {
            let f = (W / cells) * i;
            CTX.beginPath();
            CTX.moveTo(f, 0);
            CTX.lineTo(f, H);
            CTX.stroke();
            CTX.beginPath();
            CTX.moveTo(0, f);
            CTX.lineTo(W, f);
            CTX.stroke();
            CTX.closePath();
            }
        },
        randHue() {
            return ~~(Math.random() * 360);
        },
        hsl2rgb(hue, saturation, lightness) {
            if (hue == undefined) {
            return [0, 0, 0];
            }
            let chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
            let huePrime = hue / 60;
            let secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));

            huePrime = ~~huePrime;
            let red;
            let green;
            let blue;

            if (huePrime === 0) {
            red = chroma;
            green = secondComponent;
            blue = 0;
            } else if (huePrime === 1) {
            red = secondComponent;
            green = chroma;
            blue = 0;
            } else if (huePrime === 2) {
            red = 0;
            green = chroma;
            blue = secondComponent;
            } else if (huePrime === 3) {
            red = 0;
            green = secondComponent;
            blue = chroma;
            } else if (huePrime === 4) {
            red = secondComponent;
            green = 0;
            blue = chroma;
            } else if (huePrime === 5) {
            red = chroma;
            green = 0;
            blue = secondComponent;
            }

            let lightnessAdjustment = lightness - chroma / 2;
            red += lightnessAdjustment;
            green += lightnessAdjustment;
            blue += lightnessAdjustment;

            return [
            Math.round(red * 255),
            Math.round(green * 255),
            Math.round(blue * 255)
            ];
        },
        lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }
        };

        let KEY = {
        ArrowUp: false,
        ArrowRight: false,
        ArrowDown: false,
        ArrowLeft: false,
        resetState() {
            this.ArrowUp = false;
            this.ArrowRight = false;
            this.ArrowDown = false;
            this.ArrowLeft = false;
        },
        listen() {
            addEventListener(
            "keydown",
            (e) => {
                if (e.key === "ArrowUp" && this.ArrowDown) return;
                if (e.key === "ArrowDown" && this.ArrowUp) return;
                if (e.key === "ArrowLeft" && this.ArrowRight) return;
                if (e.key === "ArrowRight" && this.ArrowLeft) return;
                this[e.key] = true;
                Object.keys(this)
                .filter((f) => f !== e.key && f !== "listen" && f !== "resetState")
                .forEach((k) => {
                    this[k] = false;
                });
            },
            false
            );
        }
        };

        class Snake {
        constructor(i, type) {
            this.pos = new helpers.Vec(W / 2, H / 2);
            this.dir = new helpers.Vec(0, 0);
            this.type = type;
            this.index = i;
            this.delay = 5;
            this.size = W / cells;
            this.color = lastHue;
            this.history = [];
            this.total = 1;
        }
        draw() {
            let { x, y } = this.pos;
            CTX.fillStyle = this.color;
            CTX.shadowBlur = 20;
            CTX.shadowColor = lastHue;
            CTX.fillRect(x, y, this.size, this.size);
            CTX.shadowBlur = 3;
            if (this.total >= 2) {
            for (let i = 0; i < this.history.length - 1; i++) {
                let { x, y } = this.history[i];
                CTX.lineWidth = 1;
                CTX.fillStyle = lastHue;
                CTX.fillRect(x, y, this.size, this.size);
            }
            }
        }
        walls() {
            let { x, y } = this.pos;
            if (x + cellSize > W) {
            this.pos.x = 0;
            }
            if (y + cellSize > W) {
            this.pos.y = 0;
            }
            if (y < 0) {
            this.pos.y = H - cellSize;
            }
            if (x < 0) {
            this.pos.x = W - cellSize;
            }
        }
        controlls() {
            let dir = this.size;
            if (KEY.ArrowUp) {
            this.dir = new helpers.Vec(0, -dir);
            }
            if (KEY.ArrowDown) {
            this.dir = new helpers.Vec(0, dir);
            }
            if (KEY.ArrowLeft) {
            this.dir = new helpers.Vec(-dir, 0);
            }
            if (KEY.ArrowRight) {
            this.dir = new helpers.Vec(dir, 0);
            }
        }
        selfCollision() {
            for (let i = 0; i < this.history.length; i++) {
            let p = this.history[i];
            if (helpers.isCollision(this.pos, p)) {
                isGameOver = true;
            }
            }
        }
        update() {
            this.walls();
            this.draw();
            this.controlls();
            if (!this.delay--) {

            // snake eats food
            if (helpers.isCollision(this.pos, food.pos)) {
                lastHue = currentHue
                incrementScore();
                particleSplash();
                food.spawn();
                this.total++;
            }
            this.history[this.total - 1] = new helpers.Vec(this.pos.x, this.pos.y);
            for (let i = 0; i < this.total - 1; i++) {
                this.history[i] = this.history[i + 1];
            }
            this.pos.add(this.dir);
            this.delay = 5;
            this.total > 3 ? this.selfCollision() : null;
            }
        }
        }

        class Food {
        constructor() {
            this.pos = new helpers.Vec(
            ~~(Math.random() * cells) * cellSize,
            ~~(Math.random() * cells) * cellSize
            );
            this.color = currentHue = `hsl(${~~(Math.random() * 360)},100%,50%)`;
            this.size = cellSize;
        }
        draw() {
            let { x, y } = this.pos;
            CTX.globalCompositeOperation = "lighter";
            CTX.shadowBlur = 20;
            CTX.shadowColor = this.color;
            CTX.fillStyle = this.color;
            CTX.fillRect(x, y, this.size, this.size);
            CTX.globalCompositeOperation = "source-over";
            CTX.shadowBlur = 0;
        }
        spawn() {
            let randX = ~~(Math.random() * cells) * this.size;
            let randY = ~~(Math.random() * cells) * this.size;
            for (let path of snake.history) {
            if (helpers.isCollision(new helpers.Vec(randX, randY), path)) {
                return this.spawn();
            }
            }
            this.color = currentHue = `hsl(${helpers.randHue()}, 100%, 50%)`;
            this.pos = new helpers.Vec(randX, randY);
        }
        }

        class Particle {
        constructor(pos, color, size, vel) {
            this.pos = pos;
            this.color = color;
            this.size = Math.abs(size / 2);
            this.ttl = 0;
            this.gravity = -0.2;
            this.vel = vel;
        }
        draw() {
            let { x, y } = this.pos;
            let hsl = this.color
            .split("")
            .filter((l) => l.match(/[^hsl()$% ]/g))
            .join("")
            .split(",")
            .map((n) => +n);
            let [r, g, b] = helpers.hsl2rgb(hsl[0], hsl[1] / 100, hsl[2] / 100);
            CTX.shadowColor = `rgb(${r},${g},${b},${1})`;
            CTX.shadowBlur = 0;
            CTX.globalCompositeOperation = "lighter";
            CTX.fillStyle = `rgb(${r},${g},${b},${1})`;
            CTX.fillRect(x, y, this.size, this.size);
            CTX.globalCompositeOperation = "source-over";
        }
        update() {
            this.draw();
            this.size -= 0.3;
            this.ttl += 1;
            this.pos.add(this.vel);
            this.vel.y -= this.gravity;
        }
        }

        function incrementScore() {
        score++;
        dom_score.innerText = score.toString().padStart(2, "0");
        }

        function particleSplash() {
        for (let i = 0; i < splashingParticleCount; i++) {
            let vel = new helpers.Vec(Math.random() * 6 - 3, Math.random() * 6 - 3);
            let position = new helpers.Vec(food.pos.x, food.pos.y);
            particles.push(new Particle(position, currentHue, food.size, vel));
        }
        }

        function clear() {
        CTX.clearRect(0, 0, W, H);
        }

        function initialize() {
        CTX.imageSmoothingEnabled = false;
        KEY.listen();
        cellsCount = cells * cells;
        cellSize = W / cells;
        snake = new Snake();
        food = new Food();
        loop();
        }

        function loop() {
        clear();
        if (!isGameOver) {
            requestID = setTimeout(loop, 1000 / 80);
            helpers.drawGrid();
            snake.update();
            food.draw();
   
            console.log(lastHue)
            for (let p of particles) {
            p.update();
            }
            helpers.garbageCollector();
        } else {
            clear();
            gameOver();
        }
        }

        function gameOver() {
        CTX.fillStyle = "#4cffd7";
        CTX.textAlign = "center";
        CTX.font = "bold 30px Poppins, sans-serif";
        CTX.fillText("GAME OVER", W / 2, H / 2);
        CTX.font = "15px Poppins, sans-serif";
        CTX.fillText(`SCORE   ${score}`, W / 2, H / 2 + 60);
        }

        function reset() {
        dom_score.innerText = "00";
        score = "00";
        snake = new Snake();
        food.spawn();
        KEY.resetState();
        isGameOver = false;
        clearTimeout(requestID);
        loop();
        }

        initialize();
        listen();

                })

        document.querySelector('#pacman').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'   
            document.querySelector('#canvas').style.top = '-60px'
            var newChildObject = function(parentObj, newObj) {

            // equivalent to: var resultObj = { __proto__: parentObj };
            var x = function(){};
            x.prototype = parentObj;
            var resultObj = new x();

            // store new members in resultObj
            if (newObj) {
                var hasProp = {}.hasOwnProperty;
                for (var name in newObj) {
                    if (hasProp.call(newObj, name)) {
                        resultObj[name] = newObj[name];
                    }
                }
            }

            return resultObj;
            };

            var DEBUG = false;
            //@line 1 "src/sound.js"
            /* Sound handlers added by Dr James Freeman who was sad such a great reverse was a silent movie  */

            var audio = new preloadAudio();

            function audioTrack(url, volume) {
            var audio = new Audio(url);
            if (volume) audio.volume = volume;
            audio.load();
            var looping = false;
            this.play = function(noResetTime) {
                playSound(noResetTime);
            };
            this.startLoop = function(noResetTime) {
                if (looping) return;
                audio.addEventListener('ended', audioLoop);
                audioLoop(noResetTime);
                looping = true;
            };
            this.stopLoop = function(noResetTime) {
                try{ audio.removeEventListener('ended', audioLoop) } catch (e) {};
                audio.pause();
                if (!noResetTime) audio.currentTime = 0;
                looping = false;
            };
            this.isPlaying = function() {
                return !audio.paused;
            };
            this.isPaused = function() {
                return audio.paused;
            }; 
            this.stop = this.stopLoop;

            function audioLoop(noResetTime) {
                playSound(noResetTime);
            }
            function playSound(noResetTime) {
                // for really rapid sound repeat set noResetTime
                if(!audio.paused) {
                    audio.pause();
                    if (!noResetTime ) audio.currentTime = 0;
                }
                try{
                    var playPromise = audio.play();
                    if(playPromise) {
                        playPromise.then(function(){}).catch(function(err){});
                    }
                } 
                catch(err){ console.error(err) }
            }
            }


            function preloadAudio() {

            this.credit            = new audioTrack('https://ipfs.io/ipfs/QmbJPfFmrAgZy6jSvSjgT4Finu5x1m4V7jcuDUkcpgw447');
            this.coffeeBreakMusic  = new audioTrack('https://ipfs.io/ipfs/QmNaz7iHfFGspmNv8NgpVrbKVUZNcqCGLhhQi4tFcwWL3X');
            this.die               = new audioTrack('https://ipfs.io/ipfs/QmVSTWiLNSsgpPpS5YLoPvQZd8bTWJ1of85fVbsATCLgu8');
            this.ghostReturnToHome = new audioTrack('https://ipfs.io/ipfs/QmQadYrS8Lz2UQHPuBo3u72Eyk8T3JFkD7HKgUSZfRKfXh');
            this.eatingGhost       = new audioTrack('https://ipfs.io/ipfs/QmTuJvtAd5KoafsNwRLJDvWx1uEwqUABCNBWM2VWhEym9x');
            this.ghostTurnToBlue   = new audioTrack('https://ipfs.io/ipfs/Qmbnea5PrpW5qHGU9Ug6WeaVz9LwmKWGbdJAcqLeJBZCnR', 0.5);
            this.eatingFruit       = new audioTrack('https://ipfs.io/ipfs/QmYjc4JmToYtincSPNFZRzhxh1NsW1Zq8xEQ14ybdxxgab');
            this.ghostSpurtMove1   = new audioTrack('https://ipfs.io/ipfs/QmQ7iMkgHcxvLjno6DN45HogMjn1UF4NLR4eC8VsaN9Fr5');
            this.ghostSpurtMove2   = new audioTrack('https://ipfs.io/ipfs/Qmc9B5JtRVJmbACqqfbhmruWjybwCRkcFQKoiTungG3ufE');
            this.ghostSpurtMove3   = new audioTrack('https://ipfs.io/ipfs/QmWGesCvgck4fKsfTqrEueLwaiDMkWn199jRFz7PMkRi21');
            this.ghostSpurtMove4   = new audioTrack('https://ipfs.io/ipfs/Qmeb4q9c9ERsATVRG2ZzWGvZFFzwTpBu6sEQFn154drE5g');
            this.ghostNormalMove   = new audioTrack('https://ipfs.io/ipfs/QmcEaWp5Yuzs2NXsjitnaw2DnaaQfhn1m5EXG2txfeqLm8');
            this.extend            = new audioTrack('https://ipfs.io/ipfs/QmbgEfAQQJvnZWAxvMRQvU76TYothf1kjDFSjjzE2WfBXu');
            this.eating            = new audioTrack('https://ipfs.io/ipfs/QmXeG9YRqjKGTXT3VaBCBkcozZPxk1GXYBSunFy2geeK94', 0.5);
            this.startMusic        = new audioTrack('https://ipfs.io/ipfs/QmfDgWtivuDM1T8X6XMXtRZH9gr35xUNTyf8yThkamTZLZ');

            this.ghostReset = function(noResetTime) {
                for (var s in this) {
                    if (s == 'silence' || s == 'ghostReset' ) return;
                    if (s.match(/^ghost/)) this[s].stopLoop(noResetTime);
                }
            };

            this.silence = function(noResetTime) {
                for (var s in this) {
                    if (s == 'silence' || s == 'ghostReset' ) return;
                    this[s].stopLoop(noResetTime);
                }
            }
            }
            //@line 1 "src/random.js"

            var getRandomColor = function() {
            return '#'+('00000'+(Math.random()*(1<<24)|0).toString(16)).slice(-6);
            };

            var getRandomInt = function(min,max) {
            return Math.floor(Math.random() * (max-min+1)) + min;
            };

            //@line 1 "src/game.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Game

            // game modes
            var GAME_PACMAN = 0;
            var GAME_MSPACMAN = 1;
            var GAME_COOKIE = 2;
            var GAME_OTTO = 3;

            var practiceMode = false;
            var turboMode = false;

            // current game mode
            var gameMode = GAME_PACMAN;
            var getGameName = (function(){

            var names = ["PAC-MAN", "MS PAC-MAN", "COOKIE-MAN","CRAZY OTTO"];

            return function(mode) {
                if (mode == undefined) {
                    mode = gameMode;
                }
                return names[mode];
            };
            })();

            var getGameDescription = (function(){

            var desc = [
                [
                    "ORIGINAL ARCADE:",
                    "NAMCO (C) 1980",
                    "",
                    "REVERSE-ENGINEERING:",
                    "JAMEY PITTMAN",
                    "",
                    "REMAKE:",
                    "SHAUN WILLIAMS",
                ],
                [
                    "ORIGINAL ARCADE ADDON:",
                    "MIDWAY/GCC (C) 1981",
                    "",
                    "REVERSE-ENGINEERING:",
                    "BART GRANTHAM",
                    "",
                    "REMAKE:",
                    "SHAUN WILLIAMS",
                ],
                [
                    "A NEW PAC-MAN GAME",
                    "WITH RANDOM MAZES:",
                    "SHAUN WILLIAMS (C) 2012",
                    "",
                    "COOKIE MONSTER DESIGN:",
                    "JIM HENSON",
                    "",
                    "PAC-MAN CROSSOVER CONCEPT:",
                    "TANG YONGFA",
                ],
                [
                    "THE UNRELEASED",
                    "MS. PAC-MAN PROTOTYPE:",
                    "GCC (C) 1981",
                    "",
                    "SPRITES REFERENCED FROM",
                    "STEVE GOLSON'S",
                    "CAX 2012 PRESENTATION",
                    "",
                    "REMAKE:",
                    "SHAUN WILLIAMS",
                ],
            ];

            return function(mode) {
                if (mode == undefined) {
                    mode = gameMode;
                }
                return desc[mode];
            };
            })();

            var getGhostNames = function(mode) {
            if (mode == undefined) {
                mode = gameMode;
            }
            if (mode == GAME_OTTO) {
                return ["plato","darwin","freud","newton"];
            }
            else if (mode == GAME_MSPACMAN) {
                return ["blinky","pinky","inky","sue"];
            }
            else if (mode == GAME_PACMAN) {
                return ["blinky","pinky","inky","clyde"];
            }
            else if (mode == GAME_COOKIE) {
                return ["elmo","piggy","rosita","zoe"];
            }
            };

            var getGhostDrawFunc = function(mode) {
            if (mode == undefined) {
                mode = gameMode;
            }
            if (mode == GAME_OTTO) {
                return atlas.drawMonsterSprite;
            }
            else if (mode == GAME_COOKIE) {
                return atlas.drawMuppetSprite;
            }
            else {
                return atlas.drawGhostSprite;
            }
            };

            var getPlayerDrawFunc = function(mode) {
            if (mode == undefined) {
                mode = gameMode;
            }
            if (mode == GAME_OTTO) {
                return atlas.drawOttoSprite;
            }
            else if (mode == GAME_PACMAN) {
                return atlas.drawPacmanSprite;
            }
            else if (mode == GAME_MSPACMAN) {
                return atlas.drawMsPacmanSprite;
            }
            else if (mode == GAME_COOKIE) {
                //return atlas.drawCookiemanSprite;
                return drawCookiemanSprite;
            }
            };


            // for clearing, backing up, and restoring cheat states (before and after cutscenes presently)
            var clearCheats, backupCheats, restoreCheats;
            (function(){
            clearCheats = function() {
                pacman.invincible = false;
                pacman.ai = false;
                for (i=0; i<5; i++) {
                    actors[i].isDrawPath = false;
                    actors[i].isDrawTarget = false;
                }
                executive.setUpdatesPerSecond(60);
            };

            var i, invincible, ai, isDrawPath, isDrawTarget;
            isDrawPath = {};
            isDrawTarget = {};
            backupCheats = function() {
                invincible = pacman.invincible;
                ai = pacman.ai;
                for (i=0; i<5; i++) {
                    isDrawPath[i] = actors[i].isDrawPath;
                    isDrawTarget[i] = actors[i].isDrawTarget;
                }
            };
            restoreCheats = function() {
                pacman.invincible = invincible;
                pacman.ai = ai;
                for (i=0; i<5; i++) {
                    actors[i].isDrawPath = isDrawPath[i];
                    actors[i].isDrawTarget = isDrawTarget[i];
                }
            };
            })();

            // current level, lives, and score
            var level = 1;
            var extraLives = 0;

            // VCR functions

            var savedLevel = {};
            var savedExtraLives = {};
            var savedHighScore = {};
            var savedScore = {};
            var savedState = {};

            var saveGame = function(t) {
            savedLevel[t] = level;
            savedExtraLives[t] = extraLives;
            savedHighScore[t] = getHighScore();
            savedScore[t] = getScore();
            savedState[t] = state;
            };
            var loadGame = function(t) {
            level = savedLevel[t];
            if (extraLives != savedExtraLives[t]) {
                extraLives = savedExtraLives[t];
                renderer.drawMap();
            }
            setHighScore(savedHighScore[t]);
            setScore(savedScore[t]);
            state = savedState[t];
            };

            /// SCORING
            // (manages scores and high scores for each game type)

            var scores = [
            0,0, // pacman
            0,0, // mspac
            0,0, // cookie
            0,0, // otto
            0 ];
            var highScores = [
            10000,10000, // pacman
            10000,10000, // mspac
            10000,10000, // cookie
            10000,10000, // otto
            ];

            var getScoreIndex = function() {
            if (practiceMode) {
                return 8;
            }
            return gameMode*2 + (turboMode ? 1 : 0);
            };

            // handle a score increment
            var addScore = function(p) {

            // get current scores
            var score = getScore();

            // handle extra life at 10000 points
            if (score < 10000 && score+p >= 10000) {
                extraLives++;
                renderer.drawMap();
            }

            score += p;
            setScore(score);

            if (!practiceMode) {
                if (score > getHighScore()) {
                    setHighScore(score);
                }
            }
            };

            var getScore = function() {
            return scores[getScoreIndex()];
            };
            var setScore = function(score) {
            scores[getScoreIndex()] = score;
            };

            var getHighScore = function() {
            return highScores[getScoreIndex()];
            };
            var setHighScore = function(highScore) {
            highScores[getScoreIndex()] = highScore;
            saveHighScores();
            };
            // High Score Persistence

            var loadHighScores = function() {
            var hs;
            var hslen;
            var i;
/*             if (localStorage && localStorage.highScores) {
                hs = JSON.parse(localStorage.highScores);
                hslen = hs.length;
                for (i=0; i<hslen; i++) {
                    highScores[i] = Math.max(highScores[i],hs[i]);
                }
            } */
            };
            var saveHighScores = function() {
/*             if (localStorage) {
                localStorage.highScores = JSON.stringify(highScores);
            } */
            };
            //@line 1 "src/direction.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Directions
            // (variables and utility functions for representing actor heading direction)

            // direction enums (in counter-clockwise order)
            // NOTE: changing the order of these enums may effect the enums.
            //       I've tried abstracting away the uses by creating functions to rotate them.
            // NOTE: This order determines tie-breakers in the shortest distance turn logic.
            //       (i.e. higher priority turns have lower enum values)
            var DIR_UP = 0;
            var DIR_LEFT = 1;
            var DIR_DOWN = 2;
            var DIR_RIGHT = 3;

            var getClockwiseAngleFromTop = function(dirEnum) {
            return -dirEnum*Math.PI/2;
            };

            var rotateLeft = function(dirEnum) {
            return (dirEnum+1)%4;
            };

            var rotateRight = function(dirEnum) {
            return (dirEnum+3)%4;
            };

            var rotateAboutFace = function(dirEnum) {
            return (dirEnum+2)%4;
            };

            // get direction enum from a direction vector
            var getEnumFromDir = function(dir) {
            if (dir.x==-1) return DIR_LEFT;
            if (dir.x==1) return DIR_RIGHT;
            if (dir.y==-1) return DIR_UP;
            if (dir.y==1) return DIR_DOWN;
            };

            // set direction vector from a direction enum
            var setDirFromEnum = function(dir,dirEnum) {
            if (dirEnum == DIR_UP)         { dir.x = 0; dir.y =-1; }
            else if (dirEnum == DIR_RIGHT)  { dir.x =1; dir.y = 0; }
            else if (dirEnum == DIR_DOWN)  { dir.x = 0; dir.y = 1; }
            else if (dirEnum == DIR_LEFT) { dir.x = -1; dir.y = 0; }
            };

            // return the direction of the open, surrounding tile closest to our target
            var getTurnClosestToTarget = function(tile,targetTile,openTiles) {

            var dx,dy,dist;                      // variables used for euclidean distance
            var minDist = Infinity;              // variable used for finding minimum distance path
            var dir = {};
            var dirEnum = 0;
            var i;
            for (i=0; i<4; i++) {
                if (openTiles[i]) {
                    setDirFromEnum(dir,i);
                    dx = dir.x + tile.x - targetTile.x;
                    dy = dir.y + tile.y - targetTile.y;
                    dist = dx*dx+dy*dy;
                    if (dist < minDist) {
                        minDist = dist;
                        dirEnum = i;
                    }
                }
            }
            return dirEnum;
            };

            // retrieve four surrounding tiles and indicate whether they are open
            var getOpenTiles = function(tile,dirEnum) {

            // get open passages
            var openTiles = {};
            openTiles[DIR_UP] =    map.isFloorTile(tile.x, tile.y-1);
            openTiles[DIR_RIGHT] = map.isFloorTile(tile.x+1, tile.y);
            openTiles[DIR_DOWN] =  map.isFloorTile(tile.x, tile.y+1);
            openTiles[DIR_LEFT] =  map.isFloorTile(tile.x-1, tile.y);

            var numOpenTiles = 0;
            var i;
            if (dirEnum != undefined) {

                // count number of open tiles
                for (i=0; i<4; i++)
                    if (openTiles[i])
                        numOpenTiles++;

                // By design, no mazes should have dead ends,
                // but allow player to turn around if and only if it's necessary.
                // Only close the passage behind the player if there are other openings.
                var oppDirEnum = rotateAboutFace(dirEnum); // current opposite direction enum
                if (numOpenTiles > 1)
                    openTiles[oppDirEnum] = false;
            }

            return openTiles;
            };

            // returns if the given tile coordinate plus the given direction vector has a walkable floor tile
            var isNextTileFloor = function(tile,dir) {
            return map.isFloorTile(tile.x+dir.x,tile.y+dir.y);
            };

            //@line 1 "src/Map.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Map
            // (an ascii map of tiles representing a level maze)

            // size of a square tile in pixels
            var tileSize = 8;

            // the center pixel of a tile
            var midTile = {x:3, y:4};

            // constructor
            var Map = function(numCols, numRows, tiles) {

            // sizes
            this.numCols = numCols;
            this.numRows = numRows;
            this.numTiles = numCols*numRows;
            this.widthPixels = numCols*tileSize;
            this.heightPixels = numRows*tileSize;

            // ascii map
            this.tiles = tiles;

            // ghost home location
            this.doorTile = {x:13, y:14};
            this.doorPixel = {
                x:(this.doorTile.x+1)*tileSize-1, 
                y:this.doorTile.y*tileSize + midTile.y
            };
            this.homeTopPixel = 17*tileSize;
            this.homeBottomPixel = 18*tileSize;

            this.timeEaten = {};

            this.resetCurrent();
            this.parseDots();
            this.parseTunnels();
            this.parseWalls();
            };

            Map.prototype.save = function(t) {
            };

            Map.prototype.eraseFuture = function(t) {
            // current state at t.
            // erase all states after t.
            var i;
            for (i=0; i<this.numTiles; i++) {
                if (t <= this.timeEaten[i]) {
                    delete this.timeEaten[i];
                }
            }
            };

            Map.prototype.load = function(t,abs_t) {
            var firstTile,curTile;
            var refresh = function(i) {
                var x,y;
                x = i%this.numCols;
                y = Math.floor(i/this.numCols);
                renderer.refreshPellet(x,y);
            };
            var i;
            for (i=0; i<this.numTiles; i++) {
                firstTile = this.startTiles[i];
                if (firstTile == '.' || firstTile == 'o') {
                    if (abs_t <= this.timeEaten[i]) { // dot should be present
                        if (this.currentTiles[i] != firstTile) {
                            this.dotsEaten--;
                            this.currentTiles[i] = firstTile;
                            refresh.call(this,i);
                        }
                    }
                    else if (abs_t > this.timeEaten[i]) { // dot should be missing
                        if (this.currentTiles[i] != ' ') {
                            this.dotsEaten++;
                            this.currentTiles[i] = ' ';
                            refresh.call(this,i);
                        }
                    }
                }
            }
            };

            Map.prototype.resetTimeEaten = function()
            {
            this.startTiles = this.currentTiles.slice(0);
            this.timeEaten = {};
            };

            // reset current tiles
            Map.prototype.resetCurrent = function() {
            this.currentTiles = this.tiles.split(""); // create a mutable list copy of an immutable string
            this.dotsEaten = 0;
            };

            // This is a procedural way to generate original-looking maps from a simple ascii tile
            // map without a spritesheet.
            Map.prototype.parseWalls = function() {

            var that = this;

            // creates a list of drawable canvas paths to render the map walls
            this.paths = [];

            // a map of wall tiles that already belong to a built path
            var visited = {};

            // we extend the x range to suggest the continuation of the tunnels
            var toIndex = function(x,y) {
                if (x>=-2 && x<that.numCols+2 && y>=0 && y<that.numRows)
                    return (x+2)+y*(that.numCols+4);
            };

            // a map of which wall tiles that are not completely surrounded by other wall tiles
            var edges = {};
            var i=0,x,y;
            for (y=0;y<this.numRows;y++) {
                for (x=-2;x<this.numCols+2;x++,i++) {
                    if (this.getTile(x,y) == '|' &&
                        (this.getTile(x-1,y) != '|' ||
                        this.getTile(x+1,y) != '|' ||
                        this.getTile(x,y-1) != '|' ||
                        this.getTile(x,y+1) != '|' ||
                        this.getTile(x-1,y-1) != '|' ||
                        this.getTile(x-1,y+1) != '|' ||
                        this.getTile(x+1,y-1) != '|' ||
                        this.getTile(x+1,y+1) != '|')) {
                        edges[i] = true;
                    }
                }
            }

            // walks along edge wall tiles starting at the given index to build a canvas path
            var makePath = function(tx,ty) {

                // get initial direction
                var dir = {};
                var dirEnum;
                if (toIndex(tx+1,ty) in edges)
                    dirEnum = DIR_RIGHT;
                else if (toIndex(tx, ty+1) in edges)
                    dirEnum = DIR_DOWN;
                else
                    throw "tile shouldn't be 1x1 at "+tx+","+ty;
                setDirFromEnum(dir,dirEnum);

                // increment to next tile
                tx += dir.x;
                ty += dir.y;

                // backup initial location and direction
                var init_tx = tx;
                var init_ty = ty;
                var init_dirEnum = dirEnum;

                var path = [];
                var pad; // (persists for each call to getStartPoint)
                var point;
                var lastPoint;

                var turn,turnAround;

                /*

                We employ the 'right-hand rule' by keeping our right hand in contact
                with the wall to outline an individual wall piece.

                Since we parse the tiles in row major order, we will always start
                walking along the wall at the leftmost tile of its topmost row.  We
                then proceed walking to the right.  

                When facing the direction of the walk at each tile, the outline will
                hug the left side of the tile unless there is a walkable tile to the
                left.  In that case, there will be a padding distance applied.
                
                */
                var getStartPoint = function(tx,ty,dirEnum) {
                    var dir = {};
                    setDirFromEnum(dir, dirEnum);
                    if (!(toIndex(tx+dir.y,ty-dir.x) in edges))
                        pad = that.isFloorTile(tx+dir.y,ty-dir.x) ? 5 : 0;
                    var px = -tileSize/2+pad;
                    var py = tileSize/2;
                    var a = getClockwiseAngleFromTop(dirEnum);
                    var c = Math.cos(a);
                    var s = Math.sin(a);
                    return {
                        // the first expression is the rotated point centered at origin
                        // the second expression is to translate it to the tile
                        x:(px*c - py*s) + (tx+0.5)*tileSize,
                        y:(px*s + py*c) + (ty+0.5)*tileSize,
                    };
                };
                while (true) {
                    
                    visited[toIndex(tx,ty)] = true;

                    // determine start point
                    point = getStartPoint(tx,ty,dirEnum);

                    if (turn) {
                        // if we're turning into this tile, create a control point for the curve
                        //
                        // >---+  <- control point
                        //     |
                        //     V
                        lastPoint = path[path.length-1];
                        if (dir.x == 0) {
                            point.cx = point.x;
                            point.cy = lastPoint.y;
                        }
                        else {
                            point.cx = lastPoint.x;
                            point.cy = point.y;
                        }
                    }

                    // update direction
                    turn = false;
                    turnAround = false;
                    if (toIndex(tx+dir.y, ty-dir.x) in edges) { // turn left
                        dirEnum = rotateLeft(dirEnum);
                        turn = true;
                    }
                    else if (toIndex(tx+dir.x, ty+dir.y) in edges) { // continue straight
                    }
                    else if (toIndex(tx-dir.y, ty+dir.x) in edges) { // turn right
                        dirEnum = rotateRight(dirEnum);
                        turn = true;
                    }
                    else { // turn around
                        dirEnum = rotateAboutFace(dirEnum);
                        turnAround = true;
                    }
                    setDirFromEnum(dir,dirEnum);

                    // commit path point
                    path.push(point);

                    // special case for turning around (have to connect more dots manually)
                    if (turnAround) {
                        path.push(getStartPoint(tx-dir.x, ty-dir.y, rotateAboutFace(dirEnum)));
                        path.push(getStartPoint(tx, ty, dirEnum));
                    }

                    // advance to the next wall
                    tx += dir.x;
                    ty += dir.y;

                    // exit at full cycle
                    if (tx==init_tx && ty==init_ty && dirEnum == init_dirEnum) {
                        that.paths.push(path);
                        break;
                    }
                }
            };

            // iterate through all edges, making a new path after hitting an unvisited wall edge
            i=0;
            for (y=0;y<this.numRows;y++)
                for (x=-2;x<this.numCols+2;x++,i++)
                    if (i in edges && !(i in visited)) {
                        visited[i] = true;
                        makePath(x,y);
                    }
            };

            // count pellets and store energizer locations
            Map.prototype.parseDots = function() {

            this.numDots = 0;
            this.numEnergizers = 0;
            this.energizers = [];

            var x,y;
            var i = 0;
            var tile;
            for (y=0; y<this.numRows; y++) for (x=0; x<this.numCols; x++) {
                tile = this.tiles[i];
                if (tile == '.') {
                    this.numDots++;
                }
                else if (tile == 'o') {
                    this.numDots++;
                    this.numEnergizers++;
                    this.energizers.push({'x':x,'y':y});
                }
                i++;
            }
            };

            // get remaining dots left
            Map.prototype.dotsLeft = function() {
            return this.numDots - this.dotsEaten;
            };

            // determine if all dots have been eaten
            Map.prototype.allDotsEaten = function() {
            return this.dotsLeft() == 0;
            };

            // create a record of tunnel locations
            Map.prototype.parseTunnels = (function(){

            // starting from x,y and increment x by dx...
            // determine where the tunnel entrance begins
            var getTunnelEntrance = function(x,y,dx) {
                while (!this.isFloorTile(x,y-1) && !this.isFloorTile(x,y+1) && this.isFloorTile(x,y))
                    x += dx;
                return x;
            };

            // the number of margin tiles outside of the map on one side of a tunnel
            // There are (2*marginTiles) tiles outside of the map per tunnel.
            var marginTiles = 2;

            return function() {
                this.tunnelRows = {};
                var y;
                var i;
                var left,right;
                for (y=0;y<this.numRows;y++)
                    // a map row is a tunnel if opposite ends are both walkable tiles
                    if (this.isFloorTile(0,y) && this.isFloorTile(this.numCols-1,y))
                        this.tunnelRows[y] = {
                            'leftEntrance': getTunnelEntrance.call(this,0,y,1),
                            'rightEntrance':getTunnelEntrance.call(this,this.numCols-1,y,-1),
                            'leftExit': -marginTiles*tileSize,
                            'rightExit': (this.numCols+marginTiles)*tileSize-1,
                        };
            };
            })();

            // teleport actor to other side of tunnel if necessary
            Map.prototype.teleport = function(actor){
            var i;
            var t = this.tunnelRows[actor.tile.y];
            if (t) {
                if (actor.pixel.x < t.leftExit)       actor.pixel.x = t.rightExit;
                else if (actor.pixel.x > t.rightExit) actor.pixel.x = t.leftExit;
            }
            };

            Map.prototype.posToIndex = function(x,y) {
            if (x>=0 && x<this.numCols && y>=0 && y<this.numRows) 
                return x+y*this.numCols;
            };

            // define which tiles are inside the tunnel
            Map.prototype.isTunnelTile = function(x,y) {
            var tunnel = this.tunnelRows[y];
            return tunnel && (x < tunnel.leftEntrance || x > tunnel.rightEntrance);
            };

            // retrieves tile character at given coordinate
            // extended to include offscreen tunnel space
            Map.prototype.getTile = function(x,y) {
            if (x>=0 && x<this.numCols && y>=0 && y<this.numRows) 
                return this.currentTiles[this.posToIndex(x,y)];
            if ((x<0 || x>=this.numCols) && (this.isTunnelTile(x,y-1) || this.isTunnelTile(x,y+1)))
                return '|';
            if (this.isTunnelTile(x,y))
                return ' ';
            };

            // determines if the given character is a walkable floor tile
            Map.prototype.isFloorTileChar = function(tile) {
            return tile==' ' || tile=='.' || tile=='o';
            };

            // determines if the given tile coordinate has a walkable floor tile
            Map.prototype.isFloorTile = function(x,y) {
            return this.isFloorTileChar(this.getTile(x,y));
            };

            // mark the dot at the given coordinate eaten
            Map.prototype.onDotEat = function(x,y) {
            this.dotsEaten++;
            var i = this.posToIndex(x,y);
            this.currentTiles[i] = ' ';
            this.timeEaten[i] = vcr.getTime();
            renderer.erasePellet(x,y);
            };
            //@line 1 "src/colors.js"
            // source: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript

            /**
            * Converts an RGB color value to HSL. Conversion formula
            * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
            * Assumes r, g, and b are contained in the set [0, 255] and
            * returns h, s, and l in the set [0, 1].
            *
            * @param   Number  r       The red color value
            * @param   Number  g       The green color value
            * @param   Number  b       The blue color value
            * @return  Array           The HSL representation
            */
            function rgbToHsl(r, g, b){
            r /= 255, g /= 255, b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;

            if(max == min){
                h = s = 0; // achromatic
            }else{
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch(max){
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h, s, l];
            }

            /**
            * Converts an HSL color value to RGB. Conversion formula
            * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
            * Assumes h, s, and l are contained in the set [0, 1] and
            * returns r, g, and b in the set [0, 255].
            *
            * @param   Number  h       The hue
            * @param   Number  s       The saturation
            * @param   Number  l       The lightness
            * @return  Array           The RGB representation
            */
            function hslToRgb(h, s, l){
            var r, g, b;

            if(s == 0){
                r = g = b = l; // achromatic
            }else{
                function hue2rgb(p, q, t){
                    if(t < 0) t += 1;
                    if(t > 1) t -= 1;
                    if(t < 1/6) return p + (q - p) * 6 * t;
                    if(t < 1/2) return q;
                    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            r *= 255;
            g *= 255;
            b *= 255;

            return [r,g,b];
            }

            /**
            * Converts an RGB color value to HSV. Conversion formula
            * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
            * Assumes r, g, and b are contained in the set [0, 255] and
            * returns h, s, and v in the set [0, 1].
            *
            * @param   Number  r       The red color value
            * @param   Number  g       The green color value
            * @param   Number  b       The blue color value
            * @return  Array           The HSV representation
            */
            function rgbToHsv(r, g, b){
            r = r/255, g = g/255, b = b/255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, v = max;

            var d = max - min;
            s = max == 0 ? 0 : d / max;

            if(max == min){
                h = 0; // achromatic
            }else{
                switch(max){
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h, s, v];
            }

            /**
            * Converts an HSV color value to RGB. Conversion formula
            * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
            * Assumes h, s, and v are contained in the set [0, 1] and
            * returns r, g, and b in the set [0, 255].
            *
            * @param   Number  h       The hue
            * @param   Number  s       The saturation
            * @param   Number  v       The value
            * @return  Array           The RGB representation
            */
            function hsvToRgb(h, s, v){
            var r, g, b;

            var i = Math.floor(h * 6);
            var f = h * 6 - i;
            var p = v * (1 - s);
            var q = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);

            switch(i % 6){
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }

            r *= 255;
            g *= 255;
            b *= 255;

            return [r,g,b];
            }

            function rgbString(rgb) {
            var r = Math.floor(rgb[0]);
            var g = Math.floor(rgb[1]);
            var b = Math.floor(rgb[2]);
            return 'rgb('+r+','+g+','+b+')';
            }
            //@line 1 "src/mapgen.js"
            var mapgen = (function(){

            var shuffle = function(list) {
                var len = list.length;
                var i,j;
                var temp;
                for (i=0; i<len; i++) {
                    j = getRandomInt(0,len-1);
                    temp = list[i];
                    list[i] = list[j];
                    list[j] = temp;
                }
            };

            var randomElement = function(list) {
                var len = list.length;
                if (len > 0) {
                    return list[getRandomInt(0,len-1)];
                }
            };

            var UP = 0;
            var RIGHT = 1;
            var DOWN = 2;
            var LEFT = 3;

            var cells = [];
            var tallRows = [];
            var narrowCols = [];

            var rows = 9;
            var cols = 5;

            var reset = function() {
                var i;
                var c;

                // initialize cells
                for (i=0; i<rows*cols; i++) {
                    cells[i] = {
                        x: i%cols,
                        y: Math.floor(i/cols),
                        filled: false,
                        connect: [false, false, false, false],
                        next: [],
                        no: undefined,
                        group: undefined,
                    };
                }

                // allow each cell to refer to surround cells by direction
                for (i=0; i<rows*cols; i++) {
                    var c = cells[i];
                    if (c.x > 0)
                        c.next[LEFT] = cells[i-1];
                    if (c.x < cols - 1)
                        c.next[RIGHT] = cells[i+1];
                    if (c.y > 0)
                        c.next[UP] = cells[i-cols];
                    if (c.y < rows - 1)
                        c.next[DOWN] = cells[i+cols];
                }

                // define the ghost home square

                i = 3*cols;
                c = cells[i];
                c.filled=true;
                c.connect[LEFT] = c.connect[RIGHT] = c.connect[DOWN] = true;

                i++;
                c = cells[i];
                c.filled=true;
                c.connect[LEFT] = c.connect[DOWN] = true;

                i+=cols-1;
                c = cells[i];
                c.filled=true;
                c.connect[LEFT] = c.connect[UP] = c.connect[RIGHT] = true;

                i++;
                c = cells[i];
                c.filled=true;
                c.connect[UP] = c.connect[LEFT] = true;
            };

            var genRandom = function() {

                var getLeftMostEmptyCells = function() {
                    var x;
                    var leftCells = [];
                    for (x=0; x<cols; x++) {
                        for (y=0; y<rows; y++) {
                            var c = cells[x+y*cols];
                            if (!c.filled) {
                                leftCells.push(c);
                            }
                        }

                        if (leftCells.length > 0) {
                            break;
                        }
                    }
                    return leftCells;
                };
                var isOpenCell = function(cell,i,prevDir,size) {

                    // prevent wall from going through starting position
                    if (cell.y == 6 && cell.x == 0 && i == DOWN ||
                        cell.y == 7 && cell.x == 0 && i == UP) {
                        return false;
                    }

                    // prevent long straight pieces of length 3
                    if (size == 2 && (i==prevDir || rotateAboutFace(i)==prevDir)) {
                        return false;
                    }

                    // examine an adjacent empty cell
                    if (cell.next[i] && !cell.next[i].filled) {
                        
                        // only open if the cell to the left of it is filled
                        if (cell.next[i].next[LEFT] && !cell.next[i].next[LEFT].filled) {
                        }
                        else {
                            return true;
                        }
                    }

                    return false;
                };
                var getOpenCells = function(cell,prevDir,size) {
                    var openCells = [];
                    var numOpenCells = 0;
                    for (i=0; i<4; i++) {
                        if (isOpenCell(cell,i,prevDir,size)) {
                            openCells.push(i);
                            numOpenCells++;
                        }
                    }
                    return { openCells: openCells, numOpenCells: numOpenCells };
                };
                var connectCell = function(cell,dir) {
                    cell.connect[dir] = true;
                    cell.next[dir].connect[rotateAboutFace(dir)] = true;
                    if (cell.x == 0 && dir == RIGHT) {
                        cell.connect[LEFT] = true;
                    }
                };

                var gen = function() {
                
                    var cell;      // cell at the center of growth (open cells are chosen around this cell)
                    var newCell;   // most recent cell filled
                    var firstCell; // the starting cell of the current group

                    var openCells;    // list of open cells around the center cell
                    var numOpenCells; // size of openCells

                    var dir; // the most recent direction of growth relative to the center cell
                    var i;   // loop control variable used for iterating directions

                    var numFilled = 0;  // current count of total cells filled
                    var numGroups;      // current count of cell groups created
                    var size;           // current number of cells in the current group
                    var probStopGrowingAtSize = [ // probability of stopping growth at sizes...
                            0,     // size 0
                            0,     // size 1
                            0.10,  // size 2
                            0.5,   // size 3
                            0.75,  // size 4
                            1];    // size 5

                    // A single cell group of size 1 is allowed at each row at y=0 and y=rows-1,
                    // so keep count of those created.
                    var singleCount = {};
                    singleCount[0] = singleCount[rows-1] = 0;
                    var probTopAndBotSingleCellJoin = 0.35;

                    // A count and limit of the number long pieces (i.e. an "L" of size 4 or "T" of size 5)
                    var longPieces = 0;
                    var maxLongPieces = 1;
                    var probExtendAtSize2 = 1;
                    var probExtendAtSize3or4 = 0.5;

                    var fillCell = function(cell) {
                        cell.filled = true;
                        cell.no = numFilled++;
                        cell.group = numGroups;
                    };

                    for (numGroups=0; ; numGroups++) {

                        // find all the leftmost empty cells
                        openCells = getLeftMostEmptyCells();

                        // stop add pieces if there are no more empty cells.
                        numOpenCells = openCells.length;
                        if (numOpenCells == 0) {
                            break;
                        }

                        // choose the center cell to be a random open cell, and fill it.
                        firstCell = cell = openCells[getRandomInt(0,numOpenCells-1)];
                        fillCell(cell);

                        // randomly allow one single-cell piece on the top or bottom of the map.
                        if (cell.x < cols-1 && (cell.y in singleCount) && Math.random() <= probTopAndBotSingleCellJoin) {
                            if (singleCount[cell.y] == 0) {
                                cell.connect[cell.y == 0 ? UP : DOWN] = true;
                                singleCount[cell.y]++;
                                continue;
                            }
                        }

                        // number of cells in this contiguous group
                        size = 1;

                        if (cell.x == cols-1) {
                            // if the first cell is at the right edge, then don't grow it.
                            cell.connect[RIGHT] = true;
                            cell.isRaiseHeightCandidate = true;
                        }
                        else {
                            // only allow the piece to grow to 5 cells at most.
                            while (size < 5) {

                                var stop = false;

                                if (size == 2) {
                                    // With a horizontal 2-cell group, try to turn it into a 4-cell "L" group.
                                    // This is done here because this case cannot be reached when a piece has already grown to size 3.
                                    var c = firstCell;
                                    if (c.x > 0 && c.connect[RIGHT] && c.next[RIGHT] && c.next[RIGHT].next[RIGHT]) {
                                        if (longPieces < maxLongPieces && Math.random() <= probExtendAtSize2) {

                                            c = c.next[RIGHT].next[RIGHT];
                                            var dirs = {};
                                            if (isOpenCell(c,UP)) {
                                                dirs[UP] = true;
                                            }
                                            if (isOpenCell(c,DOWN)) {
                                                dirs[DOWN] = true;
                                            }

                                            if (dirs[UP] && dirs[DOWN]) {
                                                i = [UP,DOWN][getRandomInt(0,1)];
                                            }
                                            else if (dirs[UP]) {
                                                i = UP;
                                            }
                                            else if (dirs[DOWN]) {
                                                i = DOWN;
                                            }
                                            else {
                                                i = undefined;
                                            }

                                            if (i != undefined) {
                                                connectCell(c,LEFT);
                                                fillCell(c);
                                                connectCell(c,i);
                                                fillCell(c.next[i]);
                                                longPieces++;
                                                size+=2;
                                                stop = true;
                                            }
                                        }
                                    }
                                }

                                if (!stop) {
                                    // find available open adjacent cells.
                                    var result = getOpenCells(cell,dir,size);
                                    openCells = result['openCells'];
                                    numOpenCells = result['numOpenCells'];

                                    // if no open cells found from center point, then use the last cell as the new center
                                    // but only do this if we are of length 2 to prevent numerous short pieces.
                                    // then recalculate the open adjacent cells.
                                    if (numOpenCells == 0 && size == 2) {
                                        cell = newCell;
                                        result = getOpenCells(cell,dir,size);
                                        openCells = result['openCells'];
                                        numOpenCells = result['numOpenCells'];
                                    }

                                    // no more adjacent cells, so stop growing this piece.
                                    if (numOpenCells == 0) {
                                        stop = true;
                                    }
                                    else {
                                        // choose a random valid direction to grow.
                                        dir = openCells[getRandomInt(0,numOpenCells-1)];
                                        newCell = cell.next[dir];

                                        // connect the cell to the new cell.
                                        connectCell(cell,dir);

                                        // fill the cell
                                        fillCell(newCell);

                                        // increase the size count of this piece.
                                        size++;

                                        // don't let center pieces grow past 3 cells
                                        if (firstCell.x == 0 && size == 3) {
                                            stop = true;
                                        }

                                        // Use a probability to determine when to stop growing the piece.
                                        if (Math.random() <= probStopGrowingAtSize[size]) {
                                            stop = true;
                                        }
                                    }
                                }

                                // Close the piece.
                                if (stop) {

                                    if (size == 1) {
                                        // This is provably impossible because this loop is never entered with size==1.
                                    }
                                    else if (size == 2) {

                                        // With a vertical 2-cell group, attach to the right wall if adjacent.
                                        var c = firstCell;
                                        if (c.x == cols-1) {

                                            // select the top cell
                                            if (c.connect[UP]) {
                                                c = c.next[UP];
                                            }
                                            c.connect[RIGHT] = c.next[DOWN].connect[RIGHT] = true;
                                        }
                                        
                                    }
                                    else if (size == 3 || size == 4) {

                                        // Try to extend group to have a long leg
                                        if (longPieces < maxLongPieces && firstCell.x > 0 && Math.random() <= probExtendAtSize3or4) {
                                            var dirs = [];
                                            var dirsLength = 0;
                                            for (i=0; i<4; i++) {
                                                if (cell.connect[i] && isOpenCell(cell.next[i],i)) {
                                                    dirs.push(i);
                                                    dirsLength++;
                                                }
                                            }
                                            if (dirsLength > 0) {
                                                i = dirs[getRandomInt(0,dirsLength-1)];
                                                c = cell.next[i];
                                                connectCell(c,i);
                                                fillCell(c.next[i]);
                                                longPieces++;
                                            }
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    }
                    setResizeCandidates();
                };


                var setResizeCandidates = function() {
                    var i;
                    var c,q,c2,q2;
                    var x,y;
                    for (i=0; i<rows*cols; i++) {
                        c = cells[i];
                        x = i % cols;
                        y = Math.floor(i/cols);

                        // determine if it has flexible height

                        //
                        // |_|
                        //
                        // or
                        //  _
                        // | |
                        //
                        q = c.connect;
                        if ((c.x == 0 || !q[LEFT]) &&
                            (c.x == cols-1 || !q[RIGHT]) &&
                            q[UP] != q[DOWN]) {
                            c.isRaiseHeightCandidate = true;
                        }

                        //  _ _
                        // |_ _|
                        //
                        c2 = c.next[RIGHT];
                        if (c2 != undefined) {
                            q2 = c2.connect;
                            if (((c.x == 0 || !q[LEFT]) && !q[UP] && !q[DOWN]) &&
                                ((c2.x == cols-1 || !q2[RIGHT]) && !q2[UP] && !q2[DOWN])
                                ) {
                                c.isRaiseHeightCandidate = c2.isRaiseHeightCandidate = true;
                            }
                        }

                        // determine if it has flexible width

                        // if cell is on the right edge with an opening to the right
                        if (c.x == cols-1 && q[RIGHT]) {
                            c.isShrinkWidthCandidate = true;
                        }

                        //  _
                        // |_
                        // 
                        // or
                        //  _
                        //  _|
                        //
                        if ((c.y == 0 || !q[UP]) &&
                            (c.y == rows-1 || !q[DOWN]) &&
                            q[LEFT] != q[RIGHT]) {
                            c.isShrinkWidthCandidate = true;
                        }

                    }
                };

                // Identify if a cell is the center of a cross.
                var cellIsCrossCenter = function(c) {
                    return c.connect[UP] && c.connect[RIGHT] && c.connect[DOWN] && c.connect[LEFT];
                };

                var chooseNarrowCols = function() {

                    var canShrinkWidth = function(x,y) {

                        // Can cause no more tight turns.
                        if (y==rows-1) {
                            return true;
                        }

                        // get the right-hand-side bound
                        var x0;
                        var c,c2;
                        for (x0=x; x0<cols; x0++) {
                            c = cells[x0+y*cols];
                            c2 = c.next[DOWN]
                            if ((!c.connect[RIGHT] || cellIsCrossCenter(c)) &&
                                (!c2.connect[RIGHT] || cellIsCrossCenter(c2))) {
                                break;
                            }
                        }

                        // build candidate list
                        var candidates = [];
                        var numCandidates = 0;
                        for (; c2; c2=c2.next[LEFT]) {
                            if (c2.isShrinkWidthCandidate) {
                                candidates.push(c2);
                                numCandidates++;
                            }

                            // cannot proceed further without causing irreconcilable tight turns
                            if ((!c2.connect[LEFT] || cellIsCrossCenter(c2)) &&
                                (!c2.next[UP].connect[LEFT] || cellIsCrossCenter(c2.next[UP]))) {
                                break;
                            }
                        }
                        shuffle(candidates);

                        var i;
                        for (i=0; i<numCandidates; i++) {
                            c2 = candidates[i];
                            if (canShrinkWidth(c2.x,c2.y)) {
                                c2.shrinkWidth = true;
                                narrowCols[c2.y] = c2.x;
                                return true;
                            }
                        }

                        return false;
                    };

                    var x;
                    var c;
                    for (x=cols-1; x>=0; x--) {
                        c = cells[x];
                        if (c.isShrinkWidthCandidate && canShrinkWidth(x,0)) {
                            c.shrinkWidth = true;
                            narrowCols[c.y] = c.x;
                            return true;
                        }
                    }

                    return false;
                };

                var chooseTallRows = function() {

                    var canRaiseHeight = function(x,y) {

                        // Can cause no more tight turns.
                        if (x==cols-1) {
                            return true;
                        }

                        // find the first cell below that will create too tight a turn on the right
                        var y0;
                        var c;
                        var c2;
                        for (y0=y; y0>=0; y0--) {
                            c = cells[x+y0*cols];
                            c2 = c.next[RIGHT]
                            if ((!c.connect[UP] || cellIsCrossCenter(c)) && 
                                (!c2.connect[UP] || cellIsCrossCenter(c2))) {
                                break;
                            }
                        }

                        // Proceed from the right cell upwards, looking for a cell that can be raised.
                        var candidates = [];
                        var numCandidates = 0;
                        for (; c2; c2=c2.next[DOWN]) {
                            if (c2.isRaiseHeightCandidate) {
                                candidates.push(c2);
                                numCandidates++;
                            }

                            // cannot proceed further without causing irreconcilable tight turns
                            if ((!c2.connect[DOWN] || cellIsCrossCenter(c2)) &&
                                (!c2.next[LEFT].connect[DOWN] || cellIsCrossCenter(c2.next[LEFT]))) {
                                break;
                            }
                        }
                        shuffle(candidates);

                        var i;
                        for (i=0; i<numCandidates; i++) {
                            c2 = candidates[i];
                            if (canRaiseHeight(c2.x,c2.y)) {
                                c2.raiseHeight = true;
                                tallRows[c2.x] = c2.y;
                                return true;
                            }
                        }

                        return false;
                    };

                    // From the top left, examine cells below until hitting top of ghost house.
                    // A raisable cell must be found before the ghost house.
                    var y;
                    var c;
                    for (y=0; y<3; y++) {
                        c = cells[y*cols];
                        if (c.isRaiseHeightCandidate && canRaiseHeight(0,y)) {
                            c.raiseHeight = true;
                            tallRows[c.x] = c.y;
                            return true;
                        }
                    }

                    return false;
                };

                // This is a function to detect impurities in the map that have no heuristic implemented to avoid it yet in gen().
                var isDesirable = function() {

                    // ensure a solid top right corner
                    var c = cells[4];
                    if (c.connect[UP] || c.connect[RIGHT]) {
                        return false;
                    }

                    // ensure a solid bottom right corner
                    c = cells[rows*cols-1];
                    if (c.connect[DOWN] || c.connect[RIGHT]) {
                        return false;
                    }

                    // ensure there are no two stacked/side-by-side 2-cell pieces.
                    var isHori = function(x,y) {
                        var q1 = cells[x+y*cols].connect;
                        var q2 = cells[x+1+y*cols].connect;
                        return !q1[UP] && !q1[DOWN] && (x==0 || !q1[LEFT]) && q1[RIGHT] && 
                            !q2[UP] && !q2[DOWN] && q2[LEFT] && !q2[RIGHT];
                    };
                    var isVert = function(x,y) {
                        var q1 = cells[x+y*cols].connect;
                        var q2 = cells[x+(y+1)*cols].connect;
                        if (x==cols-1) {
                            // special case (we can consider two single cells as vertical at the right edge)
                            return !q1[LEFT] && !q1[UP] && !q1[DOWN] &&
                                !q2[LEFT] && !q2[UP] && !q2[DOWN];
                        }
                        return !q1[LEFT] && !q1[RIGHT] && !q1[UP] && q1[DOWN] && 
                            !q2[LEFT] && !q2[RIGHT] && q2[UP] && !q2[DOWN];
                    };
                    var x,y;
                    var g;
                    for (y=0; y<rows-1; y++) {
                        for (x=0; x<cols-1; x++) {
                            if (isHori(x,y) && isHori(x,y+1) ||
                                isVert(x,y) && isVert(x+1,y)) {

                                // don't allow them in the middle because they'll be two large when reflected.
                                if (x==0) {
                                    return false;
                                }

                                // Join the four cells to create a square.
                                cells[x+y*cols].connect[DOWN] = true;
                                cells[x+y*cols].connect[RIGHT] = true;
                                g = cells[x+y*cols].group;

                                cells[x+1+y*cols].connect[DOWN] = true;
                                cells[x+1+y*cols].connect[LEFT] = true;
                                cells[x+1+y*cols].group = g;

                                cells[x+(y+1)*cols].connect[UP] = true;
                                cells[x+(y+1)*cols].connect[RIGHT] = true;
                                cells[x+(y+1)*cols].group = g;

                                cells[x+1+(y+1)*cols].connect[UP] = true;
                                cells[x+1+(y+1)*cols].connect[LEFT] = true;
                                cells[x+1+(y+1)*cols].group = g;
                            }
                        }
                    }

                    if (!chooseTallRows()) {
                        return false;
                    }

                    if (!chooseNarrowCols()) {
                        return false;
                    }

                    return true;
                };

                // set the final position and size of each cell when upscaling the simple model to actual size
                var setUpScaleCoords = function() {
                    var i,c;
                    for (i=0; i<rows*cols; i++) {
                        c = cells[i];
                        c.final_x = c.x*3;
                        if (narrowCols[c.y] < c.x) {
                            c.final_x--;
                        }
                        c.final_y = c.y*3;
                        if (tallRows[c.x] < c.y) {
                            c.final_y++;
                        }
                        c.final_w = c.shrinkWidth ? 2 : 3;
                        c.final_h = c.raiseHeight ? 4 : 3;
                    }
                };

                var reassignGroup = function(oldg,newg) {
                    var i;
                    var c;
                    for (i=0; i<rows*cols; i++) {
                        c = cells[i];
                        if (c.group == oldg) {
                            c.group = newg;
                        }
                    }
                };

                var createTunnels = function() {

                    // declare candidates
                    var singleDeadEndCells = [];
                    var topSingleDeadEndCells = [];
                    var botSingleDeadEndCells = [];

                    var voidTunnelCells = [];
                    var topVoidTunnelCells = [];
                    var botVoidTunnelCells = [];

                    var edgeTunnelCells = [];
                    var topEdgeTunnelCells = [];
                    var botEdgeTunnelCells = [];

                    var doubleDeadEndCells = [];

                    var numTunnelsCreated = 0;

                    // prepare candidates
                    var y;
                    var c;
                    var upDead;
                    var downDead;
                    for (y=0; y<rows; y++) {
                        c = cells[cols-1+y*cols];
                        if (c.connect[UP]) {
                            continue;
                        }
                        if (c.y > 1 && c.y < rows-2) {
                            c.isEdgeTunnelCandidate = true;
                            edgeTunnelCells.push(c);
                            if (c.y <= 2) {
                                topEdgeTunnelCells.push(c);
                            }
                            else if (c.y >= 5) {
                                botEdgeTunnelCells.push(c);
                            }
                        }
                        upDead = (!c.next[UP] || c.next[UP].connect[RIGHT]);
                        downDead = (!c.next[DOWN] || c.next[DOWN].connect[RIGHT]);
                        if (c.connect[RIGHT]) {
                            if (upDead) {
                                c.isVoidTunnelCandidate = true;
                                voidTunnelCells.push(c);
                                if (c.y <= 2) {
                                    topVoidTunnelCells.push(c);
                                }
                                else if (c.y >= 6) {
                                    botVoidTunnelCells.push(c);
                                }
                            }
                        }
                        else {
                            if (c.connect[DOWN]) {
                                continue;
                            }
                            if (upDead != downDead) {
                                if (!c.raiseHeight && y < rows-1 && !c.next[LEFT].connect[LEFT]) {
                                    singleDeadEndCells.push(c);
                                    c.isSingleDeadEndCandidate = true;
                                    c.singleDeadEndDir = upDead ? UP : DOWN;
                                    var offset = upDead ? 1 : 0;
                                    if (c.y <= 1+offset) {
                                        topSingleDeadEndCells.push(c);
                                    }
                                    else if (c.y >= 5+offset) {
                                        botSingleDeadEndCells.push(c);
                                    }
                                }
                            }
                            else if (upDead && downDead) {
                                if (y > 0 && y < rows-1) {
                                    if (c.next[LEFT].connect[UP] && c.next[LEFT].connect[DOWN]) {
                                        c.isDoubleDeadEndCandidate = true;
                                        if (c.y >= 2 && c.y <= 5) {
                                            doubleDeadEndCells.push(c);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // choose tunnels from candidates
                    var numTunnelsDesired = Math.random() <= 0.45 ? 2 : 1;
                    var c;
                    var selectSingleDeadEnd = function(c) {
                        c.connect[RIGHT] = true;
                        if (c.singleDeadEndDir == UP) {
                            c.topTunnel = true;
                        }
                        else {
                            c.next[DOWN].topTunnel = true;
                        }
                    };
                    if (numTunnelsDesired == 1) {
                        if (c = randomElement(voidTunnelCells)) {
                            c.topTunnel = true;
                        }
                        else if (c = randomElement(singleDeadEndCells)) {
                            selectSingleDeadEnd(c);
                        }
                        else if (c = randomElement(edgeTunnelCells)) {
                            c.topTunnel = true;
                        }
                        else {
                            return false;
                        }
                    }
                    else if (numTunnelsDesired == 2) {
                        if (c = randomElement(doubleDeadEndCells)) {
                            c.connect[RIGHT] = true;
                            c.topTunnel = true;
                            c.next[DOWN].topTunnel = true;
                        }
                        else {
                            numTunnelsCreated = 1;
                            if (c = randomElement(topVoidTunnelCells)) {
                                c.topTunnel = true;
                            }
                            else if (c = randomElement(topSingleDeadEndCells)) {
                                selectSingleDeadEnd(c);
                            }
                            else if (c = randomElement(topEdgeTunnelCells)) {
                                c.topTunnel = true;
                            }
                            else {
                                // could not find a top tunnel opening
                                numTunnelsCreated = 0;
                            }

                            if (c = randomElement(botVoidTunnelCells)) {
                                c.topTunnel = true;
                            }
                            else if (c = randomElement(botSingleDeadEndCells)) {
                                selectSingleDeadEnd(c);
                            }
                            else if (c = randomElement(botEdgeTunnelCells)) {
                                c.topTunnel = true;
                            }
                            else {
                                // could not find a bottom tunnel opening
                                if (numTunnelsCreated == 0) {
                                    return false;
                                }
                            }
                        }
                    }

                    // don't allow a horizontal path to cut straight through a map (through tunnels)
                    var exit,topy;
                    for (y=0; y<rows; y++) {
                        c = cells[cols-1+y*cols];
                        if (c.topTunnel) {
                            exit = true;
                            topy = c.final_y;
                            while (c.next[LEFT]) {
                                c = c.next[LEFT];
                                if (!c.connect[UP] && c.final_y == topy) {
                                    continue;
                                }
                                else {
                                    exit = false;
                                    break;
                                }
                            }
                            if (exit) {
                                return false;
                            }
                        }
                    }

                    // clear unused void tunnels (dead ends)
                    var len = voidTunnelCells.length;
                    var i;

                    var replaceGroup = function(oldg,newg) {
                        var i,c;
                        for (i=0; i<rows*cols; i++) {
                            c = cells[i];
                            if (c.group == oldg) {
                                c.group = newg;
                            }
                        }
                    };
                    for (i=0; i<len; i++) {
                        c = voidTunnelCells[i];
                        if (!c.topTunnel) {
                            replaceGroup(c.group, c.next[UP].group);
                            c.connect[UP] = true;
                            c.next[UP].connect[DOWN] = true;
                        }
                    }

                    return true;
                };

                var joinWalls = function() {

                    // randomly join wall pieces to the boundary to increase difficulty

                    var x,y;
                    var c;

                    // join cells to the top boundary
                    for (x=0; x<cols; x++) {
                        c = cells[x];
                        if (!c.connect[LEFT] && !c.connect[RIGHT] && !c.connect[UP] &&
                            (!c.connect[DOWN] || !c.next[DOWN].connect[DOWN])) {

                            // ensure it will not create a dead-end
                            if ((!c.next[LEFT] || !c.next[LEFT].connect[UP]) &&
                                (c.next[RIGHT] && !c.next[RIGHT].connect[UP])) {

                                // prevent connecting very large piece
                                if (!(c.next[DOWN] && c.next[DOWN].connect[RIGHT] && c.next[DOWN].next[RIGHT].connect[RIGHT])) {
                                    c.isJoinCandidate = true;
                                    if (Math.random() <= 0.25) {
                                        c.connect[UP] = true;
                                    }
                                }
                            }
                        }
                    }

                    // join cells to the bottom boundary
                    for (x=0; x<cols; x++) {
                        c = cells[x+(rows-1)*cols];
                        if (!c.connect[LEFT] && !c.connect[RIGHT] && !c.connect[DOWN] &&
                            (!c.connect[UP] || !c.next[UP].connect[UP])) {

                            // ensure it will not creat a dead-end
                            if ((!c.next[LEFT] || !c.next[LEFT].connect[DOWN]) &&
                                (c.next[RIGHT] && !c.next[RIGHT].connect[DOWN])) {

                                // prevent connecting very large piece
                                if (!(c.next[UP] && c.next[UP].connect[RIGHT] && c.next[UP].next[RIGHT].connect[RIGHT])) {
                                    c.isJoinCandidate = true;
                                    if (Math.random() <= 0.25) {
                                        c.connect[DOWN] = true;
                                    }
                                }
                            }
                        }
                    }

                    // join cells to the right boundary
                    var c2;
                    for (y=1; y<rows-1; y++) {
                        c = cells[cols-1+y*cols];
                        if (c.raiseHeight) {
                            continue;
                        }
                        if (!c.connect[RIGHT] && !c.connect[UP] && !c.connect[DOWN] &&
                            !c.next[UP].connect[RIGHT] && !c.next[DOWN].connect[RIGHT]) {
                            if (c.connect[LEFT]) {
                                c2 = c.next[LEFT];
                                if (!c2.connect[UP] && !c2.connect[DOWN] && !c2.connect[LEFT]) {
                                    c.isJoinCandidate = true;
                                    if (Math.random() <= 0.5) {
                                        c.connect[RIGHT] = true;
                                    }
                                }
                            }
                        }
                    }
                };

                // try to generate a valid map, and keep count of tries.
                var genCount = 0;
                while (true) {
                    reset();
                    gen();
                    genCount++;
                    if (!isDesirable()) {
                        continue;
                    }

                    setUpScaleCoords();
                    joinWalls();
                    if (!createTunnels()) {
                        continue;
                    }

                    break;
                }

            };

            // Transform the simple cells to a tile array used for creating the map.
            var getTiles = function() {

                var tiles = []; // each is a character indicating a wall(|), path(.), or blank(_).
                var tileCells = []; // maps each tile to a specific cell of our simple map
                var subrows = rows*3+1+3;
                var subcols = cols*3-1+2;

                var midcols = subcols-2;
                var fullcols = (subcols-2)*2;

                // getter and setter for tiles (ensures vertical symmetry axis)
                var setTile = function(x,y,v) {
                    if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {
                        return;
                    }
                    x -= 2;
                    tiles[midcols+x+y*fullcols] = v;
                    tiles[midcols-1-x+y*fullcols] = v;
                };
                var getTile = function(x,y) {
                    if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {
                        return undefined;
                    }
                    x -= 2;
                    return tiles[midcols+x+y*fullcols];
                };

                // getter and setter for tile cells
                var setTileCell = function(x,y,cell) {
                    if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {
                        return;
                    }
                    x -= 2;
                    tileCells[x+y*subcols] = cell;
                };
                var getTileCell = function(x,y) {
                    if (x<0 || x>subcols-1 || y<0 || y>subrows-1) {
                        return undefined;
                    }
                    x -= 2;
                    return tileCells[x+y*subcols];
                };

                // initialize tiles
                var i;
                for (i=0; i<subrows*fullcols; i++) {
                    tiles.push('_');
                }
                for (i=0; i<subrows*subcols; i++) {
                    tileCells.push(undefined);
                }

                // set tile cells
                var c;
                var x,y,w,h;
                var x0,y0;
                for (i=0; i<rows*cols; i++) {
                    c = cells[i];
                    for (x0=0; x0<c.final_w; x0++) {
                        for (y0=0; y0<c.final_h; y0++) {
                            setTileCell(c.final_x+x0,c.final_y+1+y0,c);
                        }
                    }
                }

                // set path tiles
                var cl, cu;
                for (y=0; y<subrows; y++) {
                    for (x=0; x<subcols; x++) {
                        c = getTileCell(x,y); // cell
                        cl = getTileCell(x-1,y); // left cell
                        cu = getTileCell(x,y-1); // up cell

                        if (c) {
                            // inside map
                            if (cl && c.group != cl.group || // at vertical boundary
                                cu && c.group != cu.group || // at horizontal boundary
                                !cu && !c.connect[UP]) { // at top boundary
                                setTile(x,y,'.');
                            }
                        }
                        else {
                            // outside map
                            if (cl && (!cl.connect[RIGHT] || getTile(x-1,y) == '.') || // at right boundary
                                cu && (!cu.connect[DOWN] || getTile(x,y-1) == '.')) { // at bottom boundary
                                setTile(x,y,'.');
                            }
                        }

                        // at corner connecting two paths
                        if (getTile(x-1,y) == '.' && getTile(x,y-1) == '.' && getTile(x-1,y-1) == '_') {
                            setTile(x,y,'.');
                        }
                    }
                }

                // extend tunnels
                var y;
                for (c=cells[cols-1]; c; c = c.next[DOWN]) {
                    if (c.topTunnel) {
                        y = c.final_y+1;
                        setTile(subcols-1, y,'.');
                        setTile(subcols-2, y,'.');
                    }
                }

                // fill in walls
                for (y=0; y<subrows; y++) {
                    for (x=0; x<subcols; x++) {
                        // any blank tile that shares a vertex with a path tile should be a wall tile
                        if (getTile(x,y) != '.' && (getTile(x-1,y) == '.' || getTile(x,y-1) == '.' || getTile(x+1,y) == '.' || getTile(x,y+1) == '.' ||
                            getTile(x-1,y-1) == '.' || getTile(x+1,y-1) == '.' || getTile(x+1,y+1) == '.' || getTile(x-1,y+1) == '.')) {
                            setTile(x,y,'|');
                        }
                    }
                }

                // create the ghost door
                setTile(2,12,'-');

                // set energizers
                var getTopEnergizerRange = function() {
                    var miny;
                    var maxy = subrows/2;
                    var x = subcols-2;
                    var y;
                    for (y=2; y<maxy; y++) {
                        if (getTile(x,y) == '.' && getTile(x,y+1) == '.') {
                            miny = y+1;
                            break;
                        }
                    }
                    maxy = Math.min(maxy,miny+7);
                    for (y=miny+1; y<maxy; y++) {
                        if (getTile(x-1,y) == '.') {
                            maxy = y-1;
                            break;
                        }
                    }
                    return {miny:miny, maxy:maxy};
                };
                var getBotEnergizerRange = function() {
                    var miny = subrows/2;
                    var maxy;
                    var x = subcols-2;
                    var y;
                    for (y=subrows-3; y>=miny; y--) {
                        if (getTile(x,y) == '.' && getTile(x,y+1) == '.') {
                            maxy = y;
                            break;
                        }
                    }
                    miny = Math.max(miny,maxy-7);
                    for (y=maxy-1; y>miny; y--) {
                        if (getTile(x-1,y) == '.') {
                            miny = y+1;
                            break;
                        }
                    }
                    return {miny:miny, maxy:maxy};
                };
                var x = subcols-2;
                var y;
                var range;
                if (range = getTopEnergizerRange()) {
                    y = getRandomInt(range.miny, range.maxy);
                    setTile(x,y,'o');
                }
                if (range = getBotEnergizerRange()) {
                    y = getRandomInt(range.miny, range.maxy);
                    setTile(x,y,'o');
                }

                // erase pellets in the tunnels
                var eraseUntilIntersection = function(x,y) {
                    var adj;
                    while (true) {
                        adj = [];
                        if (getTile(x-1,y) == '.') {
                            adj.push({x:x-1,y:y});
                        }
                        if (getTile(x+1,y) == '.') {
                            adj.push({x:x+1,y:y});
                        }
                        if (getTile(x,y-1) == '.') {
                            adj.push({x:x,y:y-1});
                        }
                        if (getTile(x,y+1) == '.') {
                            adj.push({x:x,y:y+1});
                        }
                        if (adj.length == 1) {
                            setTile(x,y,' ');
                            x = adj[0].x;
                            y = adj[0].y;
                        }
                        else {
                            break;
                        }
                    }
                };
                x = subcols-1;
                for (y=0; y<subrows; y++) {
                    if (getTile(x,y) == '.') {
                        eraseUntilIntersection(x,y);
                    }
                }

                // erase pellets on starting position
                setTile(1,subrows-8,' ');

                // erase pellets around the ghost house
                var i,j;
                var y;
                for (i=0; i<7; i++) {

                    // erase pellets from bottom of the ghost house proceeding down until
                    // reaching a pellet tile that isn't surround by walls
                    // on the left and right
                    y = subrows-14;
                    setTile(i, y, ' ');
                    j = 1;
                    while (getTile(i,y+j) == '.' &&
                            getTile(i-1,y+j) == '|' &&
                            getTile(i+1,y+j) == '|') {
                        setTile(i,y+j,' ');
                        j++;
                    }

                    // erase pellets from top of the ghost house proceeding up until
                    // reaching a pellet tile that isn't surround by walls
                    // on the left and right
                    y = subrows-20;
                    setTile(i, y, ' ');
                    j = 1;
                    while (getTile(i,y-j) == '.' &&
                            getTile(i-1,y-j) == '|' &&
                            getTile(i+1,y-j) == '|') {
                        setTile(i,y-j,' ');
                        j++;
                    }
                }
                // erase pellets on the side of the ghost house
                for (i=0; i<7; i++) {

                    // erase pellets from side of the ghost house proceeding right until
                    // reaching a pellet tile that isn't surround by walls
                    // on the top and bottom.
                    x = 6;
                    y = subrows-14-i;
                    setTile(x, y, ' ');
                    j = 1;
                    while (getTile(x+j,y) == '.' &&
                            getTile(x+j,y-1) == '|' &&
                            getTile(x+j,y+1) == '|') {
                        setTile(x+j,y,' ');
                        j++;
                    }
                }

                // return a tile string (3 empty lines on top and 2 on bottom)
                return (
                    "____________________________" +
                    "____________________________" +
                    "____________________________" +
                    tiles.join("") +
                    "____________________________" +
                    "____________________________");
            };

            var randomColor = function() {
                return '#'+('00000'+(Math.random()*(1<<24)|0).toString(16)).slice(-6);
            };

            // dijkstra's algorithm to find shortest path to all tiles from (x0,y0)
            // we also remove (destroyX,destroyY) from the map to try to constrain the path
            // from going a certain way from the start.
            // (We created this because the ghost's minimum distance direction is not always sufficient in procedural maps)
            var getShortestDistGraph = function(map,x0,y0,isNodeTile) {

                // build graph
                var graph = {};
                var x,y,i,j;
                for (y=0; y<36; y++) {
                    for (x=0; x<28; x++) {
                        if (isNodeTile(x,y)) {
                            i = x+y*28;
                            graph[i] = {'x':x, 'y':y, 'dist':Infinity, 'penult':undefined, 'neighbors':[], 'completed':false};
                            if (isNodeTile(x-1,y)) {
                                j = i-1;
                                graph[i].neighbors.push(graph[j]);
                                graph[j].neighbors.push(graph[i]);
                            }
                            if (isNodeTile(x,y-1)) {
                                j = i-28;
                                graph[i].neighbors.push(graph[j]);
                                graph[j].neighbors.push(graph[i]);
                            }
                        }
                    }
                }

                var node = graph[x0+y0*28];
                node.completed = true;
                node.dist = 0;
                var d;
                var next_node,min_dist,dist;
                while (true) {

                    // update distances of current node's neighbors
                    for (i=0; i<4; i++) {
                        d = node.neighbors[i];
                        if (d && !d.completed) {
                            dist = node.dist+1;
                            if (dist == d.dist) {
                                if (Math.random() < 0.5) {
                                    d.penult = node;
                                }
                            }
                            else if (dist < d.dist) {
                                d.dist = dist;
                                d.penult = node;
                            }
                        }
                    }

                    // find next node to process (closest fringe node)
                    next_node = undefined;
                    min_dist = Infinity;
                    for (i=0; i<28*36; i++) {
                        d = graph[i];
                        if (d && !d.completed) {
                            if (d.dist < min_dist) { 
                                next_node = d;
                                min_dist = d.dist;
                            }
                        }
                    }

                    if (!next_node) {
                        break;
                    }

                    node = next_node;
                    node.completed = true;
                }

                return graph;
            };

            // retrieves the direction enum from a node's penultimate node to itself.
            var getDirFromPenult = function(node) {
                if (!node.penult) {
                    return undefined;
                }
                var dx = node.x - node.penult.x;
                var dy = node.y - node.penult.y;
                if (dy == -1) {
                    return DIR_UP;
                }
                else if (dy == 1) {
                    return DIR_DOWN;
                }
                else if (dx == -1) {
                    return DIR_LEFT;
                }
                else if (dx == 1) {
                    return DIR_RIGHT;
                }
            };

            // sometimes the ghosts can get stuck in loops when trying to return home
            // so we build a path from all tiles to the ghost door tile
            var makeExitPaths = function(map) {
                var isNodeTile = function(x,y) {
                    if (x<0 || x>=28 || y<0 || y>=36) {
                        return false;
                    }
                    return map.isFloorTile(x,y);
                };
                var graph = getShortestDistGraph(map,map.doorTile.x,map.doorTile.y,isNodeTile);

                // give the map a function that tells the ghost which direction to go to return home
                map.getExitDir = function(x,y) {
                    if (x<0 || x>=28 || y<0 || y>=36) {
                        return undefined;
                    }
                    var node = graph[x+y*28];
                    var dirEnum = getDirFromPenult(node);
                    if (dirEnum != undefined) {
                        return rotateAboutFace(dirEnum); // reverse direction (door->ghost to door<-ghost)
                    }
                };
            };

            // add fruit paths to a map
            var makeFruitPaths = (function(){
                var reversed = {
                    'v':'^',
                    '^':'v',
                    '<':'>',
                    '>':'<',
                };
                var reversePath = function(path) {
                    var rpath = "";
                    var i;
                    for (i=path.length-1; i>=0; i--) {
                        rpath += reversed[path[i]];
                    }
                    return rpath;
                };

                var dirChars = {};
                dirChars[DIR_UP] = '^';
                dirChars[DIR_DOWN] = 'v';
                dirChars[DIR_LEFT] = '<';
                dirChars[DIR_RIGHT] = '>';

                var getPathFromGraph = function(graph,x0,y0,x1,y1,reverse) {
                    // from (x0,y0) to (x1,y1)
                    var start_node = graph[x0+y0*28];
                    var dx,dy;
                    var path = "";
                    var node;
                    for (node=graph[x1+y1*28]; node!=start_node; node=node.penult) {
                        path = dirChars[getDirFromPenult(node)] + path;
                    }
                    return reverse ? reversePath(path) : path;
                }

                return function(map) {

                    paths = {entrances:[], exits:[]};

                    var isFloorTile = function(x,y) {
                        if (x<0 || x>=28 || y<0 || y>=36) {
                            return false
                        }
                        return map.isFloorTile(x,y);
                    };

                    enter_graph = getShortestDistGraph(map,15,20, function(x,y) { return (x==14 && y==20) ? false : isFloorTile(x,y); });
                    exit_graph =  getShortestDistGraph(map,16,20, function(x,y) { return (x==17 && y==20) ? false : isFloorTile(x,y); });

                    // start at (15,20)
                    for (y=0; y<36; y++) {
                        if (map.isFloorTile(-1,y)) {

                            // left entrance
                            paths.entrances.push({
                                'start': {'y':y*8+4, 'x': -4},
                                'path': '>'+getPathFromGraph(enter_graph, 15,20, 0,y, true)});

                            // right entrance
                            paths.entrances.push({
                                'start': {'y':y*8+4, 'x': 28*8+4},
                                'path': '<'+getPathFromGraph(enter_graph, 15,20, 27,y, true)});

                            // left exit
                            paths.exits.push({
                                'start': {'y':y*8+4, 'x': -4},
                                'path': getPathFromGraph(exit_graph, 16,20, 0,y, false)+'<'});

                            // right exit
                            paths.exits.push({
                                'start': {'y':y*8+4, 'x': 28*8+4},
                                'path': getPathFromGraph(exit_graph, 16,20, 27,y, false)+'>'});
                        }
                    }

                    map.fruitPaths = paths;
                };
            })();

            return function() {
                genRandom();
                var map = new Map(28,36,getTiles());

                makeFruitPaths(map);
                makeExitPaths(map);

                map.name = "Random Map";
                map.wallFillColor = randomColor();
                map.wallStrokeColor = rgbString(hslToRgb(Math.random(), Math.random(), Math.random() * 0.4 + 0.6));
                map.pelletColor = "#ffb8ae";

                return map;
            };
            })();
            //@line 1 "src/atlas.js"

            var atlas = (function(){

            var canvas,ctx;
            var size = 22;
            var cols = 14; // has to be ONE MORE than intended to fix some sort of CHROME BUG (last cell always blank?)
            var rows = 22;

            var creates = 0;

            var drawGrid = function() {
                // draw grid overlay
                var canvas = document.getElementById('gridcanvas');
                if (!canvas) {
                    return;
                }
                var w = size*cols*renderScale;
                var h = size*rows*renderScale;
                canvas.width = w;
                canvas.height = h;
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,w,h);
                var x,y;
                var step = size*renderScale;
                ctx.beginPath();
                for (x=0; x<=w; x+=step) {
                    ctx.moveTo(x,0);
                    ctx.lineTo(x,h);
                }
                for (y=0; y<=h; y+=step) {
                    ctx.moveTo(0,y);
                    ctx.lineTo(w,y);
                }
                ctx.lineWidth = "1px";
                ctx.lineCap = "square";
                ctx.strokeStyle="rgba(255,255,255,0.5)";
                ctx.stroke();
            };

            var create = function() {
                drawGrid();
                canvas = document.getElementById('atlas');
                ctx = canvas.getContext("2d");
                /*
                canvas.style.left = 0;
                canvas.style.top = 0;
                canvas.style.position = "absolute";
                */

                var w = size*cols*renderScale;
                var h = size*rows*renderScale;
                canvas.width = w;
                canvas.height = h;

                if (creates > 0) {
                    ctx.restore();
                }
                creates++;

                ctx.save();
                ctx.clearRect(0,0,w,h);
                ctx.scale(renderScale,renderScale);

                var drawAtCell = function(f,row,col) {
                    var x = col*size + size/2;
                    var y = row*size + size/2;
                    f(x,y);
                };

                var row = 0;
                drawAtCell(function(x,y) { drawCherry(ctx,x,y); },      row,0);
                drawAtCell(function(x,y) { drawStrawberry(ctx,x,y); },  row,1);
                drawAtCell(function(x,y) { drawOrange(ctx,x,y); },      row,2);
                drawAtCell(function(x,y) { drawApple(ctx,x,y); },       row,3);
                drawAtCell(function(x,y) { drawMelon(ctx,x,y); },       row,4);
                drawAtCell(function(x,y) { drawGalaxian(ctx,x,y); },    row,5);
                drawAtCell(function(x,y) { drawBell(ctx,x,y); },        row,6);
                drawAtCell(function(x,y) { drawKey(ctx,x,y); },         row,7);
                drawAtCell(function(x,y) { drawPretzel(ctx,x,y); },     row,8);
                drawAtCell(function(x,y) { drawPear(ctx,x,y); },        row,9);
                drawAtCell(function(x,y) { drawBanana(ctx,x,y); },      row,10);
                drawAtCell(function(x,y) { drawCookie(ctx,x,y); },      row,11);
                drawAtCell(function(x,y) { drawCookieFlash(ctx,x,y); },      row,12);

                var drawGhostCells = function(row,color) {
                    var i,f;
                    var col = 0;
                    for (i=0; i<4; i++) { // dirEnum
                        for (f=0; f<2; f++) { // frame
                            drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, f, i, false, false, false, color); },   row,col);
                            col++;
                        }
                    }
                };

                row++;
                drawGhostCells(row, "#FF0000");
                row++;
                drawGhostCells(row, "#FFB8FF");
                row++;
                drawGhostCells(row, "#00FFFF");
                row++;
                drawGhostCells(row, "#FFB851");

                row++;
                // draw disembodied eyes
                (function(){
                    var i;
                    var col = 0;
                    for (i=0; i<4; i++) { // dirEnum
                        drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, 0, i, false, false, true, "#fff"); },     row,col);
                        col++;
                    }
                })();

                // draw ghosts scared
                drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, 0, DIR_UP, true, false, false, "#fff"); }, row,4);
                drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, 1, DIR_UP, true, false, false, "#fff"); }, row,5);
                drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, 0, DIR_UP, true, true, false, "#fff"); },  row,6);
                drawAtCell(function(x,y) { drawGhostSprite(ctx, x,y, 1, DIR_UP, true, true, false, "#fff"); },  row,7);

                var drawPacCells = function(row,col,dir) {
                    drawAtCell(function(x,y) { drawPacmanSprite(ctx, x,y, dir, Math.PI/6); }, row, col);
                    drawAtCell(function(x,y) { drawPacmanSprite(ctx, x,y, dir, Math.PI/3); }, row, col+1);
                };
                row++;

                // draw pacman mouth closed
                drawAtCell(function(x,y) { drawPacmanSprite(ctx, x,y, DIR_RIGHT, 0); }, row, 0);

                // draw pacman directions
                (function(){
                    var i;
                    var col=1;
                    for (i=0; i<4; i++) {
                        drawPacCells(row,col,i);
                        col+=2;
                    }
                })();

                var drawMsPacCells = function(row,col,dir) {
                    drawAtCell(function(x,y) { drawMsPacmanSprite(ctx, x,y, dir, 0); }, row, col);
                    drawAtCell(function(x,y) { drawMsPacmanSprite(ctx, x,y, dir, 1); }, row, col+1);
                    drawAtCell(function(x,y) { drawMsPacmanSprite(ctx, x,y, dir, 2); }, row, col+2);
                };
                row++;
                (function(){
                    var i;
                    var col=0;
                    for (i=0; i<4; i++) {
                        drawMsPacCells(row,col,i);
                        col+=3;
                    }
                })();

                var drawCookieCells = function(row,col,dir) {
                    drawAtCell(function(x,y) { drawCookiemanSprite(ctx, x,y, dir, 0, true); }, row, col);
                    drawAtCell(function(x,y) { drawCookiemanSprite(ctx, x,y, dir, 1, true); }, row, col+1);
                    drawAtCell(function(x,y) { drawCookiemanSprite(ctx, x,y, dir, 2, true); }, row, col+2);
                };
                row++;
                (function(){
                    var i;
                    var col=0;
                    for (i=0; i<4; i++) {
                        drawCookieCells(row,col,i);
                        col+=3;
                    }
                })();

                var drawMonsterCells = function(row,color) {
                    var i,f;
                    var col=0;
                    for (i=0; i<4; i++) { // dirEnum
                        for (f=0; f<2; f++) { // frame
                            drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, f, i, false, false, false, color); },   row,col);
                            col++;
                        }
                    }
                };

                row++;
                drawMonsterCells(row, "#FF0000");
                row++;
                drawMonsterCells(row, "#FFB8FF");
                row++;
                drawMonsterCells(row, "#00FFFF");
                row++;
                drawMonsterCells(row, "#FFB851");

                row++;
                (function(){
                    var i;
                    var col = 0;
                    for (i=0; i<4; i++) { // dirEnum
                        drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, 0, i, false, false, true, "#fff"); },     row,col);
                        col++;
                    }
                })();
                drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, 0, DIR_UP, true, false, false, "#fff"); }, row,4);
                drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, 1, DIR_UP, true, false, false, "#fff"); }, row,5);
                drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, 0, DIR_UP, true, true, false, "#fff"); },  row,6);
                drawAtCell(function(x,y) { drawMonsterSprite(ctx, x,y, 1, DIR_UP, true, true, false, "#fff"); },  row,7);

                var drawOttoCells = function(row,col,dir) {
                    var i;
                    for (i=0; i<4; i++) { // frame
                        drawAtCell(function(x,y) { drawOttoSprite(ctx, x,y, dir, i); }, row, col);
                        col++;
                    }
                };
                row++;
                drawOttoCells(row,0, DIR_UP);
                drawOttoCells(row,4, DIR_RIGHT);
                row++;
                drawOttoCells(row,0, DIR_DOWN);
                drawOttoCells(row,4, DIR_LEFT);

                row++;
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 200, "#33ffff"); }, row, 0);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 400, "#33ffff"); }, row, 1);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 800, "#33ffff"); }, row, 2);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 1600, "#33ffff");}, row, 3);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 100, "#ffb8ff"); }, row, 4);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 300, "#ffb8ff"); }, row, 5);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 500, "#ffb8ff"); }, row, 6);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 700, "#ffb8ff"); }, row, 7);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 1000, "#ffb8ff"); }, row, 8);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 2000, "#ffb8ff"); }, row, 9);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 3000, "#ffb8ff"); }, row, 10);
                drawAtCell(function(x,y) { drawPacPoints(ctx, x,y, 5000, "#ffb8ff"); }, row, 11);
                row++;
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 100, "#fff"); }, row, 0);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 200, "#fff"); }, row, 1);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 500, "#fff"); }, row, 2);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 700, "#fff"); }, row, 3);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 1000, "#fff"); }, row, 4);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 2000, "#fff"); }, row, 5);
                drawAtCell(function(x,y) { drawMsPacPoints(ctx, x,y, 5000, "#fff"); }, row, 6);

                row++;
                drawAtCell(function(x,y) {
                    drawSnail(ctx,x,y, "#0ff");
                }, row, 0);
                drawAtCell(function(x,y) {
                    drawSnail(ctx,x,y, "#FFF");
                }, row, 1);

                var drawMsOttoCells = function(row,col,dir) {
                    var i;
                    for (i=0; i<4; i++) { // frame
                        drawAtCell(function(x,y) { drawMsOttoSprite(ctx, x,y, dir, i); }, row, col);
                        col++;
                    }
                };
                row++;
                drawMsOttoCells(row,0, DIR_UP);
                drawMsOttoCells(row,4, DIR_RIGHT);
                row++;
                drawMsOttoCells(row,0, DIR_DOWN);
                drawMsOttoCells(row,4, DIR_LEFT);

            };

            var copyCellTo = function(row, col, destCtx, x, y,display) {
                var sx = col*size*renderScale;
                var sy = row*size*renderScale;
                var sw = renderScale*size;
                var sh = renderScale*size;

                var dx = x - size/2;
                var dy = y - size/2;
                var dw = size;
                var dh = size;

                if (display) {
                    console.log(sx,sy,sw,sh,dw,dy,dw,dh);
                }

                destCtx.drawImage(canvas,sx,sy,sw,sh,dx,dy,dw,dh);
            };

            var copyGhostPoints = function(destCtx,x,y,points) {
                var row = 16;
                var col = {
                    200: 0,
                    400: 1,
                    800: 2,
                    1600: 3,
                }[points];
                if (col != undefined) {
                    copyCellTo(row, col, destCtx, x, y);
                }
            };

            var copyPacFruitPoints = function(destCtx,x,y,points) {
                var row = 16;
                var col = {
                    100: 4,
                    300: 5,
                    500: 6,
                    700: 7,
                    1000: 8,
                    2000: 9,
                    3000: 10,
                    5000: 11,
                }[points];
                if (col != undefined) {
                    copyCellTo(row, col, destCtx, x, y);
                }
            };

            var copyMsPacFruitPoints = function(destCtx,x,y,points) {
                var row = 17;
                var col = {
                    100: 0,
                    200: 1,
                    500: 2,
                    700: 3,
                    1000: 4,
                    2000: 5,
                    5000: 6,
                }[points];
                if (col != undefined) {
                    copyCellTo(row, col, destCtx, x, y);
                }
            };

            var copyGhostSprite = function(destCtx,x,y,frame,dirEnum,scared,flash,eyes_only,color) {
                var row,col;
                if (eyes_only) {
                    row = 5;
                    col = dirEnum;
                }
                else if (scared) {
                    row = 5;
                    col = flash ? 6 : 4;
                    col += frame;
                }
                else {
                    col = dirEnum*2 + frame;
                    if (color == blinky.color) {
                        row = 1;
                    }
                    else if (color == pinky.color) {
                        row = 2;
                    }
                    else if (color == inky.color) {
                        row = 3;
                    }
                    else if (color == clyde.color) {
                        row = 4;
                    }
                    else {
                        row = 5;
                    }
                }

                copyCellTo(row, col, destCtx, x, y);
            };

            var copyMuppetSprite = function(destCtx,x,y,frame,dirEnum,scared,flash,eyes_only,color) {
                if (scared) {
                    if (flash) {
                        copyFruitSprite(destCtx,x,y,"cookieface");
                    }
                    else {
                        copyFruitSprite(destCtx,x,y,"cookie");
                    }
                }
                else {
                    copyGhostSprite(destCtx,x,y,frame,dirEnum,scared,flash,eyes_only,color);
                }
            };

            var copyMonsterSprite = function(destCtx,x,y,frame,dirEnum,scared,flash,eyes_only,color) {
                var row,col;
                if (eyes_only) {
                    row = 13;
                    col = dirEnum;
                }
                else if (scared) {
                    row = 13;
                    col = flash ? 6 : 4;
                    col += frame;
                }
                else {
                    col = dirEnum*2 + frame;
                    if (color == blinky.color) {
                        row = 9;
                    }
                    else if (color == pinky.color) {
                        row = 10;
                    }
                    else if (color == inky.color) {
                        row = 11;
                    }
                    else if (color == clyde.color) {
                        row = 12;
                    }
                    else {
                        row = 13;
                    }
                }

                copyCellTo(row, col, destCtx, x, y);
            };

            var copyOttoSprite = function(destCtx,x,y,dirEnum,frame) {
                var col,row;
                if (dirEnum == DIR_UP) {
                    col = frame;
                    row = 14;
                }
                else if (dirEnum == DIR_RIGHT) {
                    col = frame+4;
                    row = 14;
                }
                else if (dirEnum == DIR_DOWN) {
                    col = frame;
                    row = 15;
                }
                else if (dirEnum == DIR_LEFT) {
                    col = frame+4;
                    row = 15;
                }
                copyCellTo(row,col,destCtx,x,y);
            };

            var copyMsOttoSprite = function(destCtx,x,y,dirEnum,frame) {
                var col,row;
                if (dirEnum == DIR_UP) {
                    col = frame;
                    row = 19;
                }
                else if (dirEnum == DIR_RIGHT) {
                    col = frame+4;
                    row = 19;
                }
                else if (dirEnum == DIR_DOWN) {
                    col = frame;
                    row = 20;
                }
                else if (dirEnum == DIR_LEFT) {
                    col = frame+4;
                    row = 20;
                }
                copyCellTo(row,col,destCtx,x,y);
            };

            var copySnail = function(destCtx,x,y,frame) {
                var row = 18;
                var col = frame;
                copyCellTo(row,col,destCtx,x,y);
            };

            var copyPacmanSprite = function(destCtx,x,y,dirEnum,frame) {
                var row = 6;
                var col;
                if (frame == 0) {
                    col = 0;
                }
                else {
                col = dirEnum*2+1+(frame-1);
                }
                copyCellTo(row,col,destCtx,x,y);
            };

            var copyMsPacmanSprite = function(destCtx,x,y,dirEnum,frame) {
                // TODO: determine row, col
                //copyCellTo(row,col,destCtx,x,y);
                var row = 7;
                var col = dirEnum*3+frame;
                copyCellTo(row,col,destCtx,x,y);
            };

            var copyCookiemanSprite = function(destCtx,x,y,dirEnum,frame) {
                var row = 8;
                var col = dirEnum*3+frame;
                copyCellTo(row,col,destCtx,x,y);
            };

            var copyFruitSprite = function(destCtx,x,y,name) {
                var row = 0;
                var col = {
                    "cherry": 0,
                    "strawberry": 1,
                    "orange": 2,
                    "apple": 3,
                    "melon": 4,
                    "galaxian": 5,
                    "bell": 6,
                    "key": 7,
                    "pretzel": 8,
                    "pear": 9,
                    "banana": 10,
                    "cookie": 11,
                    "cookieface": 12,
                }[name];

                copyCellTo(row,col,destCtx,x,y);
            };

            return {
                create: create,
                getCanvas: function() { return canvas; },
                drawGhostSprite: copyGhostSprite,
                drawMonsterSprite: copyMonsterSprite,
                drawMuppetSprite: copyMuppetSprite,
                drawOttoSprite: copyOttoSprite,
                drawMsOttoSprite: copyMsOttoSprite,
                drawPacmanSprite: copyPacmanSprite,
                drawMsPacmanSprite: copyMsPacmanSprite,
                drawCookiemanSprite: copyCookiemanSprite,
                drawFruitSprite: copyFruitSprite,
                drawGhostPoints: copyGhostPoints,
                drawPacFruitPoints: copyPacFruitPoints,
                drawMsPacFruitPoints: copyMsPacFruitPoints,
                drawSnail: copySnail,
            };
            })();
            //@line 1 "src/renderers.js"
            //////////////////////////////////////////////////////////////
            // Renderers

            // Draws everything in the game using swappable renderers
            // to enable to different front-end displays for Pac-Man.

            // list of available renderers
            var renderer_list;

            // current renderer
            var renderer;

            var renderScale;

            var mapMargin = 4*tileSize; // margin between the map and the screen
            var mapPad = tileSize/8; // padding between the map and its clipping

            var mapWidth = 28*tileSize+mapPad*2;
            var mapHeight = 36*tileSize+mapPad*2;

            var screenWidth = mapWidth+mapMargin*2;
            var screenHeight = mapHeight+mapMargin*2;

            // all rendering will be shown on this canvas
            var canvas;

            // switch to the given renderer index
            var switchRenderer = function(i) {
            renderer = renderer_list[i];
            renderer.drawMap();
            };

            var getDevicePixelRatio = function() {
            // Only consider the device pixel ratio for devices that are <= 320 pixels in width.
            // This is necessary for the iPhone4's retina display; otherwise the game would be blurry.
            // The iPad3's retina display @ 2048x1536 starts slowing the game down.
            return 1;
            if (window.innerWidth <= 320) {
                return window.devicePixelRatio || 1;
            }
            return 1;
            };

            var initRenderer = function(){

            var bgCanvas;
            var ctx, bgCtx;

            // drawing scale
            var scale = 2;        // scale everything by this amount

            // (temporary global version of scale just to get things quickly working)
            renderScale = scale; 

            var resets = 0;

            // rescale the canvases
            var resetCanvasSizes = function() {

                // set the size of the canvas in actual pixels
                canvas.width = screenWidth * scale;
                canvas.height = screenHeight * scale;

                // set the size of the canvas in browser pixels
                var ratio = getDevicePixelRatio();
                canvas.style.width = canvas.width / ratio;
                canvas.style.height = canvas.height / ratio;

                if (resets > 0) {
                    ctx.restore();
                }
                ctx.save();
                ctx.scale(scale,scale);

                bgCanvas.width = mapWidth * scale;
                bgCanvas.height = mapHeight * scale;
                if (resets > 0) {
                    bgCtx.restore();
                }
                bgCtx.save();
                bgCtx.scale(scale,scale);

                resets++;
            };

            // get the target scale that will cause the canvas to fit the window
            var getTargetScale = function() {
                var sx = (window.innerWidth - 10) / screenWidth;
                var sy = (window.innerHeight - 10) / screenHeight;
                var s = Math.min(sx,sy);
                s *= getDevicePixelRatio();
                return s;
            };

            // maximize the scale to fit the window
            var fullscreen = function() {
                // NOTE: css-scaling alternative at https://gist.github.com/1184900
                renderScale = scale = getTargetScale();
                resetCanvasSizes();
                atlas.create();
                if (renderer) {
                    renderer.drawMap();
                }
                center();
            };

            // center the canvas in the window
            var center = function() {
                var s = getTargetScale()/getDevicePixelRatio();
                var w = screenWidth*s;
                var x = Math.max(0,(window.innerWidth-10)/2 - w/2);
                var y = 0;
                /*
                canvas.style.position = "absolute";
                canvas.style.left = x;
                canvas.style.top = y;
                console.log(canvas.style.left);
                */
                document.body.style.marginLeft = (window.innerWidth - w)/2 + "px";
            };

            // create foreground and background canvases
            canvas = document.getElementById('canvas');
            bgCanvas = document.createElement('canvas');
            ctx = canvas.getContext("2d");
            bgCtx = bgCanvas.getContext("2d");

            // initialize placement and size
            fullscreen();

            // adapt placement and size to window resizes
            var resizeTimeout;
            window.addEventListener('resize', function () {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(fullscreen, 100);
            }, false);

            //////////////////////

            var beginMapFrame = function() {
                bgCtx.fillStyle = "#000";
                bgCtx.fillRect(0,0,mapWidth,mapHeight);
                bgCtx.translate(mapPad, mapPad);
            };

            var endMapFrame = function() {
                bgCtx.translate(-mapPad, -mapPad);
            };

            //////////////////////////////////////////////////////////////
            // Common Renderer
            // (attributes and functionality that are currently common to all renderers)

            // constructor
            var CommonRenderer = function() {
                this.actorSize = (tileSize-1)*2;
                this.energizerSize = tileSize+2;
                this.pointsEarnedTextSize = tileSize;

                this.energizerColor = "#FFF";
                this.pelletColor = "#888";

                this.flashLevel = false;
            };

            CommonRenderer.prototype = {

                setOverlayColor: function(color) {
                    this.overlayColor = color;
                },

                beginMapClip: function() {
                    ctx.save();
                    ctx.beginPath();

                    // subtract one from size due to shift done for sprite realignment?
                    // (this fixes a bug that leaves unerased artifacts after actors use right-side tunnel
                    ctx.rect(-mapPad,-mapPad,mapWidth-1,mapHeight-1); 

                    ctx.clip();
                },

                endMapClip: function() {
                    ctx.restore();
                },

                beginFrame: function() {
                    this.setOverlayColor(undefined);
                    ctx.save();

                    // clear margin area
                    ctx.fillStyle = "#000";
                    (function(w,h,p){
                        ctx.fillRect(0,0,w,p+1);
                        ctx.fillRect(0,p,p,h-2*p);
                        ctx.fillRect(w-p-2,p,p+2,h-2*p);
                        ctx.fillRect(0,h-p-2,w,p+2);
                    })(screenWidth, screenHeight, mapMargin);

                    // draw fps
                    if (DEBUG) {
                        ctx.font = (tileSize-2) + "px ArcadeR";
                        ctx.textBaseline = "bottom";
                        ctx.textAlign = "right";
                        ctx.fillStyle = "#333";
                        ctx.fillText(Math.floor(executive.getFps())+" FPS", screenWidth, screenHeight);
                    }

                    // translate to map space
                    ctx.translate(mapMargin+mapPad, mapMargin+mapPad);
                },

                endFrame: function() {
                    ctx.restore();
                    if (this.overlayColor != undefined) {
                        ctx.fillStyle = this.overlayColor;
                        ctx.fillRect(0,0,screenWidth,screenHeight);
                    }
                },

                clearMapFrame: function() {
                    ctx.fillStyle = "#000";
                    ctx.fillRect(-1,-1,mapWidth+1,mapHeight+1);
                },

                renderFunc: function(f,that) {
                    if (that) {
                        f.call(that,ctx);
                    }
                    else {
                        f(ctx);
                    }
                },

                // scaling the canvas can incur floating point roundoff errors
                // which manifest as "grout" between tiles that are otherwise adjacent in integer-space
                // This function extends the width and height of the tile if it is adjacent to equivalent tiles
                // that are to the bottom or right of the given tile
                drawNoGroutTile: function(ctx,x,y,w) {
                    var tileChar = map.getTile(x,y);
                    this.drawCenterTileSq(ctx,x,y,tileSize,
                            map.getTile(x+1,y) == tileChar,
                            map.getTile(x,y+1) == tileChar,
                            map.getTile(x+1,y+1) == tileChar);
                },

                // draw square centered at the given tile with optional "floating point grout" filling
                drawCenterTileSq: function (ctx,tx,ty,w, rightGrout, downGrout, downRightGrout) {
                    this.drawCenterPixelSq(ctx, tx*tileSize+midTile.x, ty*tileSize+midTile.y,w,
                            rightGrout, downGrout, downRightGrout);
                },

                // draw square centered at the given pixel
                drawCenterPixelSq: function (ctx,px,py,w,rightGrout, downGrout, downRightGrout) {
                    ctx.fillRect(px-w/2, py-w/2,w,w);

                    // fill "floating point grout" gaps between tiles
                    var gap = 1;
                    if (rightGrout) ctx.fillRect(px-w/2, py-w/2,w+gap,w);
                    if (downGrout) ctx.fillRect(px-w/2, py-w/2,w,w+gap);
                    //if (rightGrout && downGrout && downRightGrout) ctx.fillRect(px-w/2, py-w/2,w+gap,w+gap);
                },

                // this flag is used to flash the level upon its successful completion
                toggleLevelFlash: function () {
                    this.flashLevel = !this.flashLevel;
                },

                setLevelFlash: function(on) {
                    if (on != this.flashLevel) {
                        this.flashLevel = on;
                        this.drawMap();
                    }
                },

                // draw the target visualizers for each actor
                drawTargets: function() {
                    var i;
                    ctx.strokeStyle = "rgba(255,255,255,0.5)";
                    ctx.lineWidth = "1.5";
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";
                    for (i=0;i<5;i++)
                        if (actors[i].isDrawTarget)
                            actors[i].drawTarget(ctx);
                },

                drawPaths: function() {
                    var backupAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = 0.7;
                    var i;
                    for (i=0;i<5;i++)
                        if (actors[i].isDrawPath)
                            this.drawPath(actors[i]);
                    ctx.globalAlpha = backupAlpha;
                },

                // draw a predicted path for the actor if it continues pursuing current target
                drawPath: function(actor) {
                    if (!actor.targetting) return;

                    // current state of the predicted path
                    var tile = { x: actor.tile.x, y: actor.tile.y};
                    var target = actor.targetTile;
                    var dir = { x: actor.dir.x, y: actor.dir.y };
                    var dirEnum = actor.dirEnum;
                    var openTiles;

                    // exit if we're already on the target
                    if (tile.x == target.x && tile.y == target.y) {
                        return;
                    }

                    // if we are past the center of the tile, we cannot turn here anymore, so jump to next tile
                    if ((dirEnum == DIR_UP && actor.tilePixel.y <= midTile.y) ||
                        (dirEnum == DIR_DOWN && actor.tilePixel.y >= midTile.y) ||
                        (dirEnum == DIR_LEFT && actor.tilePixel.x <= midTile.x) ||
                        (dirEnum == DIR_RIGHT & actor.tilePixel.x >= midTile.x)) {
                        tile.x += dir.x;
                        tile.y += dir.y;
                    }
                    var pixel = { x:tile.x*tileSize+midTile.x, y:tile.y*tileSize+midTile.y };
                    
                    // dist keeps track of how far we're going along this path, stopping at maxDist
                    // distLeft determines how long the last line should be
                    var dist = Math.abs(tile.x*tileSize+midTile.x - actor.pixel.x + tile.y*tileSize+midTile.y - actor.pixel.y);
                    var maxDist = actorPathLength*tileSize;
                    var distLeft;
                    
                    // add the first line
                    ctx.strokeStyle = actor.pathColor;
                    ctx.lineWidth = "2.0";
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";
                    ctx.beginPath();
                    ctx.moveTo(
                            actor.pixel.x+actor.pathCenter.x,
                            actor.pixel.y+actor.pathCenter.y);
                    ctx.lineTo(
                            pixel.x+actor.pathCenter.x,
                            pixel.y+actor.pathCenter.y);

                    if (tile.x == target.x && tile.y == target.y) {
                        // adjust the distance left to create a smoothly interpolated path end
                        distLeft = actor.getPathDistLeft(pixel, dirEnum);
                    }
                    else while (true) {

                        // predict next turn from current tile
                        openTiles = getOpenTiles(tile, dirEnum);
                        if (actor != pacman && map.constrainGhostTurns)
                            map.constrainGhostTurns(tile, openTiles, dirEnum);
                        dirEnum = getTurnClosestToTarget(tile, target, openTiles);
                        setDirFromEnum(dir,dirEnum);
                        
                        // if the next tile is our target, determine how mush distance is left and break loop
                        if (tile.x+dir.x == target.x && tile.y+dir.y == target.y) {
                        
                            // adjust the distance left to create a smoothly interpolated path end
                            distLeft = actor.getPathDistLeft(pixel, dirEnum);

                            // cap distance left
                            distLeft = Math.min(maxDist-dist, distLeft);

                            break;
                        }
                        
                        // exit if we're going past the max distance
                        if (dist + tileSize > maxDist) {
                            distLeft = maxDist - dist;
                            break;
                        }

                        // move to next tile and add a line to its center
                        tile.x += dir.x;
                        tile.y += dir.y;
                        pixel.x += tileSize*dir.x;
                        pixel.y += tileSize*dir.y;
                        dist += tileSize;
                        ctx.lineTo(
                                tile.x*tileSize+midTile.x+actor.pathCenter.x,
                                tile.y*tileSize+midTile.y+actor.pathCenter.y);
                    }

                    // calculate final endpoint
                    var px = pixel.x+actor.pathCenter.x+distLeft*dir.x;
                    var py = pixel.y+actor.pathCenter.y+distLeft*dir.y;

                    // add an arrow head
                    ctx.lineTo(px,py);
                    var s = 3;
                    if (dirEnum == DIR_LEFT || dirEnum == DIR_RIGHT) {
                        ctx.lineTo(px-s*dir.x,py+s*dir.x);
                        ctx.moveTo(px,py);
                        ctx.lineTo(px-s*dir.x,py-s*dir.x);
                    }
                    else {
                        ctx.lineTo(px+s*dir.y,py-s*dir.y);
                        ctx.moveTo(px,py);
                        ctx.lineTo(px-s*dir.y,py-s*dir.y);
                    }

                    // draw path    
                    ctx.stroke();
                },

                // erase pellet from background
                erasePellet: function(x,y) {
                    bgCtx.translate(mapPad,mapPad);
                    bgCtx.fillStyle = this.floorColor;
                    this.drawNoGroutTile(bgCtx,x,y,tileSize);

                    // fill in adjacent floor tiles
                    if (map.getTile(x+1,y)==' ') this.drawNoGroutTile(bgCtx,x+1,y,tileSize);
                    if (map.getTile(x-1,y)==' ') this.drawNoGroutTile(bgCtx,x-1,y,tileSize);
                    if (map.getTile(x,y+1)==' ') this.drawNoGroutTile(bgCtx,x,y+1,tileSize);
                    if (map.getTile(x,y-1)==' ') this.drawNoGroutTile(bgCtx,x,y-1,tileSize);

                    // TODO: fill in adjacent wall tiles?

                    bgCtx.translate(-mapPad,-mapPad);
                },

                // draw a center screen message (e.g. "start", "ready", "game over")
                drawMessage: function(text, color, x,y) {
                    ctx.font = tileSize + "px ArcadeR";
                    ctx.textBaseline = "top";
                    ctx.textAlign = "right";
                    ctx.fillStyle = color;
                    x += text.length;
                    ctx.fillText(text, x*tileSize, y*tileSize);
                },

                drawReadyMessage: function() {
                    this.drawMessage("READY ","#FF0",11,20);
                    drawExclamationPoint(ctx,16*tileSize+3, 20*tileSize+3);
                },

                // draw the points earned from the most recently eaten ghost
                drawEatenPoints: function() {
                    atlas.drawGhostPoints(ctx, pacman.pixel.x, pacman.pixel.y, energizer.getPoints());
                },

                // draw each actor (ghosts and pacman)
                drawActors: function() {
                    var i;
                    // draw such that pacman appears on top
                    if (energizer.isActive()) {
                        for (i=0; i<4; i++) {
                            this.drawGhost(ghosts[i]);
                        }
                        if (!energizer.showingPoints())
                            this.drawPlayer();
                        else
                            this.drawEatenPoints();
                    }
                    // draw such that pacman appears on bottom
                    else {
                        this.drawPlayer();
                        for (i=3; i>=0; i--) {
                            if (ghosts[i].isVisible) {
                                this.drawGhost(ghosts[i]);
                            }
                        }
                        if (inky.isVisible && !blinky.isVisible) {
                            this.drawGhost(blinky,0.5);
                        }
                    }
                },

            };

            //////////////////////////////////////////////////////////////
            // Simple Renderer
            // (render a minimal Pac-Man display using nothing but squares)

            // constructor
            var SimpleRenderer = function() {

                // inherit attributes from Common Renderer
                CommonRenderer.call(this,ctx,bgCtx);

                this.messageRow = 21.7;
                this.pointsEarnedTextSize = 1.5*tileSize;

                this.backColor = "#222";
                this.floorColor = "#444";
                this.flashFloorColor = "#999";

                this.name = "Minimal";
            };

            SimpleRenderer.prototype = newChildObject(CommonRenderer.prototype, {

                drawMap: function() {

                    beginMapFrame();

                    var x,y;
                    var i;
                    var tile;

                    // draw floor tiles
                    bgCtx.fillStyle = (this.flashLevel ? this.flashFloorColor : this.floorColor);
                    i=0;
                    for (y=0; y<map.numRows; y++)
                    for (x=0; x<map.numCols; x++) {
                        tile = map.currentTiles[i++];
                        if (tile == ' ')
                            this.drawNoGroutTile(bgCtx,x,y,tileSize);
                    }

                    // draw pellet tiles
                    bgCtx.fillStyle = this.pelletColor;
                    i=0;
                    for (y=0; y<map.numRows; y++)
                    for (x=0; x<map.numCols; x++) {
                        tile = map.currentTiles[i++];
                        if (tile == '.')
                            this.drawNoGroutTile(bgCtx,x,y,tileSize);
                    }

                    endMapFrame();
                },

                refreshPellet: function(x,y) {
                    var i = map.posToIndex(x,y);
                    var tile = map.currentTiles[i];
                    if (tile == ' ') {
                        this.erasePellet(x,y);
                    }
                    else if (tile == '.') {
                        bgCtx.fillStyle = this.pelletColor;
                        this.drawNoGroutTile(bgCtx,x,y,tileSize);
                    }
                },


                // draw the current score and high score
                drawScore: function() {
                    ctx.font = 1.5*tileSize + "px sans-serif";
                    ctx.textBaseline = "top";
                    ctx.textAlign = "left";
                    ctx.fillStyle = "#FFF";
                    ctx.fillText(getScore(), tileSize, tileSize*2);

                    ctx.font = "bold " + 1.5*tileSize + "px sans-serif";
                    ctx.textBaseline = "top";
                    ctx.textAlign = "center";
                    ctx.fillText("high score", tileSize*map.numCols/2, 3);
                    ctx.fillText(getHighScore(), tileSize*map.numCols/2, tileSize*2);
                },

                // draw the extra lives indicator
                drawExtraLives: function() {
                    var i;
                    ctx.fillStyle = "rgba(255,255,0,0.6)";
                    var lives = extraLives == Infinity ? 1 : extraLives;
                    for (i=0; i<extraLives; i++)
                        this.drawCenterPixelSq(ctx, (2*i+3)*tileSize, (map.numRows-2)*tileSize+midTile.y,this.actorSize);
                },

                // draw the current level indicator
                drawLevelIcons: function() {
                    var i;
                    ctx.fillStyle = "rgba(255,255,255,0.5)";
                    var w = 2;
                    var h = this.actorSize;
                    for (i=0; i<level; i++)
                        ctx.fillRect((map.numCols-2)*tileSize - i*2*w, (map.numRows-2)*tileSize+midTile.y-h/2, w, h);
                },

                // draw energizer items on foreground
                drawEnergizers: function() {
                    ctx.fillStyle = this.energizerColor;
                    var e;
                    var i;
                    for (i=0; i<map.numEnergizers; i++) {
                        e = map.energizers[i];
                        if (map.currentTiles[e.x+e.y*map.numCols] == 'o')
                            this.drawCenterTileSq(ctx,e.x,e.y,this.energizerSize);
                    }
                },

                // draw pacman
                drawPlayer: function(scale, opacity) {
                    if (scale == undefined) scale = 1;
                    if (opacity == undefined) opacity = 1;
                    ctx.fillStyle = "rgba(255,255,0,"+opacity+")";
                    this.drawCenterPixelSq(ctx, pacman.pixel.x, pacman.pixel.y, this.actorSize*scale);
                },

                // draw dying pacman animation (with 0<=t<=1)
                drawDyingPlayer: function(t) {
                    var f = t*85;
                    if (f <= 60) {
                        t = f/60;
                        this.drawPlayer(1-t);
                    }
                    else {
                        f -= 60;
                        t = f/15;
                        this.drawPlayer(t,1-t);
                    }
                },

                // draw ghost
                drawGhost: function(g) {
                    if (g.mode == GHOST_EATEN)
                        return;
                    var color = g.color;
                    if (g.scared)
                        color = energizer.isFlash() ? "#FFF" : "#2121ff";
                    else if (g.mode == GHOST_GOING_HOME || g.mode == GHOST_ENTERING_HOME)
                        color = "rgba(255,255,255,0.3)";
                    ctx.fillStyle = color;
                    this.drawCenterPixelSq(ctx, g.pixel.x, g.pixel.y, this.actorSize);
                },

                drawFruit: function() {
                    if (fruit.isPresent()) {
                        ctx.fillStyle = "#0F0";
                        this.drawCenterPixelSq(ctx, fruit.pixel.x, fruit.pixel.y, tileSize+2);
                    }
                    else if (fruit.isScorePresent()) {
                        ctx.font = this.pointsEarnedTextSize + "px sans-serif";
                        ctx.textBaseline = "middle";
                        ctx.textAlign = "center";
                        ctx.fillStyle = "#FFF";
                        ctx.fillText(fruit.getPoints(), fruit.pixel.x, fruit.pixel.y);
                    }
                },

            });


            //////////////////////////////////////////////////////////////
            // Arcade Renderer
            // (render a display close to the original arcade)

            // constructor
            var ArcadeRenderer = function(ctx,bgCtx) {

                // inherit attributes from Common Renderer
                CommonRenderer.call(this,ctx,bgCtx);

                this.messageRow = 20;
                this.pelletSize = 2;
                this.energizerSize = tileSize;

                this.backColor = "#000";
                this.floorColor = "#000";
                this.flashWallColor = "#FFF";

                this.name = "Arcade";
            };

            ArcadeRenderer.prototype = newChildObject(CommonRenderer.prototype, {

                // copy background canvas to the foreground canvas
                blitMap: function() {
                    ctx.scale(1/scale,1/scale);
                    ctx.drawImage(bgCanvas,-1-mapPad*scale,-1-mapPad*scale); // offset map to compenstate for misalignment
                    ctx.scale(scale,scale);
                    //ctx.clearRect(-mapPad,-mapPad,mapWidth,mapHeight);
                },

                drawMap: function(isCutscene) {

                    // fill background
                    beginMapFrame();

                    if (map) {

                        // Sometimes pressing escape during a flash can cause flash to be permanently enabled on maps.
                        // so just turn it off when not in the finish state.
                        if (state != finishState) {
                            this.flashLevel = false;
                        }

                        var x,y;
                        var i,j;
                        var tile;

                        // ghost house door
                        i=0;
                        for (y=0; y<map.numRows; y++)
                        for (x=0; x<map.numCols; x++) {
                            if (map.currentTiles[i] == '-' && map.currentTiles[i+1] == '-') {
                                bgCtx.fillStyle = "#ffb8de";
                                bgCtx.fillRect(x*tileSize,y*tileSize+tileSize-2,tileSize*2,2);
                            }
                            i++;
                        }

                        if (this.flashLevel) {
                            bgCtx.fillStyle = "#000";
                            bgCtx.strokeStyle = "#fff";
                        }
                        else {
                            bgCtx.fillStyle = map.wallFillColor;
                            bgCtx.strokeStyle = map.wallStrokeColor;
                        }
                        for (i=0; i<map.paths.length; i++) {
                            var path = map.paths[i];
                            bgCtx.beginPath();
                            bgCtx.moveTo(path[0].x, path[0].y);
                            for (j=1; j<path.length; j++) {
                                if (path[j].cx != undefined)
                                    bgCtx.quadraticCurveTo(path[j].cx, path[j].cy, path[j].x, path[j].y);
                                else
                                    bgCtx.lineTo(path[j].x, path[j].y);
                            }
                            bgCtx.quadraticCurveTo(path[j-1].x, path[0].y, path[0].x, path[0].y);
                            bgCtx.fill();
                            bgCtx.stroke();
                        }

                        // draw pellet tiles
                        bgCtx.fillStyle = map.pelletColor;
                        i=0;
                        for (y=0; y<map.numRows; y++)
                        for (x=0; x<map.numCols; x++) {
                            this.refreshPellet(x,y,true);
                        }

                        if (map.onDraw) {
                            map.onDraw(bgCtx);
                        }

                        if (map.shouldDrawMapOnly) {
                            endMapFrame();
                            return;
                        }
                    }
                    if (level > 0) {

                        var numRows = 36;
                        var numCols = 28;

                        if (!isCutscene) {
                            // draw extra lives
                            var i;
                            bgCtx.fillStyle = pacman.color;

                            bgCtx.save();
                            bgCtx.translate(3*tileSize, (numRows-1)*tileSize);
                            bgCtx.scale(0.85, 0.85);
                            var lives = extraLives == Infinity ? 1 : extraLives;
                            if (gameMode == GAME_PACMAN) {
                                for (i=0; i<lives; i++) {
                                    drawPacmanSprite(bgCtx, 0,0, DIR_LEFT, Math.PI/6);
                                    bgCtx.translate(2*tileSize,0);
                                }
                            }
                            else if (gameMode == GAME_MSPACMAN) {
                                for (i=0; i<lives; i++) {
                                    drawMsPacmanSprite(bgCtx, 0,0, DIR_RIGHT, 1);
                                    bgCtx.translate(2*tileSize,0);
                                }
                            }
                            else if (gameMode == GAME_COOKIE) {
                                for (i=0; i<lives; i++) {
                                    drawCookiemanSprite(bgCtx, 0,0, DIR_RIGHT, 1, false);
                                    bgCtx.translate(2*tileSize,0);
                                }
                            }
                            else if (gameMode == GAME_OTTO) {
                                for (i=0; i<lives; i++) {
                                    drawOttoSprite(bgCtx, 0,0,DIR_RIGHT, 0);
                                    bgCtx.translate(2*tileSize,0);
                                }
                            }
                            if (extraLives == Infinity) {
                                bgCtx.translate(-4*tileSize,0);

                                // draw X
                                /*
                                bgCtx.translate(-s*2,0);
                                var s = 2; // radius of each stroke
                                bgCtx.beginPath();
                                bgCtx.moveTo(-s,-s);
                                bgCtx.lineTo(s,s);
                                bgCtx.moveTo(-s,s);
                                bgCtx.lineTo(s,-s);
                                bgCtx.lineWidth = 1;
                                bgCtx.strokeStyle = "#777";
                                bgCtx.stroke();
                                */

                                // draw Infinity symbol
                                var r = 2; // radius of each half-circle
                                var d = 3; // distance between the two focal points
                                bgCtx.beginPath();
                                bgCtx.moveTo(-d-r,0);
                                bgCtx.quadraticCurveTo(-d-r,-r,-d,-r);
                                bgCtx.bezierCurveTo(-(d-r),-r,d-r,r,d,r);
                                bgCtx.quadraticCurveTo(d+r,r,d+r,0);
                                bgCtx.quadraticCurveTo(d+r,-r,d,-r);
                                bgCtx.bezierCurveTo(d-r,-r,-(d-r),r,-d,r);
                                bgCtx.quadraticCurveTo(-d-r,r,-d-r,0);
                                bgCtx.lineWidth = 1;
                                bgCtx.strokeStyle = "#FFF";
                                bgCtx.stroke();
                            }
                            bgCtx.restore();
                        }

                        // draw level fruit
                        var fruits = fruit.fruitHistory;
                        var i,j;
                        var f,drawFunc;
                        var numFruit = 7;
                        var startLevel = Math.max(numFruit,level);
                        if (gameMode != GAME_PACMAN) {
                            // for the Pac-Man game, display the last 7 fruit
                            // for the Ms Pac-Man game, display stop after the 7th fruit
                            startLevel = Math.min(numFruit,startLevel);
                        }
                        var scale = 0.85;
                        for (i=0, j=startLevel-numFruit+1; i<numFruit && j<=level; j++, i++) {
                            f = fruits[j];
                            if (f) {
                                drawFunc = getSpriteFuncFromFruitName(f.name);
                                if (drawFunc) {
                                    bgCtx.save();
                                    bgCtx.translate((numCols-3)*tileSize - i*16*scale, (numRows-1)*tileSize);
                                    bgCtx.scale(scale,scale);
                                    drawFunc(bgCtx,0,0);
                                    bgCtx.restore();
                                }
                            }
                        }
                        if (!isCutscene) {
                            if (level >= 100) {
                                bgCtx.font = (tileSize-3) + "px ArcadeR";
                            }
                            else {
                                bgCtx.font = (tileSize-1) + "px ArcadeR";
                            }
                            bgCtx.textBaseline = "middle";
                            bgCtx.fillStyle = "#777";
                            bgCtx.textAlign = "left";
                            bgCtx.fillText(level,(numCols-2)*tileSize, (numRows-1)*tileSize);
                        }
                    }
                    endMapFrame();
                },

                erasePellet: function(x,y,isTranslated) {
                    if (!isTranslated) {
                        bgCtx.translate(mapPad,mapPad);
                    }
                    bgCtx.fillStyle = "#000";
                    var i = map.posToIndex(x,y);
                    var size = map.tiles[i] == 'o' ? this.energizerSize : this.pelletSize;
                    this.drawCenterTileSq(bgCtx,x,y,size+2);
                    if (!isTranslated) {
                        bgCtx.translate(-mapPad,-mapPad);
                    }
                },

                refreshPellet: function(x,y,isTranslated) {
                    if (!isTranslated) {
                        bgCtx.translate(mapPad,mapPad);
                    }
                    var i = map.posToIndex(x,y);
                    var tile = map.currentTiles[i];
                    if (tile == ' ') {
                        this.erasePellet(x,y,isTranslated);
                    }
                    else if (tile == '.') {
                        bgCtx.fillStyle = map.pelletColor;
                        bgCtx.translate(0.5, 0.5);
                        this.drawCenterTileSq(bgCtx,x,y,this.pelletSize);
                        bgCtx.translate(-0.5, -0.5);
                    }
                    else if (tile == 'o') {
                        bgCtx.fillStyle = map.pelletColor;
                        bgCtx.beginPath();
                        bgCtx.arc(x*tileSize+midTile.x+0.5,y*tileSize+midTile.y,this.energizerSize/2,0,Math.PI*2);
                        bgCtx.fill();
                    }
                    if (!isTranslated) {
                        bgCtx.translate(-mapPad,-mapPad);
                    }
                },

                // draw the current score and high score
                drawScore: function() {
                    ctx.font = tileSize + "px ArcadeR";
                    ctx.textBaseline = "top";
                    ctx.fillStyle = "#FFF";

                    ctx.textAlign = "right";
                    ctx.fillText("1UP", 6*tileSize, 0);
                    ctx.fillText(practiceMode ? "PRACTICE" : "HIGH SCORE", 19*tileSize, 0);
                    //ctx.fillText("2UP", 25*tileSize, 0);

                    // TODO: player two score
                    var score = getScore();
                    if (score == 0) {
                        score = "00";
                    }
                    var y = tileSize+1;
                    ctx.fillText(score, 7*tileSize, y);

                    if (!practiceMode) {
                        var highScore = getHighScore();
                        if (highScore == 0) {
                            highScore = "00";
                        }
                        ctx.fillText(highScore, 17*tileSize, y);
                    }
                },

                // draw ghost
                drawGhost: function(g,alpha) {
                    var backupAlpha;
                    if (alpha) {
                        backupAlpha = ctx.globalAlpha;
                        ctx.globalAlpha = alpha;
                    }

                    var draw = function(mode, pixel, frames, faceDirEnum, scared, isFlash,color, dirEnum) {
                        if (mode == GHOST_EATEN)
                            return;
                        var frame = g.getAnimFrame(frames);
                        var eyes = (mode == GHOST_GOING_HOME || mode == GHOST_ENTERING_HOME);
                        var func = getGhostDrawFunc();
                        var y = g.getBounceY(pixel.x, pixel.y, dirEnum);
                        var x = (g == blinky && scared) ? pixel.x+1 : pixel.x; // blinky's sprite is shifted right when scared

                        func(ctx,x,y,frame,faceDirEnum,scared,isFlash,eyes,color);
                    };
                    vcr.drawHistory(ctx, function(t) {
                        draw(
                            g.savedMode[t],
                            g.savedPixel[t],
                            g.savedFrames[t],
                            g.savedFaceDirEnum[t],
                            g.savedScared[t],
                            energizer.isFlash(),
                            g.color,
                            g.savedDirEnum[t]);
                    });
                    draw(g.mode, g.pixel, g.frames, g.faceDirEnum, g.scared, energizer.isFlash(), g.color, g.dirEnum);
                    if (alpha) {
                        ctx.globalAlpha = backupAlpha;
                    }
                },

                // draw pacman
                drawPlayer: function() {
                    var frame = pacman.getAnimFrame();
                    if (pacman.invincible) {
                        ctx.globalAlpha = 0.6;
                    }

                    var draw = function(pixel, dirEnum, steps) {
                        var frame = pacman.getAnimFrame(pacman.getStepFrame(steps));
                        var func = getPlayerDrawFunc();
                        func(ctx, pixel.x, pixel.y, dirEnum, frame, true);
                    };

                    vcr.drawHistory(ctx, function(t) {
                        draw(
                            pacman.savedPixel[t],
                            pacman.savedDirEnum[t],
                            pacman.savedSteps[t]);
                    });
                    draw(pacman.pixel, pacman.dirEnum, pacman.steps);
                    if (pacman.invincible) {
                        ctx.globalAlpha = 1;
                    }
                },

                // draw dying pacman animation (with 0<=t<=1)
                drawDyingPlayer: function(t) {
                    var frame = pacman.getAnimFrame();

                    if (gameMode == GAME_PACMAN) {
                        // 60 frames dying
                        // 15 frames exploding
                        var f = t*75;
                        if (f <= 60) {
                            // open mouth all the way while shifting corner of mouth forward
                            t = f/60;
                            var a = frame*Math.PI/6;
                            drawPacmanSprite(ctx, pacman.pixel.x, pacman.pixel.y, pacman.dirEnum, a + t*(Math.PI-a),4*t);
                        }
                        else {
                            // explode
                            f -= 60;
                            this.drawExplodingPlayer(f/15);
                        }
                    }
                    else if (gameMode == GAME_OTTO) {
                        // TODO: spin around
                        if (t < 0.8) {
                            var dirEnum = Math.floor((pacman.dirEnum - t*16))%4;
                            if (dirEnum < 0) {
                                dirEnum += 4;
                            }
                            drawOttoSprite(ctx, pacman.pixel.x, pacman.pixel.y, dirEnum, 0);
                        }
                        else if (t < 0.95) {
                            var dirEnum = Math.floor((pacman.dirEnum - 0.8*16))%4;
                            if (dirEnum < 0) {
                                dirEnum += 4;
                            }
                            drawOttoSprite(ctx, pacman.pixel.x, pacman.pixel.y, dirEnum, 0);
                        }
                        else {
                            drawDeadOttoSprite(ctx,pacman.pixel.x, pacman.pixel.y);
                        }
                    }
                    else if (gameMode == GAME_MSPACMAN) {
                        // spin 540 degrees
                        var maxAngle = Math.PI*5;
                        var step = (Math.PI/4) / maxAngle; // 45 degree steps
                        var angle = Math.floor(t/step)*step*maxAngle;
                        drawMsPacmanSprite(ctx, pacman.pixel.x, pacman.pixel.y, pacman.dirEnum, frame, angle);
                    }
                    else if (gameMode == GAME_COOKIE) {
                        // spin 540 degrees
                        var maxAngle = Math.PI*5;
                        var step = (Math.PI/4) / maxAngle; // 45 degree steps
                        var angle = Math.floor(t/step)*step*maxAngle;
                        drawCookiemanSprite(ctx, pacman.pixel.x, pacman.pixel.y, pacman.dirEnum, frame, false, angle);
                    }
                },

                // draw exploding pacman animation (with 0<=t<=1)
                drawExplodingPlayer: function(t) {
                    var frame = pacman.getAnimFrame();
                    drawPacmanSprite(ctx, pacman.pixel.x, pacman.pixel.y, pacman.dirEnum, 0, 0, t,-3,1-t);
                },

                // draw fruit
                drawFruit: function() {

                    if (fruit.getCurrentFruit()) {
                        var name = fruit.getCurrentFruit().name;

                        // draw history trails of the fruit if applicable
                        if (fruit.savedPixel) {
                            vcr.drawHistory(ctx, function(t) {
                                var pixel = fruit.savedPixel[t];
                                if (pixel) {
                                    atlas.drawFruitSprite(ctx, pixel.x, pixel.y, name);
                                }
                            });
                        }

                        if (fruit.isPresent()) {
                            atlas.drawFruitSprite(ctx, fruit.pixel.x, fruit.pixel.y, name);
                        }
                        else if (fruit.isScorePresent()) {
                            if (gameMode == GAME_PACMAN) {
                                atlas.drawPacFruitPoints(ctx, fruit.pixel.x, fruit.pixel.y, fruit.getPoints());
                            }
                            else {
                                atlas.drawMsPacFruitPoints(ctx, fruit.pixel.x, fruit.pixel.y, fruit.getPoints());
                            }
                        }
                    }
                },

            });

            //
            // Create list of available renderers
            //
            renderer_list = [
                new SimpleRenderer(),
                new ArcadeRenderer(),
            ];
            renderer = renderer_list[1];
            };
            //@line 1 "src/hud.js"

            var hud = (function(){

            var on = false;

            return {

                update: function() {
                    var valid = this.isValidState();
                    if (valid != on) {
                        on = valid;
                        if (on) {
                            inGameMenu.onHudEnable();
                            vcr.onHudEnable();
                        }
                        else {
                            inGameMenu.onHudDisable();
                            vcr.onHudDisable();
                        }
                    }
                },
                draw: function(ctx) {
                    inGameMenu.draw(ctx);
                    vcr.draw(ctx);
                },
                isValidState: function() {
                    return (
                        state == playState ||
                        state == newGameState ||
                        state == readyNewState ||
                        state == readyRestartState ||
                        state == finishState ||
                        state == deadState ||
                        state == overState);
                },
            };

            })();
            //@line 1 "src/galagaStars.js"

            var galagaStars = (function() {

            var stars = {};
            var numStars = 200;

            var width = mapWidth;
            var height = Math.floor(mapHeight*1.5);

            var ypos;
            var yspeed=-0.5;

            var t;
            var flickerPeriod = 120;
            var flickerSteps = 4;
            var flickerGap = flickerPeriod / flickerSteps;

            var init = function() {
                t = 0;
                ypos = 0;
                var i;
                for (i=0; i<numStars; i++) {
                    stars[i] = {
                        x: getRandomInt(0,width-1),
                        y: getRandomInt(0,height-1),
                        color: getRandomColor(),
                        phase: getRandomInt(0,flickerPeriod-1),
                    };
                }
            };

            var update = function() {
                t++;
                t %= flickerPeriod;

                ypos += yspeed;
                ypos %= height;
                if (ypos < 0) {
                    ypos += height;
                }
            };

            var draw = function(ctx) {
                var i;
                var star;
                var time;
                var y;
                ctx.fillStyle = "#FFF";
                for (i=0; i<numStars; i++) {
                    star = stars[i];
                    time = (t + star.phase) % flickerPeriod;
                    if (time >= flickerGap) {
                        y = star.y - ypos;
                        if (y < 0) {
                            y += height;
                        }
                        ctx.fillStyle = star.color;
                        ctx.fillRect(star.x, y, 1,1);
                    }
                }
            };

            return {
                init: init,
                draw: draw,
                update: update,
            };

            })();
            //@line 1 "src/Button.js"
            var getPointerPos = function(evt) {
            var obj = canvas;
            var top = 0;
            var left = 0;
            while (obj.tagName != 'BODY') {
                top += obj.offsetTop;
                left += obj.offsetLeft;
                obj = obj.offsetParent;
            }

            // calculate relative mouse position
            let mouseX = evt.pageX - left;
            let mouseY = evt.pageY - top;

            // make independent of scale
            var ratio = getDevicePixelRatio();
            mouseX /= (renderScale / ratio);
            mouseY /= (renderScale / ratio);

            // offset
            mouseX -= mapMargin;
            mouseY += mapMargin;

/*             onmousemove = function(e){console.log("mouse location:", e.clientX, e.clientY);
                                    mouseX = e.clientX;
                                    mouseY = e.clientY;
                                    console.log(mouseX); } */

            return { x: mouseX, y: mouseY };
            };

            var Button = function(x,y,w,h,onclick) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.onclick = onclick;

            // text and icon padding
            this.pad = tileSize;



            // icon attributes
            this.frame = 0;

            this.borderBlurColor = "#333";
            this.borderFocusColor = "#EEE";

            this.isSelected = false;

            // touch events
            this.startedInside = false;
            var that = this;
            var touchstart = function(evt) {
                evt.preventDefault();
                var fingerCount = evt.touches.length;
                if (fingerCount == 1) {
                    var pos = getPointerPos(evt.touches[0]);
                    (that.startedInside=that.contains(pos.x,pos.y)) ? that.focus() : that.blur();
                }
                else {
                    touchcancel(evt);
                }
            };
            var touchmove = function(evt) {
                evt.preventDefault();
                var fingerCount = evt.touches.length;
                if (fingerCount == 1) {
                    if (that.startedInside) {
                        var pos = getPointerPos(evt.touches[0]);
                        that.contains(pos.x, pos.y) ? that.focus() : that.blur();
                    }
                }
                else {
                    touchcancel(evt);
                }
            };
            var touchend = function(evt) {
                evt.preventDefault();
                var registerClick = (that.startedInside && that.isSelected);
                if (registerClick) {
                    that.click();
                }
                touchcancel(evt);
                if (registerClick) {
                    // focus the button to keep it highlighted after successful click
                    that.focus();
                }
            };
            var touchcancel = function(evt) {
                evt.preventDefault();
                this.startedInside = false;
                that.blur();
            };


            // mouse events
            var click = function(evt) {
                var pos = getPointerPos(evt);
                if (that.contains(pos.x, pos.y)) {
                    that.click();
                }
            };
            var mousemove = function(evt) {
                var pos = getPointerPos(evt);
                that.contains(pos.x, pos.y) ? that.focus() : that.blur();
            };
            var mouseleave = function(evt) {
                that.blur();
            };

            this.isEnabled = false;
            this.onEnable = function() {
                canvas.addEventListener('click', click);
                canvas.addEventListener('mousemove', mousemove);
                canvas.addEventListener('mouseleave', mouseleave);
                canvas.addEventListener('touchstart', touchstart);
                canvas.addEventListener('touchmove', touchmove);
                canvas.addEventListener('touchend', touchend);
                canvas.addEventListener('touchcancel', touchcancel);
                this.isEnabled = true;
            };

            this.onDisable = function() {
                canvas.removeEventListener('click', click);
                canvas.removeEventListener('mousemove', mousemove);
                canvas.removeEventListener('mouseleave', mouseleave);
                canvas.removeEventListener('touchstart', touchstart);
                canvas.removeEventListener('touchmove', touchmove);
                canvas.removeEventListener('touchend', touchend);
                canvas.removeEventListener('touchcancel', touchcancel);
                that.blur();
                this.isEnabled = false;
            };
            };

            Button.prototype = {

            contains: function(x,y) {
                return x >= this.x && x <= this.x+this.w &&
                    y >= this.y && y <= this.y+this.h;
            },

            click: function() {
                // disable current click timeout (to prevent double clicks on some devices)
                clearTimeout(this.clickTimeout);

                // set a click delay
                var that = this;
                if (that.onclick) {
                    this.clickTimeout = setTimeout(function() { that.onclick(); }, 200);
                }
            },

            enable: function() {
                this.frame = 0;
                this.onEnable();
            },

            disable: function() {
                this.onDisable();
            },

            focus: function() {
                this.isSelected = true;
                this.onfocus && this.onfocus();
            },

            blur: function() {
                this.isSelected = false;
                this.onblur && this.onblur();
            },

            setText: function(msg) {
                this.msg = msg;
            },

            setFont: function(font,fontcolor) {
                this.font = font;
                this.fontcolor = fontcolor;
            },

            setIcon: function(drawIcon) {
                this.drawIcon = drawIcon;
            },

            draw: function(ctx) {

                // draw border
                ctx.lineWidth = 2;
                ctx.beginPath();
                var x=this.x, y=this.y, w=this.w, h=this.h;
                var r=h/4;
                ctx.moveTo(x,y+r);
                ctx.quadraticCurveTo(x,y,x+r,y);
                ctx.lineTo(x+w-r,y);
                ctx.quadraticCurveTo(x+w,y,x+w,y+r);
                ctx.lineTo(x+w,y+h-r);
                ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
                ctx.lineTo(x+r,y+h);
                ctx.quadraticCurveTo(x,y+h,x,y+h-r);
                ctx.closePath();
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fill();
                ctx.strokeStyle = this.isSelected && this.onclick ? this.borderFocusColor : this.borderBlurColor;
                ctx.stroke();

                // draw icon
                if (this.drawIcon) {
                    if (!this.msg) {
                        this.drawIcon(ctx,this.x+this.w/2,this.y+this.h/2,this.frame);
                    }
                    else {
                        this.drawIcon(ctx,this.x+this.pad+tileSize,this.y+this.h/2,this.frame);
                    }
                }

                // draw text
                if (this.msg) {
                    ctx.font = this.font;
                    ctx.fillStyle = this.isSelected && this.onclick ? this.fontcolor : "#777";
                    ctx.textBaseline = "middle";
                    ctx.textAlign = "center";
                    //ctx.fillText(this.msg, 2*tileSize+2*this.pad+this.x, this.y + this.h/2 + 1);
                    ctx.fillText(this.msg, this.x + this.w/2, this.y + this.h/2 + 1);
                }
            },

            update: function() {
                if (this.drawIcon) {
                    this.frame = this.isSelected ? this.frame+1 : 0;
                }
            },
            };

            var ToggleButton = function(x,y,w,h,isOn,setOn) {
            var that = this;
            var onclick = function() {
                setOn(!isOn());
                that.refreshMsg();
            };
            this.isOn = isOn;
            this.setOn = setOn;
            Button.call(this,x,y,w,h,onclick);
            };

            ToggleButton.prototype = newChildObject(Button.prototype, {

            enable: function() {
                Button.prototype.enable.call(this);
                this.refreshMsg();
            },
            setToggleLabel: function(label) {
                this.label = label;
            },
            refreshMsg: function() {
                if (this.label) {
                    this.msg = this.label + ": " + (this.isOn() ? "ON" : "OFF");
                }
            },
            refreshOnState: function() {
                this.setOn(this.isOn());
            },

            });
            //@line 1 "src/Menu.js"
            var Menu = function(title,x,y,w,h,pad,font,fontcolor) {
            this.title = title;
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.pad = pad;
            this.buttons = [];
            this.buttonCount = 0;
            this.currentY = this.y+this.pad;

            if (title) {
                this.currentY += 1*(this.h + this.pad);
            }

            this.font = font;
            this.fontcolor = fontcolor;
            this.enabled = false;

            this.backButton = undefined;
            };

            Menu.prototype = {

            clickCurrentOption: function() {
                var i;
                for (i=0; i<this.buttonCount; i++) {
                    if (this.buttons[i].isSelected) {
                        this.buttons[i].onclick();
                        break;
                    }
                }
            },

            selectNextOption: function() {
                var i;
                var nextBtn;
                for (i=0; i<this.buttonCount; i++) {
                    if (this.buttons[i].isSelected) {
                        this.buttons[i].blur();
                        nextBtn = this.buttons[(i+1)%this.buttonCount];
                        break;
                    }
                }
                nextBtn = nextBtn || this.buttons[0];
                nextBtn.focus();
            },

            selectPrevOption: function() {
                var i;
                var nextBtn;
                for (i=0; i<this.buttonCount; i++) {
                    if (this.buttons[i].isSelected) {
                        this.buttons[i].blur();
                        nextBtn = this.buttons[i==0?this.buttonCount-1:i-1];
                        break;
                    }
                }
                nextBtn = nextBtn || this.buttons[this.buttonCount-1];
                nextBtn.focus();
            },

            addToggleButton: function(isOn,setOn) {
                var b = new ToggleButton(this.x+this.pad,this.currentY,this.w-this.pad*2,this.h,isOn,setOn);
                this.buttons.push(b);
                this.buttonCount++;
                this.currentY += this.pad + this.h;
            },

            addToggleTextButton: function(label,isOn,setOn) {
                var b = new ToggleButton(this.x+this.pad,this.currentY,this.w-this.pad*2,this.h,isOn,setOn);
                b.setFont(this.font,this.fontcolor);
                b.setToggleLabel(label);
                this.buttons.push(b);
                this.buttonCount++;
                this.currentY += this.pad + this.h;
            },

            addTextButton: function(msg,onclick) {
                var b = new Button(this.x+this.pad,this.currentY,this.w-this.pad*2,this.h,onclick);
                b.setFont(this.font,this.fontcolor);
                b.setText(msg);
                this.buttons.push(b);
                this.buttonCount++;
                this.currentY += this.pad + this.h;
            },

            addTextIconButton: function(msg,onclick,drawIcon) {
                var b = new Button(this.x+this.pad,this.currentY,this.w-this.pad*2,this.h,onclick);
                b.setFont(this.font,this.fontcolor);
                b.setText(msg);
                b.setIcon(drawIcon);
                this.buttons.push(b);
                this.buttonCount++;
                this.currentY += this.pad + this.h;
            },

            addIconButton: function(drawIcon,onclick) {
                var b = new Button(this.x+this.pad,this.currentY,this.w-this.pad*2,this.h,onclick);
                b.setIcon(drawIcon);
                this.buttons.push(b);
                this.buttonCount++;
                this.currentY += this.pad + this.h;
            },

            addSpacer: function(count) {
                if (count == undefined) {
                    count = 1;
                }
                this.currentY += count*(this.pad + this.h);
            },

            enable: function() {
                var i;
                for (i=0; i<this.buttonCount; i++) {
                    this.buttons[i].enable();
                }
                this.enabled = true;
            },

            disable: function() {
                var i;
                for (i=0; i<this.buttonCount; i++) {
                    this.buttons[i].disable();
                }
                this.enabled = false;
            },

            isEnabled: function() {
                return this.enabled;
            },

            draw: function(ctx) {
                if (this.title) {
                    ctx.font = tileSize+"px ArcadeR";
                    ctx.textBaseline = "middle";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#FFF";
                    ctx.fillText(this.title,this.x + this.w/2, this.y+this.pad + this.h/2);
                }
                var i;
                for (i=0; i<this.buttonCount; i++) {
                    this.buttons[i].draw(ctx);
                }
            },

            update: function() {
                var i;
                for (i=0; i<this.buttonCount; i++) {
                    this.buttons[i].update();
                }
            },
            };
            //@line 1 "src/inGameMenu.js"
            ////////////////////////////////////////////////////
            // In-Game Menu
            var inGameMenu = (function() {

            var w=tileSize*6,h=tileSize*3;

            var getMainMenu = function() {
                return practiceMode ? practiceMenu : menu;
            };
            var showMainMenu = function() {
                getMainMenu().enable();
            };
            var hideMainMenu = function() {
                getMainMenu().disable();
            };

            // button to enable in-game menu
            var btn = new Button(mapWidth/2 - w/2,mapHeight,w,h, function() {
                showMainMenu();
                vcr.onHudDisable();
            });
            btn.setText("MENU");
            btn.setFont(tileSize+"px ArcadeR","#FFF");

            // confirms a menu action
            var confirmMenu = new Menu("QUESTION?",2*tileSize,5*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            confirmMenu.addTextButton("YES", function() {
                confirmMenu.disable();
                confirmMenu.onConfirm();
            });
            confirmMenu.addTextButton("NO", function() {
                confirmMenu.disable();
                showMainMenu();
            });
            confirmMenu.addTextButton("CANCEL", function() {
                confirmMenu.disable();
                showMainMenu();
            });
            confirmMenu.backButton = confirmMenu.buttons[confirmMenu.buttonCount-1];

            var showConfirm = function(title,onConfirm) {
                hideMainMenu();
                confirmMenu.title = title;
                confirmMenu.onConfirm = onConfirm;
                confirmMenu.enable();
            };

            // regular menu
            var menu = new Menu("PAUSED",2*tileSize,5*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            menu.addTextButton("RESUME", function() {
                menu.disable();
            });
            menu.addTextButton("QUIT", function() {
                showConfirm("QUIT GAME?", function() {
                    switchState(homeState, 60);
                });
            });
            menu.backButton = menu.buttons[0];

            // practice menu
            var practiceMenu = new Menu("PAUSED",2*tileSize,5*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            practiceMenu.addTextButton("RESUME", function() {
                hideMainMenu();
                vcr.onHudEnable();
            });
            practiceMenu.addTextButton("RESTART LEVEL", function() {
                showConfirm("RESTART LEVEL?", function() {
                    level--;
                    switchState(readyNewState, 60);
                });
            });
            practiceMenu.addTextButton("SKIP LEVEL", function() {
                showConfirm("SKIP LEVEL?", function() {
                    switchState(readyNewState, 60);
                });
            });
            practiceMenu.addTextButton("CHEATS", function() {
                practiceMenu.disable();
                cheatsMenu.enable();
            });
            practiceMenu.addTextButton("QUIT", function() {
                showConfirm("QUIT GAME?", function() {
                    switchState(homeState, 60);
                    clearCheats();
                    vcr.reset();
                });
            });
            practiceMenu.backButton = practiceMenu.buttons[0];

            // cheats menu
            var cheatsMenu = new Menu("CHEATS",2*tileSize,5*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            cheatsMenu.addToggleTextButton("INVINCIBLE",
                function() {
                    return pacman.invincible;
                },
                function(on) {
                    pacman.invincible = on;
                });
            cheatsMenu.addToggleTextButton("TURBO",
                function() {
                    return turboMode;
                },
                function(on) {
                    turboMode = on;
                });
            cheatsMenu.addToggleTextButton("SHOW TARGETS",
                function() {
                    return blinky.isDrawTarget;
                },
                function(on) {
                    for (var i=0; i<4; i++) {
                        ghosts[i].isDrawTarget = on;
                    }
                });
            cheatsMenu.addToggleTextButton("SHOW PATHS",
                function() {
                    return blinky.isDrawPath;
                },
                function(on) {
                    for (var i=0; i<4; i++) {
                        ghosts[i].isDrawPath = on;
                    }
                });
            cheatsMenu.addSpacer(1);
            cheatsMenu.addTextButton("BACK", function() {
                cheatsMenu.disable();
                practiceMenu.enable();
            });
            cheatsMenu.backButton = cheatsMenu.buttons[cheatsMenu.buttons.length-1];

            var menus = [menu, practiceMenu, confirmMenu, cheatsMenu];
            var getVisibleMenu = function() {
                var len = menus.length;
                var i;
                var m;
                for (i=0; i<len; i++) {
                    m = menus[i];
                    if (m.isEnabled()) {
                        return m;
                    }
                }
            };

            return {
                onHudEnable: function() {
                    btn.enable();
                },
                onHudDisable: function() {
                    btn.disable();
                },
                update: function() {
                    if (btn.isEnabled) {
                        btn.update();
                    }
                },
                draw: function(ctx) {
                    var m = getVisibleMenu();
                    if (m) {
                        ctx.fillStyle = "rgba(0,0,0,0.8)";
                        ctx.fillRect(-mapPad-1,-mapPad-1,mapWidth+1,mapHeight+1);
                        m.draw(ctx);
                    }
                    else {
                        btn.draw(ctx);
                    }
                },
                isOpen: function() {
                    return getVisibleMenu() != undefined;
                },
                getMenu: function() {
                    return getVisibleMenu();
                },
                getMenuButton: function() {
                    return btn;
                },
            };
            })();

            //@line 1 "src/sprites.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Sprites
            // (sprites are created using canvas paths)

            var drawGhostSprite = (function(){

            // add top of the ghost head to the current canvas path
            var addHead = (function() {

                // pixel coordinates for the top of the head
                // on the original arcade ghost sprite
                var coords = [
                    0,6,
                    1,3,
                    2,2,
                    3,1,
                    4,1,
                    5,0,
                    8,0,
                    9,1,
                    10,1,
                    11,2,
                    12,3,
                    13,6,
                ];

                return function(ctx) {
                    var i;
                    ctx.save();

                    // translate by half a pixel to the right
                    // to try to force centering
                    ctx.translate(0.5,0);

                    ctx.moveTo(0,6);
                    ctx.quadraticCurveTo(1.5,0,6.5,0);
                    ctx.quadraticCurveTo(11.5,0,13,6);

                    // draw lines between pixel coordinates
                    /*
                    ctx.moveTo(coords[0],coords[1]);
                    for (i=2; i<coords.length; i+=2)
                        ctx.lineTo(coords[i],coords[i+1]);
                    */

                    ctx.restore();
                };
            })();

            // add first ghost animation frame feet to the current canvas path
            var addFeet1 = (function(){

                // pixel coordinates for the first feet animation
                // on the original arcade ghost sprite
                var coords = [
                    13,13,
                    11,11,
                    9,13,
                    8,13,
                    8,11,
                    5,11,
                    5,13,
                    4,13,
                    2,11,
                    0,13,
                ];

                return function(ctx) {
                    var i;
                    ctx.save();

                    // translate half a pixel right and down
                    // to try to force centering and proper height
                    ctx.translate(0.5,0.5);

                    // continue previous path (assuming ghost head)
                    // by drawing lines to each of the pixel coordinates
                    for (i=0; i<coords.length; i+=2)
                        ctx.lineTo(coords[i],coords[i+1]);

                    ctx.restore();
                };

            })();

            // add second ghost animation frame feet to the current canvas path
            var addFeet2 = (function(){

                // pixel coordinates for the second feet animation
                // on the original arcade ghost sprite
                var coords = [
                    13,12,
                    12,13,
                    11,13,
                    9,11,
                    7,13,
                    6,13,
                    4,11,
                    2,13,
                    1,13,
                    0,12,
                ];

                return function(ctx) {
                    var i;
                    ctx.save();

                    // translate half a pixel right and down
                    // to try to force centering and proper height
                    ctx.translate(0.5,0.5);

                    // continue previous path (assuming ghost head)
                    // by drawing lines to each of the pixel coordinates
                    for (i=0; i<coords.length; i+=2)
                        ctx.lineTo(coords[i],coords[i+1]);

                    ctx.restore();
                };

            })();

            // draw regular ghost eyes
            var addEyes = function(ctx,dirEnum){
                var i;

                ctx.save();
                ctx.translate(2,3);

                var coords = [
                    0,1,
                    1,0,
                    2,0,
                    3,1,
                    3,3,
                    2,4,
                    1,4,
                    0,3
                ];

                var drawEyeball = function() {
                    ctx.translate(0.5,0.5);
                    ctx.beginPath();
                    ctx.moveTo(coords[0],coords[1]);
                    for (i=2; i<coords.length; i+=2)
                        ctx.lineTo(coords[i],coords[i+1]);
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    ctx.translate(-0.5,-0.5);
                    //ctx.fillRect(1,0,2,5); // left
                    //ctx.fillRect(0,1,4,3);
                };

                // translate eye balls to correct position
                if (dirEnum == DIR_LEFT) ctx.translate(-1,0);
                else if (dirEnum == DIR_RIGHT) ctx.translate(1,0);
                else if (dirEnum == DIR_UP) ctx.translate(0,-1);
                else if (dirEnum == DIR_DOWN) ctx.translate(0,1);

                // draw eye balls
                ctx.fillStyle = "#FFF";
                ctx.strokeStyle = "#FFF";
                ctx.lineWidth = 1.0;
                ctx.lineJoin = 'round';
                drawEyeball();
                ctx.translate(6,0);
                drawEyeball();

                // translate pupils to correct position
                if (dirEnum == DIR_LEFT) ctx.translate(0,2);
                else if (dirEnum == DIR_RIGHT) ctx.translate(2,2);
                else if (dirEnum == DIR_UP) ctx.translate(1,0);
                else if (dirEnum == DIR_DOWN) ctx.translate(1,3);

                // draw pupils
                ctx.fillStyle = "#00F";
                ctx.fillRect(0,0,2,2); // right
                ctx.translate(-6,0);
                ctx.fillRect(0,0,2,2); // left

                ctx.restore();
            };

            // draw scared ghost face
            var addScaredFace = function(ctx,flash){
                ctx.strokeStyle = ctx.fillStyle = flash ? "#F00" : "#FF0";

                // eyes
                ctx.fillRect(4,5,2,2);
                ctx.fillRect(8,5,2,2);

                // mouth
                var coords = [
                    1,10,
                    2,9,
                    3,9,
                    4,10,
                    5,10,
                    6,9,
                    7,9,
                    8,10,
                    9,10,
                    10,9,
                    11,9,
                    12,10,
                ];
                ctx.translate(0.5,0.5);
                ctx.beginPath();
                ctx.moveTo(coords[0],coords[1]);
                for (i=2; i<coords.length; i+=2)
                    ctx.lineTo(coords[i],coords[i+1]);
                ctx.lineWidth = 1.0;
                ctx.stroke();
                ctx.translate(-0.5,-0.5);
                /*
                ctx.fillRect(1,10,1,1);
                ctx.fillRect(12,10,1,1);
                ctx.fillRect(2,9,2,1);
                ctx.fillRect(6,9,2,1);
                ctx.fillRect(10,9,2,1);
                ctx.fillRect(4,10,2,1);
                ctx.fillRect(8,10,2,1);
                */
            };


            return function(ctx,x,y,frame,dirEnum,scared,flash,eyes_only,color) {
                ctx.save();
                ctx.translate(x-7,y-7);

                if (scared)
                    color = flash ? "#FFF" : "#2121ff";

                if (!eyes_only) {
                    // draw body
                    ctx.beginPath();
                    addHead(ctx);
                    if (frame == 0)
                        addFeet1(ctx);
                    else
                        addFeet2(ctx);
                    ctx.closePath();
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                    ctx.fillStyle = color;
                    ctx.fill();
                }

                // draw face
                if (scared)
                    addScaredFace(ctx, flash);
                else
                    addEyes(ctx,dirEnum);

                ctx.restore();
            };
            })();

            // draw points displayed when pac-man eats a ghost or a fruit
            var drawPacPoints = (function(){
            var ctx;
            var color;

            var plotOutline = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var plotLine = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var draw0 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotOutline([
                    1,0,
                    2,0,
                    3,1,
                    3,5,
                    2,6,
                    1,6,
                    0,5,
                    0,1,
                ],color);
                ctx.restore();
            };

            var draw1narrow = function(x,y) {
                plotLine([x,y,x,y+6],color);
            };

            var draw1 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,1,
                    1,0,
                    1,6,
                    0,6,
                    2,6,
                ],color);
                ctx.restore();
            };

            var draw2 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,2,
                    0,1,
                    1,0,
                    3,0,
                    4,1,
                    4,2,
                    0,6,
                    4,6,
                ],color);
                ctx.restore();
            };

            var draw3 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,0,
                    4,0,
                    2,2,
                    4,4,
                    4,5,
                    3,6,
                    1,6,
                    0,5,
                ],color);
                ctx.restore();
            };

            var draw4 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    3,6,
                    3,0,
                    0,3,
                    0,4,
                    4,4,
                ],color);
                ctx.restore();
            };

            var draw5 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    4,0,
                    0,0,
                    0,2,
                    3,2,
                    4,3,
                    4,5,
                    3,6,
                    1,6,
                    0,5,
                ],color);
                ctx.restore();
            };

            var draw6 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    3,0,
                    1,0,
                    0,1,
                    0,5,
                    1,6,
                    2,6,
                    3,5,
                    3,3,
                    0,3,
                ],color);
                ctx.restore();
            };

            var draw7 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,1,
                    0,0,
                    4,0,
                    4,1,
                    2,4,
                    2,6,
                ],color);
                ctx.restore();
            };

            var draw8 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotOutline([
                    1,0,
                    3,0,
                    4,1,
                    4,2,
                    3,3,
                    1,3,
                    0,4,
                    0,5,
                    1,6,
                    3,6,
                    4,5,
                    4,4,
                    3,3,
                    1,3,
                    0,2,
                    0,1,
                ],color);
                ctx.restore();
            };

            var draw100 = function() {
                draw1(-5,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw200 = function() {
                draw2(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw300 = function() {
                draw3(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw400 = function() {
                draw4(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw500 = function() {
                draw5(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw700 = function() {
                draw7(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw800 = function() {
                draw8(-7,-3);
                draw0(-1,-3);
                draw0(4,-3);
            };

            var draw1000 = function() {
                draw1(-8,-3);
                draw0(-4,-3);
                draw0(1,-3);
                draw0(6,-3);
            };

            var draw1600 = function() {
                draw1narrow(-7,-3);
                draw6(-5,-3);
                draw0(0,-3);
                draw0(5,-3);
            };

            var draw2000 = function() {
                draw2(-10,-3);
                draw0(-4,-3);
                draw0(1,-3);
                draw0(6,-3);
            };

            var draw3000 = function() {
                draw3(-10,-3);
                draw0(-4,-3);
                draw0(1,-3);
                draw0(6,-3);
            };

            var draw5000 = function() {
                draw5(-10,-3);
                draw0(-4,-3);
                draw0(1,-3);
                draw0(6,-3);
            };

            return function(_ctx,x,y,points,_color) {
                ctx = _ctx;
                color = _color;

                ctx.save();
                ctx.translate(x+0.5,y+0.5);
                ctx.translate(0,-1);

                var f = {
                    100: draw100,
                    200: draw200,
                    300: draw300,
                    400: draw400,
                    500: draw500,
                    700: draw700,
                    800: draw800,
                    1000: draw1000,
                    1600: draw1600,
                    2000: draw2000,
                    3000: draw3000,
                    5000: draw5000,
                }[points];

                if (f) {
                    f();
                }

                ctx.restore();
            };
            })();

            // draw points displayed when ms. pac-man eats a fruit
            var drawMsPacPoints = (function(){
            var ctx;
            var color = "#fff";

            var plotOutline = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var plotLine = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };


            var draw0 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotOutline([
                    0,0,
                    2,0,
                    2,4,
                    0,4,
                ],color);
                ctx.restore();
            };

            var draw1 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    1,0,
                    1,4,
                ],color);
                ctx.restore();
            };

            var draw2 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,0,
                    2,0,
                    2,2,
                    0,2,
                    0,4,
                    2,4,
                ],color);
                ctx.restore();
            };

            var draw5 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    2,0,
                    0,0,
                    0,2,
                    2,2,
                    2,4,
                    0,4,
                ],color);
                ctx.restore();
            };

            var draw7 = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotLine([
                    0,0,
                    2,0,
                    2,4,
                ],color);
                ctx.restore();
            };

            var draw100 = function() {
                draw1(-5,-5);
                draw0(-1,-2);
                draw0(3,1);
            };

            var draw200 = function() {
                draw2(-5,-5);
                draw0(-1,-2);
                draw0(3,1);
            };

            var draw500 = function() {
                draw5(-5,-5);
                draw0(-1,-2);
                draw0(3,1);
            };

            var draw700 = function() {
                draw7(-5,-5);
                draw0(-1,-2);
                draw0(3,1);
            };

            var draw1000 = function() {
                draw1(-7,-7);
                draw0(-3,-4);
                draw0(1,-1);
                draw0(5,2);
            };

            var draw2000 = function() {
                draw2(-7,-7);
                draw0(-3,-4);
                draw0(1,-1);
                draw0(5,2);
            };

            var draw5000 = function() {
                draw5(-7,-7);
                draw0(-3,-4);
                draw0(1,-1);
                draw0(5,2);
            };

            return function(_ctx,x,y,points) {
                ctx = _ctx;

                ctx.save();
                ctx.translate(x+0.5,y+0.5);

                var f = {
                    100: draw100,
                    200: draw200,
                    500: draw500,
                    700: draw700,
                    1000: draw1000,
                    2000: draw2000,
                    5000: draw5000,
                }[points];

                if (f) {
                    f();
                }

                ctx.restore();
            };
            })();

            var drawMonsterSprite = (function(){
            var ctx;
            var color;

            var plotOutline = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var plotLine = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var plotSolid = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineJoin = "round";
                ctx.fillStyle = ctx.strokeStyle = color;
                ctx.fill();
                ctx.stroke();
            };


            // draw regular ghost eyes
            var drawEye = function(dirEnum,x,y){
                var i;

                ctx.save();
                ctx.translate(x,y);

                plotSolid([
                    0,1,
                    1,0,
                    2,0,
                    3,1,
                    3,3,
                    2,4,
                    1,4,
                    0,3
                ],"#FFF");

                // translate pupil to correct position
                if (dirEnum == DIR_LEFT) ctx.translate(0,2);
                else if (dirEnum == DIR_RIGHT) ctx.translate(2,2);
                else if (dirEnum == DIR_UP) ctx.translate(1,0);
                else if (dirEnum == DIR_DOWN) ctx.translate(1,3);

                // draw pupil
                plotSolid([
                    0,0,
                    1,0,
                    1,1,
                    0,1,
                ],"#00F");

                ctx.restore();
            };

            var drawRightBody = function() {
                plotSolid([
                    -7,-3,
                    -3,-7,
                    -1,-7,
                    -2,-6,
                    0,-4,
                    3,-7,
                    5,-7,
                    4,-7,
                    3,-6,
                    6,-3,
                    6,1,
                    5,3,
                    2,6,
                    -4,6,
                    -5,5,
                    -7,1,
                ],color);
            };

            var drawRightShoe = function(x,y) {
                ctx.save();
                ctx.translate(x,y);
                plotSolid([
                    0,0,
                    3,-3,
                    4,-3,
                    5,-2,
                    5,-1,
                    4,0,
                ],"#00F");
                ctx.restore();
            };

            var drawRight0 = function() {
                // antenna tips
                plotLine([-1,-7,0,-6],"#FFF");
                plotLine([5,-7,6,-6],"#FFF");

                drawRightBody();

                drawRightShoe(1,6);
                plotLine([-4,6,-1,6],"#00F");

                drawEye(DIR_RIGHT,-4,-4);
                drawEye(DIR_RIGHT,2,-4);
            };

            var drawRight1 = function() {
                // antenna tips
                plotLine([-1,-7,0,-7],"#FFF");
                plotLine([5,-7,6,-7],"#FFF");

                drawRightBody();

                drawRightShoe(-4,6);
                plotLine([2,6,5,6],"#00F");

                drawEye(DIR_RIGHT,-4,-4);
                drawEye(DIR_RIGHT,2,-4);
            };

            var drawLeft0 = function() {
                ctx.scale(-1,1);
                ctx.translate(1,0);
                drawRight0();
            };

            var drawLeft1 = function() {
                ctx.scale(-1,1);
                ctx.translate(1,0);
                drawRight1();
            };

            var drawUpDownBody0 = function() {
                plotLine([-6,-7,-7,-6],"#FFF");
                plotLine([5,-7,6,-6],"#FFF");
                plotSolid([
                    -7,-3,
                    -4,-6,
                    -5,-7,
                    -6,-7,
                    -4,-7,
                    -3,-6,
                    -2,-6,
                    -1,-5,
                    0,-5,
                    1,-6,
                    2,-6,
                    3,-7,
                    5,-7,
                    4,-7,
                    3,-6,
                    6,-3,
                    6,1,
                    5,3,
                    4,5,
                    3,6,
                    -4,6,
                    -5,5,
                    -6,3,
                    -7,1,
                ],color);
            };

            var drawUpDownBody1 = function() {
                plotLine([-6,-6,-7,-5],"#FFF");
                plotLine([5,-6,6,-5],"#FFF");
                plotSolid([
                    -7,-3,
                    -4,-6,
                    -5,-7,
                    -6,-6,
                    -5,-7,
                    -4,-7,
                    -3,-6,
                    -2,-6,
                    -1,-5,
                    0,-5,
                    1,-6,
                    2,-6,
                    3,-7,
                    4,-7,
                    5,-6,
                    4,-7,
                    3,-6,
                    6,-3,
                    6,1,
                    5,3,
                    4,5,
                    3,6,
                    -4,6,
                    -5,5,
                    -6,3,
                    -7,1,
                ],color);
            };

            var drawUp0 = function() {
                drawUpDownBody0();
                drawEye(DIR_UP,-5,-5);
                drawEye(DIR_UP,1,-5);
                plotSolid([
                    -4,6,
                    -3,5,
                    -2,5,
                    -1,6,
                ],"#00F");
            };

            var drawUp1 = function() {
                drawUpDownBody1();
                drawEye(DIR_UP,-5,-5);
                drawEye(DIR_UP,1,-5);
                plotSolid([
                    0,6,
                    1,5,
                    2,5,
                    3,6,
                ],"#00F");
            };

            var drawDown0 = function() {
                drawUpDownBody0();
                drawEye(DIR_DOWN,-5,-4);
                drawEye(DIR_DOWN,1,-4);
                plotSolid([
                    0,6,
                    1,4,
                    2,3,
                    3,3,
                    4,4,
                    4,5,
                    3,6,
                ],"#00F");
                plotLine([-4,6,-2,6],"#00F");
            };

            var drawDown1 = function() {
                drawUpDownBody1();
                drawEye(DIR_DOWN,-5,-4);
                drawEye(DIR_DOWN,1,-4);
                plotSolid([
                    -1,6,
                    -2,4,
                    -3,3,
                    -4,3,
                    -5,4,
                    -5,5,
                    -4,6,
                ],"#00F");
                plotLine([1,6,3,6],"#00F");
            };

            var borderColor;
            var faceColor;

            var drawScaredBody = function() {
                plotOutline([
                    -6,-2,
                    -2,-5,
                    -3,-6,
                    -5,-6,
                    -3,-6,
                    -1,-4,
                    1,-4,
                    3,-6,
                    5,-6,
                    3,-6,
                    2,-5,
                    6,-2,
                    6,4,
                    5,6,
                    4,7,
                    -4,7,
                    -5,6,
                    -6,4
                ],borderColor);

                plotLine([
                    -2,4,
                    -1,3,
                    1,3,
                    2,4
                ],faceColor);
            };


            var drawScared0 = function(flash) {
                plotLine([-2,-2,-2,0],faceColor);
                plotLine([-3,-1,-1,-1],faceColor);
                plotLine([2,-2,2,0],faceColor);
                plotLine([3,-1,1,-1],faceColor);
                plotLine([-5,-6,-6,-7],"#FFF");
                plotLine([5,-6,6,-7],"#FFF");
                drawScaredBody();
            };

            var drawScared1 = function(flash) {
                plotLine([-3,-2,-1,0],faceColor);
                plotLine([-3,0,-1,-2],faceColor);
                plotLine([1,-2,3,0],faceColor);
                plotLine([1,0,3,-2],faceColor);
                plotLine([-5,-6,-6,-5],"#FFF");
                plotLine([5,-6,6,-5],"#FFF");
                drawScaredBody();
            };

            return function(_ctx,x,y,frame,dirEnum,scared,flash,eyes_only,_color) {
                if (eyes_only) {
                    return; // invisible
                }

                ctx = _ctx;
                color = _color;

                ctx.save();
                ctx.translate(x+0.5,y+0.5);

                if (scared) {
                    ctx.translate(0,-1); // correct alignment error from my chosen coordinates
                    borderColor = flash ? "#FFF" : "#00F";
                    faceColor = flash ? "#F00" : "#FF0";
                    [drawScared0, drawScared1][frame]();
                }
                else if (dirEnum == DIR_RIGHT) {
                    [drawRight0, drawRight1][frame]();
                }
                else if (dirEnum == DIR_LEFT) {
                    [drawLeft0, drawLeft1][frame]();
                }
                else if (dirEnum == DIR_DOWN) {
                    [drawDown0, drawDown1][frame]();
                }
                else if (dirEnum == DIR_UP) {
                    [drawUp0, drawUp1][frame]();
                }

                ctx.restore();
            };
            })();

            var drawColoredOttoSprite = function(color,eyeColor) {
            var ctx;

            var plotLine = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };

            var plotSolid = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineJoin = "round";
                ctx.fillStyle = ctx.strokeStyle = color;
                ctx.fill();
                ctx.stroke();
            };

            var drawRightEye = function() {
                plotSolid([
                    -4,-5,
                    -3,-6,
                    -2,-6,
                    -2,-5,
                    -3,-4,
                    -4,-4,
                ],eyeColor);
            };

            var drawRight0 = function() {
                plotSolid([
                    -5,-4,
                    -3,-6,
                    2,-6,
                    3,-5,
                    -1,-3,
                    3,-1,
                    1,1,
                    1,3,
                    3,6,
                    5,4,
                    6,4,
                    6,5,
                    4,7,
                    2,7,
                    -1,1,
                    -4,4,
                    -3,6,
                    -3,7,
                    -4,7,
                    -6,5,
                    -6,4,
                    -3,1,
                    -5,-1,
                ],color);
                drawRightEye();
            };
            var drawRight1 = function() {
                plotSolid([
                    -5,-4,
                    -3,-6,
                    1,-6,
                    3,-4,
                    3,-1,
                    1,1,
                    1,6,
                    4,6,
                    4,7,
                    0,7,
                    0,1,
                    -2,1,
                    -4,3,
                    -4,4,
                    -3,5,
                    -3,6,
                    -4,6,
                    -5,4,
                    -5,3,
                    -3,1,
                    -5,-1,
                ],color);
                drawRightEye();
            };
            var drawRight2 = function() {
                plotSolid([
                    -5,-4,
                    -3,-6,
                    2,-6,
                    3,-5,
                    -1,-3,
                    3,-1,
                    1,1,
                    1,3,
                    4,3,
                    4,4,
                    0,4,
                    0,1,
                    -2,1,
                    -2,6,
                    1,6,
                    1,7,
                    -3,7,
                    -3,1,
                    -5,-1,
                ],color);
                drawRightEye();
            };
            var drawRight3 = function() {
                plotSolid([
                    -5,-4,
                    -3,-6,
                    2,-6,
                    -2,-3,
                    2,0,
                    1,1,
                    3,5,
                    5,3,
                    6,3,
                    6,4,
                    4,6,
                    2,6,
                    -1,1,
                    -3,1,
                    -3,6,
                    0,6,
                    0,7,
                    -4,7,
                    -4,2,
                    -3,1,
                    -5,-1,
                ],color);
                drawRightEye();
            };

            var drawUpDownEyes = function() {
                plotSolid([
                    -5,-5,
                    -4,-6,
                    -3,-6,
                    -3,-5,
                    -4,-4,
                    -5,-4,
                ],eyeColor);
                plotSolid([
                    3,-6,
                    4,-6,
                    5,-5,
                    5,-4,
                    4,-4,
                    3,-5,
                ],eyeColor);
            };

            var drawUpDownHead = function() {
                plotSolid([
                    -4,-4,
                    -2,-6,
                    2,-6,
                    4,-4,
                    4,-1,
                    2,1,
                    -2,1,
                    -4,-1,
                ],color);
            };

            var drawUpDownLeg0 = function(y,xs) {
                ctx.save();
                ctx.translate(0,y);
                ctx.scale(xs,1);

                plotSolid([
                    1,0,
                    2,0,
                    2,6,
                    4,6,
                    4,7,
                    1,7,
                ],color);

                ctx.restore();
            };

            var drawUpDownLeg1 = function(y,xs) {
                ctx.save();
                ctx.translate(0,y);
                ctx.scale(xs,1);

                plotSolid([
                    1,0,
                    2,0,
                    2,4,
                    3,5,
                    4,4,
                    5,4,
                    5,5,
                    3,7,
                    2,7,
                    1,6,
                ],color);

                ctx.restore();
            };
            var drawUpDownLegs0 = function() {
                drawUpDownLeg0(0,-1);
                drawUpDownLeg1(-2,1);
            };

            var drawUpDownLegs1 = function() {
                drawUpDownLeg0(-2,-1);
                drawUpDownLeg1(-2,1);
            };

            var drawUpDownLegs2 = function() {
                drawUpDownLeg1(-2,-1);
                drawUpDownLeg0(0,1);
            };

            var drawUpDownLegs3 = function() {
                drawUpDownLeg1(0,-1);
                drawUpDownLeg0(0,1);
            };

            var drawDown0 = function() {
                drawUpDownHead();
                drawUpDownEyes();
                drawUpDownLegs0();
                plotLine([-2,-3,2,-3],"#000");
            };
            var drawDown1 = function() {
                drawUpDownHead();
                drawUpDownEyes();
                drawUpDownLegs1();
            };
            var drawDown2 = function() {
                drawUpDownHead();
                drawUpDownEyes();
                drawUpDownLegs2();
                plotLine([-2,-3,2,-3],"#000");
            };
            var drawDown3 = function() {
                drawUpDownHead();
                drawUpDownEyes();
                drawUpDownLegs3();
                plotSolid([
                    -2,-3,
                    0,-5,
                    2,-3,
                    0,-1,
                ],"#000");
            };

            var drawUp0 = function() {
                drawUpDownEyes();
                drawUpDownHead();
                drawUpDownLegs0();
            };
            var drawUp1 = function() {
                drawUpDownEyes();
                drawUpDownHead();
                drawUpDownLegs1();
            };
            var drawUp2 = function() {
                drawUpDownEyes();
                drawUpDownHead();
                drawUpDownLegs2();
            };
            var drawUp3 = function() {
                drawUpDownEyes();
                drawUpDownHead();
                drawUpDownLegs3();
            };

            return function(_ctx,x,y,dirEnum,frame,rotate) {
                ctx = _ctx;

                ctx.save();
                ctx.translate(x+0.5,y+0.5);
                if (rotate) {
                    ctx.rotate(rotate);
                }

                if (dirEnum == DIR_RIGHT) {
                    ctx.translate(0,-1); // correct my coordinate system
                    [drawRight0, drawRight1, drawRight2, drawRight3][frame]();
                }
                else if (dirEnum == DIR_LEFT) {
                    ctx.translate(0,-1); // correct my coordinate system
                    ctx.scale(-1,1);
                    [drawRight0, drawRight1, drawRight2, drawRight3][frame]();
                }
                else if (dirEnum == DIR_DOWN) {
                    ctx.translate(0,-1); // correct my coordinate system
                    [drawDown0, drawDown1, drawDown2, drawDown3][frame]();
                }
                else if (dirEnum == DIR_UP) {
                    ctx.translate(0,-1); // correct my coordinate system
                    [drawUp0, drawUp1, drawUp2, drawUp3][frame]();
                }

                ctx.restore();
            };
            };

            var drawOttoSprite = drawColoredOttoSprite("#FF0","#00F");
            var drawMsOttoSprite = drawColoredOttoSprite("#F00","#FFF");

            var drawDeadOttoSprite = function(ctx,x,y) {
            var plotOutline = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.strokeStyle = color;
                ctx.stroke();
            };
            ctx.save();
            ctx.translate(x+2,y);
            plotOutline([
                3,-5,
                -1,-5,
                -2,-6,
                -2,-7,
                -1,-8,
                3,-8,
                4,-7,
                4,-6,
            ],"#F00");
            ctx.restore();
            drawOttoSprite(ctx,x,y,DIR_LEFT,2,Math.PI/2);
            };

            // draw pacman body
            var drawPacmanSprite = function(ctx,x,y,dirEnum,angle,mouthShift,scale,centerShift,alpha,color,rot_angle) {

            if (mouthShift == undefined) mouthShift = 0;
            if (centerShift == undefined) centerShift = 0;
            if (scale == undefined) scale = 1;
            if (alpha == undefined) alpha = 1;

            if (color == undefined) {
                color = "rgba(255,255,0," + alpha + ")";
            }

            ctx.save();
            ctx.translate(x,y);
            ctx.scale(scale,scale);
            if (rot_angle) {
                ctx.rotate(rot_angle);
            }

            // rotate to current heading direction
            var d90 = Math.PI/2;
            if (dirEnum == DIR_UP) ctx.rotate(3*d90);
            else if (dirEnum == DIR_RIGHT) ctx.rotate(0);
            else if (dirEnum == DIR_DOWN) ctx.rotate(d90);
            else if (dirEnum == DIR_LEFT) ctx.rotate(2*d90);

            // plant corner of mouth
            ctx.beginPath();
            ctx.moveTo(-3+mouthShift,0);

            // draw head outline
            ctx.arc(centerShift,0,6.5,angle,2*Math.PI-angle);
            ctx.closePath();

            //ctx.strokeStyle = color;
            //ctx.stroke();
            ctx.fillStyle = color;
            ctx.fill();

            ctx.restore();
            };

            // draw giant pacman body
            var drawGiantPacmanSprite = function(ctx,x,y,dirEnum,frame) {

            var color = "#FF0";
            var mouthShift = 0;
            var angle = 0;
            if (frame == 1) {
                mouthShift = -4;
                angle = Math.atan(7/14);
            }
            else if (frame == 2) {
                mouthShift = -2;
                angle = Math.atan(13/9);
            }

            ctx.save();
            ctx.translate(x,y);

            // rotate to current heading direction
            var d90 = Math.PI/2;
            if (dirEnum == DIR_UP) ctx.rotate(3*d90);
            else if (dirEnum == DIR_RIGHT) ctx.rotate(0);
            else if (dirEnum == DIR_DOWN) ctx.rotate(d90);
            else if (dirEnum == DIR_LEFT) ctx.rotate(2*d90);

            // plant corner of mouth
            ctx.beginPath();
            ctx.moveTo(mouthShift,0);

            // draw head outline
            ctx.arc(0,0,16,angle,2*Math.PI-angle);
            ctx.closePath();

            ctx.fillStyle = color;
            ctx.fill();

            ctx.restore();
            };

            var drawMsPacmanSprite = function(ctx,x,y,dirEnum,frame,rot_angle) {
            var angle = 0;

            // draw body
            if (frame == 0) {
                // closed
                drawPacmanSprite(ctx,x,y,dirEnum,0,undefined,undefined,undefined,undefined,undefined,rot_angle);
            }
            else if (frame == 1) {
                // open
                angle = Math.atan(4/5);
                drawPacmanSprite(ctx,x,y,dirEnum,angle,undefined,undefined,undefined,undefined,undefined,rot_angle);
                angle = Math.atan(4/8); // angle for drawing eye
            }
            else if (frame == 2) {
                // wide
                angle = Math.atan(6/3);
                drawPacmanSprite(ctx,x,y,dirEnum,angle,undefined,undefined,undefined,undefined,undefined,rot_angle);
                angle = Math.atan(6/6); // angle for drawing eye
            }

            ctx.save();
            ctx.translate(x,y);
            if (rot_angle) {
                ctx.rotate(rot_angle);
            }

            // reflect or rotate sprite according to current direction
            var d90 = Math.PI/2;
            if (dirEnum == DIR_UP)
                ctx.rotate(-d90);
            else if (dirEnum == DIR_DOWN)
                ctx.rotate(d90);
            else if (dirEnum == DIR_LEFT)
                ctx.scale(-1,1);

            // bow
            var x=-7.5,y=-7.5;
            ctx.fillStyle = "#F00";
            ctx.beginPath(); ctx.arc(x+1,y+4,1.25,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.arc(x+2,y+5,1.25,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.arc(x+3,y+3,1.25,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.arc(x+4,y+1,1.25,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.arc(x+5,y+2,1.25,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.fillStyle = "#0031FF";
            ctx.beginPath(); ctx.arc(x+2.5,y+3.5,0.5,0,Math.PI*2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.arc(x+3.5,y+2.5,0.5,0,Math.PI*2); ctx.closePath(); ctx.fill();

            // lips
            ctx.strokeStyle = "#F00";
            ctx.lineWidth = 1.25;
            ctx.lineCap = "round";
            ctx.beginPath();
            if (frame == 0) {
                ctx.moveTo(5,0);
                ctx.lineTo(6.5,0);
                ctx.moveTo(6.5,-1.5);
                ctx.lineTo(6.5,1.5);
            }
            else {
                var r1 = 7.5;
                var r2 = 8.5;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                ctx.moveTo(-3+r1*c,r1*s);
                ctx.lineTo(-3+r2*c,r2*s);
                ctx.moveTo(-3+r1*c,-r1*s);
                ctx.lineTo(-3+r2*c,-r2*s);
            }
            ctx.stroke();

            // mole
            ctx.beginPath();
            ctx.arc(-3,2,0.5,0,Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.fill();

            // eye
            ctx.strokeStyle = "#000";
            ctx.lineCap = "round";
            ctx.beginPath();
            if (frame == 0) {
                ctx.moveTo(-2.5,-2);
                ctx.lineTo(-0.5,-2);
            }
            else {
                var r1 = 0.5;
                var r2 = 2.5;
                var c = Math.cos(angle);
                var s = Math.sin(angle);
                ctx.moveTo(-3+r1*c,-2-r1*s);
                ctx.lineTo(-3+r2*c,-2-r2*s);
            }
            ctx.stroke();

            ctx.restore();
            };

            var drawCookiemanSprite = (function(){

            // TODO: draw pupils separately in atlas
            //      composite the body frame and a random pupil frame when drawing cookie-man

            var prevFrame = undefined;
            var sx1 = 0; // shift x for first pupil
            var sy1 = 0; // shift y for first pupil
            var sx2 = 0; // shift x for second pupil
            var sy2 = 0; // shift y for second pupil

            var er = 2.1; // eye radius
            var pr = 1; // pupil radius

            var movePupils = function() {
                var a1 = Math.random()*Math.PI*2;
                var a2 = Math.random()*Math.PI*2;
                var r1 = Math.random()*pr;
                var r2 = Math.random()*pr;

                sx1 = Math.cos(a1)*r1;
                sy1 = Math.sin(a1)*r1;
                sx2 = Math.cos(a2)*r2;
                sy2 = Math.sin(a2)*r2;
            };

            return function(ctx,x,y,dirEnum,frame,shake,rot_angle) {
                var angle = 0;

                // draw body
                var draw = function(angle) {
                    //angle = Math.PI/6*frame;
                    drawPacmanSprite(ctx,x,y,dirEnum,angle,undefined,undefined,undefined,undefined,"#47b8ff",rot_angle);
                };
                if (frame == 0) {
                    // closed
                    draw(0);
                }
                else if (frame == 1) {
                    // open
                    angle = Math.atan(4/5);
                    draw(angle);
                    angle = Math.atan(4/8); // angle for drawing eye
                }
                else if (frame == 2) {
                    // wide
                    angle = Math.atan(6/3);
                    draw(angle);
                    angle = Math.atan(6/6); // angle for drawing eye
                }

                ctx.save();
                ctx.translate(x,y);
                if (rot_angle) {
                    ctx.rotate(rot_angle);
                }

                // reflect or rotate sprite according to current direction
                var d90 = Math.PI/2;
                if (dirEnum == DIR_UP)
                    ctx.rotate(-d90);
                else if (dirEnum == DIR_DOWN)
                    ctx.rotate(d90);
                else if (dirEnum == DIR_LEFT)
                    ctx.scale(-1,1);

                var x = -4; // pivot point
                var y = -3.5;
                var r1 = 3;   // distance from pivot of first eye
                var r2 = 6; // distance from pivot of second eye
                angle /= 3; // angle from pivot point
                angle += Math.PI/8;
                var c = Math.cos(angle);
                var s = Math.sin(angle);

                if (shake) {
                    if (frame != prevFrame) {
                        movePupils();
                    }
                    prevFrame = frame;
                }

                // second eyeball
                ctx.beginPath();
                ctx.arc(x+r2*c, y-r2*s, er, 0, Math.PI*2);
                ctx.fillStyle = "#FFF";
                ctx.fill();
                // second pupil
                ctx.beginPath();
                ctx.arc(x+r2*c+sx2, y-r2*s+sy2, pr, 0, Math.PI*2);
                ctx.fillStyle = "#000";
                ctx.fill();

                // first eyeball
                ctx.beginPath();
                ctx.arc(x+r1*c, y-r1*s, er, 0, Math.PI*2);
                ctx.fillStyle = "#FFF";
                ctx.fill();
                // first pupil
                ctx.beginPath();
                ctx.arc(x+r1*c+sx1, y-r1*s+sy1, pr, 0, Math.PI*2);
                ctx.fillStyle = "#000";
                ctx.fill();

                ctx.restore();

            };
            })();

            ////////////////////////////////////////////////////////////////////
            // FRUIT SPRITES

            var drawCherry = function(ctx,x,y) {

            // cherry
            var cherry = function(x,y) {
                ctx.save();
                ctx.translate(x,y);

                // red fruit
                ctx.beginPath();
                ctx.arc(2.5,2.5,3,0,Math.PI*2);
                ctx.lineWidth = 1.0;
                ctx.strokeStyle = "#000";
                ctx.stroke();
                ctx.fillStyle = "#ff0000";
                ctx.fill();

                // white shine
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(1,3);
                ctx.lineTo(2,4);
                ctx.strokeStyle = "#fff";
                ctx.stroke();
                ctx.restore();
            };

            ctx.save();
            ctx.translate(x,y);

            // draw both cherries
            cherry(-6,-1);
            cherry(-1,1);

            // draw stems
            ctx.beginPath();
            ctx.moveTo(-3,0);
            ctx.bezierCurveTo(-1,-2, 2,-4, 5,-5);
            ctx.lineTo(5,-4);
            ctx.bezierCurveTo(3,-4, 1,0, 1,2);
            ctx.strokeStyle = "#ff9900";
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.restore();
            };

            var drawStrawberry = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // red body
            ctx.beginPath();
            ctx.moveTo(-1,-4);
            ctx.bezierCurveTo(-3,-4,-5,-3, -5,-1);
            ctx.bezierCurveTo(-5,3,-2,5, 0,6);
            ctx.bezierCurveTo(3,5, 5,2, 5,0);
            ctx.bezierCurveTo(5,-3, 3,-4, 0,-4);
            ctx.fillStyle = "#f00";
            ctx.fill();
            ctx.strokeStyle = "#f00";
            ctx.stroke();

            // white spots
            var spots = [
                {x:-4,y:-1},
                {x:-3,y:2 },
                {x:-2,y:0 },
                {x:-1,y:4 },
                {x:0, y:2 },
                {x:0, y:0 },
                {x:2, y:4 },
                {x:2, y:-1 },
                {x:3, y:1 },
                {x:4, y:-2 } ];

            ctx.fillStyle = "#fff";
            var i,len;
            for (i=0, len=spots.length; i<len; i++) {
                var s = spots[i];
                ctx.beginPath();
                ctx.arc(s.x,s.y,0.75,0,2*Math.PI);
                ctx.fill();
            }

            // green leaf
            ctx.beginPath();
            ctx.moveTo(0,-4);
            ctx.lineTo(-3,-4);
            ctx.lineTo(0,-4);
            ctx.lineTo(-2,-3);
            ctx.lineTo(-1,-3);
            ctx.lineTo(0,-4);
            ctx.lineTo(0,-2);
            ctx.lineTo(0,-4);
            ctx.lineTo(1,-3);
            ctx.lineTo(2,-3);
            ctx.lineTo(0,-4);
            ctx.lineTo(3,-4);
            ctx.closePath();
            ctx.strokeStyle = "#00ff00";
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            // stem
            ctx.beginPath();
            ctx.moveTo(0,-4);
            ctx.lineTo(0,-5);
            ctx.lineCap = 'round';
            ctx.strokeStyle = "#fff";
            ctx.stroke();
            ctx.restore();
            };

            var drawOrange = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // orange body
            ctx.beginPath();
            ctx.moveTo(-2,-2);
            ctx.bezierCurveTo(-3,-2, -5,-1, -5,1);
            ctx.bezierCurveTo(-5,4, -3,6, 0,6);
            ctx.bezierCurveTo(3,6, 5,4, 5,1);
            ctx.bezierCurveTo(5,-1, 3,-2, 2,-2);
            ctx.closePath();
            ctx.fillStyle="#ffcc33";
            ctx.fill();
            ctx.strokeStyle = "#ffcc33";
            ctx.stroke();

            // stem
            ctx.beginPath();
            ctx.moveTo(-1,-1);
            ctx.quadraticCurveTo(-1,-2,-2,-2);
            ctx.quadraticCurveTo(-1,-2,-1,-4);
            ctx.quadraticCurveTo(-1,-2,0,-2);
            ctx.quadraticCurveTo(-1,-2,-1,-1);
            ctx.strokeStyle = "#ff9900";
            ctx.lineJoin = 'round';
            ctx.stroke();

            // green leaf
            ctx.beginPath();
            ctx.moveTo(-0.5,-4);
            ctx.quadraticCurveTo(0,-5,1,-5);
            ctx.bezierCurveTo(2,-5, 3,-4,4,-4);
            ctx.bezierCurveTo(3,-4, 3,-3, 2,-3);
            ctx.bezierCurveTo(1,-3,1,-4,-0.5,-4);
            ctx.strokeStyle = "#00ff00";
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.fillStyle = "#00ff00";
            ctx.fill();

            ctx.restore();
            };

            var drawApple = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // red fruit
            ctx.beginPath();
            ctx.moveTo(-2,-3);
            ctx.bezierCurveTo(-2,-4,-3,-4,-4,-4);
            ctx.bezierCurveTo(-5,-4,-6,-3,-6,0);
            ctx.bezierCurveTo(-6,3,-4,6,-2.5,6);
            ctx.quadraticCurveTo(-1,6,-1,5);
            ctx.bezierCurveTo(-1,6,0,6,1,6);
            ctx.bezierCurveTo(3,6, 5,3, 5,0);
            ctx.bezierCurveTo(5,-3, 3,-4, 2,-4);
            ctx.quadraticCurveTo(0,-4,0,-3);
            ctx.closePath();
            ctx.fillStyle = "#ff0000";
            ctx.fill();

            // stem
            ctx.beginPath();
            ctx.moveTo(-1,-3);
            ctx.quadraticCurveTo(-1,-5, 0,-5);
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#ff9900';
            ctx.stroke();

            // shine
            ctx.beginPath();
            ctx.moveTo(2,3);
            ctx.quadraticCurveTo(3,3, 3,1);
            ctx.lineCap = 'round';
            ctx.strokeStyle = "#fff";
            ctx.stroke();

            ctx.restore();
            };

            var drawMelon = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // draw body
            ctx.beginPath();
            ctx.arc(0,2,5.5,0,Math.PI*2);
            ctx.fillStyle = "#7bf331";
            ctx.fill();

            // draw stem
            ctx.beginPath();
            ctx.moveTo(0,-4);
            ctx.lineTo(0,-5);
            ctx.moveTo(2,-5);
            ctx.quadraticCurveTo(-3,-5,-3,-6);
            ctx.strokeStyle="#69b4af";
            ctx.lineCap = "round";
            ctx.stroke();

            // dark lines
            /*
            ctx.beginPath();
            ctx.moveTo(0,-2);
            ctx.lineTo(-4,2);
            ctx.lineTo(-1,5);
            ctx.moveTo(-3,-1);
            ctx.lineTo(-2,0);
            ctx.moveTo(-2,6);
            ctx.lineTo(1,3);
            ctx.moveTo(1,7);
            ctx.lineTo(3,5);
            ctx.lineTo(0,2);
            ctx.lineTo(3,-1);
            ctx.moveTo(2,0);
            ctx.lineTo(4,2);
            ctx.strokeStyle="#69b4af";
            ctx.lineCap = "round";
            ctx.lineJoin = 'round';
            ctx.stroke();
            */
            // dark spots
            var spots = [
                0,-2,
                -1,-1,
                -2,0,
                -3,1,
                -4,2,
                -3,3,
                -2,4,
                -1,5,
                -2,6,
                -3,-1,
                1,7,
                2,6,
                3,5,
                2,4,
                1,3,
                0,2,
                1,1,
                2,0,
                3,-1,
                3,1,
                4,2,
                ];

            ctx.fillStyle="#69b4af";
            var i,len;
            for (i=0, len=spots.length; i<len; i+=2) {
                var x = spots[i];
                var y = spots[i+1];
                ctx.beginPath();
                ctx.arc(x,y,0.65,0,2*Math.PI);
                ctx.fill();
            }

            // white spots
            var spots = [
                {x: 0,y:-3},
                {x:-2,y:-1},
                {x:-4,y: 1},
                {x:-3,y: 3},
                {x: 1,y: 0},
                {x:-1,y: 2},
                {x:-1,y: 4},
                {x: 3,y: 2},
                {x: 1,y: 4},
                ];

            ctx.fillStyle = "#fff";
            var i,len;
            for (i=0, len=spots.length; i<len; i++) {
                var s = spots[i];
                ctx.beginPath();
                ctx.arc(s.x,s.y,0.65,0,2*Math.PI);
                ctx.fill();
            }

            ctx.restore();
            };

            var drawGalaxian = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // draw yellow body
            ctx.beginPath();
            ctx.moveTo(-4,-2);
            ctx.lineTo(4,-2);
            ctx.lineTo(4,-1);
            ctx.lineTo(2,1);
            ctx.lineTo(1,0);
            ctx.lineTo(0,0);
            ctx.lineTo(0,5);
            ctx.lineTo(0,0);
            ctx.lineTo(-1,0);
            ctx.lineTo(-2,1);
            ctx.lineTo(-4,-1);
            ctx.closePath();
            ctx.lineJoin = 'round';
            ctx.strokeStyle = ctx.fillStyle = '#fffa36';
            ctx.fill();
            ctx.stroke();

            // draw red arrow head
            ctx.beginPath();
            ctx.moveTo(0,-5);
            ctx.lineTo(-3,-2);
            ctx.lineTo(-2,-2);
            ctx.lineTo(-1,-3);
            ctx.lineTo(0,-3);
            ctx.lineTo(0,-1);
            ctx.lineTo(0,-3);
            ctx.lineTo(1,-3);
            ctx.lineTo(2,-2);
            ctx.lineTo(3,-2);
            ctx.closePath();
            ctx.lineJoin = 'round';
            ctx.strokeStyle = ctx.fillStyle = "#f00";
            ctx.fill();
            ctx.stroke();

            // draw blue wings
            ctx.beginPath();
            ctx.moveTo(-5,-4);
            ctx.lineTo(-5,-1);
            ctx.lineTo(-2,2);
            ctx.moveTo(5,-4);
            ctx.lineTo(5,-1);
            ctx.lineTo(2,2);
            ctx.strokeStyle = "#00f";
            ctx.lineJoin = 'round';
            ctx.stroke();

            ctx.restore();
            };

            var drawBell = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // bell body
            ctx.beginPath();
            ctx.moveTo(-1,-5);
            ctx.bezierCurveTo(-4,-5,-6,1,-6,6);
            ctx.lineTo(5,6);
            ctx.bezierCurveTo(5,1,3,-5,0,-5);
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle = "#fffa37";
            ctx.stroke();
            ctx.fill();

            // marks
            ctx.beginPath();
            ctx.moveTo(-4,4);
            ctx.lineTo(-4,3);
            ctx.moveTo(-3,1);
            ctx.quadraticCurveTo(-3,-2,-2,-2);
            ctx.moveTo(-1,-4);
            ctx.lineTo(0,-4);
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000';
            ctx.stroke();

            // bell bottom
            ctx.beginPath();
            ctx.rect(-5.5,6,10,2);
            ctx.fillStyle = "#68b9fc";
            ctx.fill();
            ctx.beginPath();
            ctx.rect(-0.5,6,2,2);
            ctx.fillStyle = '#fff';
            ctx.fill();

            ctx.restore();
            };

            var drawKey = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // draw key metal
            ctx.beginPath();
            ctx.moveTo(-1,-2);
            ctx.lineTo(-1,5);
            ctx.moveTo(0,6);
            ctx.quadraticCurveTo(1,6,1,3);
            ctx.moveTo(1,4);
            ctx.lineTo(2,4);
            ctx.moveTo(1,1);
            ctx.lineTo(1,-2);
            ctx.moveTo(1,0);
            ctx.lineTo(2,0);
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#fff';
            ctx.stroke();

            // draw key top
            ctx.beginPath();
            ctx.moveTo(0,-6);
            ctx.quadraticCurveTo(-3,-6,-3,-4);
            ctx.lineTo(-3,-2);
            ctx.lineTo(3,-2);
            ctx.lineTo(3,-4);
            ctx.quadraticCurveTo(3,-6, 0,-6);
            ctx.strokeStyle = ctx.fillStyle = "#68b9fc";
            ctx.fill();
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(1,-5);
            ctx.lineTo(-1,-5);
            ctx.lineCap = 'round';
            ctx.strokeStyle = "#000";
            ctx.stroke();

            ctx.restore();
            };

            var drawPretzel = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // bread
            ctx.beginPath();
            ctx.moveTo(-2,-5);
            ctx.quadraticCurveTo(-4,-6,-6,-4);
            ctx.quadraticCurveTo(-7,-2,-5,1);
            ctx.quadraticCurveTo(-3,4,0,5);
            ctx.quadraticCurveTo(5,5,5,-1);
            ctx.quadraticCurveTo(6,-5,3,-5);
            ctx.quadraticCurveTo(1,-5,0,-2);
            ctx.quadraticCurveTo(-2,3,-5,5);
            ctx.moveTo(1,1);
            ctx.quadraticCurveTo(3,4,4,6);
            ctx.lineWidth = 2.0;
            ctx.lineCap = 'round';
            ctx.strokeStyle = "#ffcc33";
            ctx.stroke();

            // salt
            var spots = [
                -5,-6,
                1,-6,
                4,-4,
                -5,0,
                -2,0,
                6,1,
                -4,6,
                5,5,
                ];

            ctx.fillStyle = "#fff";
            var i,len;
            for (i=0, len=spots.length; i<len; i+=2) {
                var x = spots[i];
                var y = spots[i+1];
                ctx.beginPath();
                ctx.arc(x,y,0.65,0,2*Math.PI);
                ctx.fill();
            }

            ctx.restore();
            };

            var drawPear = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // body
            ctx.beginPath();
            ctx.moveTo(0,-4);
            ctx.bezierCurveTo(-1,-4,-2,-3,-2,-1);
            ctx.bezierCurveTo(-2,1,-4,2,-4,4);
            ctx.bezierCurveTo(-4,6,-2,7,0,7);
            ctx.bezierCurveTo(2,7,4,6,4,4);
            ctx.bezierCurveTo(4,2,2,1,2,-1);
            ctx.bezierCurveTo(2,-3,1,-4,0,-4);
            ctx.fillStyle = ctx.strokeStyle = "#00ff00";
            ctx.stroke();
            ctx.fill();

            // blue shine
            ctx.beginPath();
            ctx.moveTo(-2,3);
            ctx.quadraticCurveTo(-2,5,-1,5);
            ctx.strokeStyle = "#0033ff";
            ctx.lineCap = 'round';
            ctx.stroke();

            // white stem
            ctx.beginPath();
            ctx.moveTo(0,-4);
            ctx.quadraticCurveTo(0,-6,2,-6);
            ctx.strokeStyle = "#fff";
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.restore();
            };

            var drawBanana = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // body
            ctx.beginPath();
            ctx.moveTo(-5,5);
            ctx.quadraticCurveTo(-4,5,-2,6);
            ctx.bezierCurveTo(2,6,6,2,6,-4);
            ctx.lineTo(3,-3);
            ctx.lineTo(3,-2);
            ctx.lineTo(-4,5);
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle = "#ffff00";
            ctx.stroke();
            ctx.fill();

            // stem
            ctx.beginPath();
            ctx.moveTo(4,-5);
            ctx.lineTo(5,-6);
            ctx.strokeStyle="#ffff00";
            ctx.lineCap='round';
            ctx.stroke();

            // black mark
            ctx.beginPath();
            ctx.moveTo(3,-1);
            ctx.lineTo(-2,4);
            ctx.strokeStyle = "#000";
            ctx.lineCap='round';
            ctx.stroke();

            // shine
            ctx.beginPath();
            ctx.moveTo(2,3);
            ctx.lineTo(0,5);
            ctx.strokeStyle = "#fff";
            ctx.lineCap='round';
            ctx.stroke();

            ctx.restore();
            };

            var drawCookie = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // body
            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2);
            ctx.fillStyle = "#f9bd6d";
            //ctx.fillStyle = "#dfab68";
            ctx.fill();

            // chocolate chips
            var spots = [
                0,-3,
                -4,-1,
                0,2,
                3,0,
                3,3,
                ];

            ctx.fillStyle = "#000";
            var i,len;
            for (i=0, len=spots.length; i<len; i+=2) {
                var x = spots[i];
                var y = spots[i+1];
                ctx.beginPath();
                ctx.arc(x,y,0.75,0,2*Math.PI);
                ctx.fill();
            }

            ctx.restore();
            };

            var drawCookieFlash = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);

            // body
            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#f9bd6d";
            ctx.fill();
            ctx.stroke();

            // chocolate chips
            var spots = [
                0,-3,
                -4,-1,
                0,2,
                3,0,
                3,3,
                ];

            ctx.fillStyle = "#f9bd6d";
            var i,len;
            for (i=0, len=spots.length; i<len; i+=2) {
                var x = spots[i];
                var y = spots[i+1];
                ctx.beginPath();
                ctx.arc(x,y,0.75,0,2*Math.PI);
                ctx.fill();
            }

            ctx.restore();
            };

            var getSpriteFuncFromFruitName = function(name) {
            var funcs = {
                'cherry': drawCherry,
                'strawberry': drawStrawberry,
                'orange': drawOrange,
                'apple': drawApple,
                'melon': drawMelon,
                'galaxian': drawGalaxian,
                'bell': drawBell,
                'key': drawKey,
                'pretzel': drawPretzel,
                'pear': drawPear,
                'banana': drawBanana,
                'cookie': drawCookie,
            };

            return funcs[name];
            };

            var drawRecordSymbol = function(ctx,x,y,color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.translate(x,y);

            ctx.beginPath();
            ctx.arc(0,0,4,0,Math.PI*2);
            ctx.fill();

            ctx.restore();
            };

            var drawRewindSymbol = function(ctx,x,y,color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.translate(x,y);

            var s = 3;
            var drawTriangle = function(x) {
                ctx.beginPath();
                ctx.moveTo(x,s);
                ctx.lineTo(x-2*s,0);
                ctx.lineTo(x,-s);
                ctx.closePath();
                ctx.fill();
            };
            drawTriangle(0);
            drawTriangle(2*s);

            ctx.restore();
            };

            var drawUpSymbol = function(ctx,x,y,color) {
            ctx.save();
            ctx.translate(x,y);
            var s = tileSize;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0,-s/2);
            ctx.lineTo(s/2,s/2);
            ctx.lineTo(-s/2,s/2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            };

            var drawDownSymbol = function(ctx,x,y,color) {
            ctx.save();
            ctx.translate(x,y);
            var s = tileSize;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0,s/2);
            ctx.lineTo(s/2,-s/2);
            ctx.lineTo(-s/2,-s/2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            };

            var drawSnail = (function(){
            var plotSolid = function(points,color) {
                var len = points.length;
                var i;
                ctx.beginPath();
                ctx.moveTo(points[0],points[1]);
                for (i=2; i<len; i+=2) {
                    ctx.lineTo(points[i],points[i+1]);
                }
                ctx.closePath();
                ctx.lineWidth = 1.0;
                ctx.lineJoin = "round";
                ctx.fillStyle = ctx.strokeStyle = color;
                ctx.fill();
                ctx.stroke();
            };
            return function(ctx,x,y,color) {
                ctx.save();
                ctx.translate(x,y);
                ctx.beginPath();
                ctx.moveTo(-7,3);
                ctx.lineTo(-5,3);
                ctx.bezierCurveTo(-6,0,-5,-3,-2,-3);
                ctx.bezierCurveTo(0,-3,2,-2,2,2);
                ctx.bezierCurveTo(3,-1,3,-2,5,-2);
                ctx.bezierCurveTo(6,-2,6,0,5,0);
                ctx.bezierCurveTo(4,1,4,3,2,3);
                ctx.closePath();

                ctx.lineWidth = 1.0;
                ctx.lineCap = ctx.lineJoin = "round";
                ctx.fillStyle = ctx.strokeStyle = color;
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(4,-2);
                ctx.lineTo(3,-5);
                ctx.moveTo(5,-1);
                ctx.lineTo(7,-5);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(3,-5, 1, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(7,-5, 1, 0, Math.PI*2);
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(-4,1);
                ctx.bezierCurveTo(-5,-1,-3,-3, -1,-2);
                ctx.bezierCurveTo(0,-1,0,0,-1,1);
                ctx.bezierCurveTo(-2,1,-3,0,-2,-0.5);
                ctx.lineWidth = 0.5;
                ctx.strokeStyle = "#000";
                ctx.stroke();

                ctx.restore();
            };
            })();

            var drawHeartSprite = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);
            ctx.fillStyle = "#ffb8ff";

            ctx.beginPath();
            ctx.moveTo(0,-3);
            ctx.bezierCurveTo(-1,-4,-2,-6,-3.5,-6);
            ctx.quadraticCurveTo(-7,-6,-7,-0.5);
            ctx.bezierCurveTo(-7,2,-2,5,0,7);
            ctx.bezierCurveTo(2,5,7,2,7,-0.5);
            ctx.quadraticCurveTo(7,-6,3.5,-6);
            ctx.bezierCurveTo(2,-6,1,-4,0,-3);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
            };

            var drawExclamationPoint = function(ctx,x,y) {
            ctx.save();
            ctx.translate(x,y);
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = ctx.fillStyle = "#ff0";
            ctx.beginPath();
            ctx.moveTo(-1,1);
            ctx.bezierCurveTo(-1,0,-1,-3,0,-3);
            ctx.lineTo(2,-3);
            ctx.bezierCurveTo(2,-2,0,0,-1,1);
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(-2,3,0.5,0,Math.PI*2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            };
            //@line 1 "src/Actor.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // The actor class defines common data functions for the ghosts and pacman
            // It provides everything for updating position and direction.

            // "Ghost" and "Player" inherit from this "Actor"

            // Actor constructor
            var Actor = function() {

            this.dir = {};          // facing direction vector
            this.pixel = {};        // pixel position
            this.tile = {};         // tile position
            this.tilePixel = {};    // pixel location inside tile
            this.distToMid = {};    // pixel distance to mid-tile

            this.targetTile = {};   // tile position used for targeting

            this.frames = 0;        // frame count
            this.steps = 0;         // step count

            this.isDrawTarget = false;
            this.isDrawPath = false;

            this.savedSteps = {};
            this.savedFrames = {};
            this.savedDirEnum = {};
            this.savedPixel = {};
            this.savedTargetting = {};
            this.savedTargetTile = {};
            };

            // save state at time t
            Actor.prototype.save = function(t) {
            this.savedSteps[t] = this.steps;
            this.savedFrames[t] = this.frames;
            this.savedDirEnum[t] = this.dirEnum;
            this.savedPixel[t] = { x:this.pixel.x, y:this.pixel.y };
            this.savedTargetting[t] = this.targetting;
            this.savedTargetTile[t] = { x: this.targetTile.x, y: this.targetTile.y };
            };

            // load state at time t
            Actor.prototype.load = function(t) {
            this.steps = this.savedSteps[t];
            this.frames = this.savedFrames[t];
            this.setDir(this.savedDirEnum[t]);
            this.setPos(this.savedPixel[t].x, this.savedPixel[t].y);
            this.targetting = this.savedTargetting[t];
            this.targetTile.x = this.savedTargetTile[t].x;
            this.targetTile.y = this.savedTargetTile[t].y;
            };


            // reset to initial position and direction
            Actor.prototype.reset = function() {
            this.setDir(this.startDirEnum);
            this.setPos(this.startPixel.x, this.startPixel.y);
            this.frames = 0;
            this.steps = 0;
            this.targetting = false;
            };

            // sets the position and updates its dependent variables
            Actor.prototype.setPos = function(px,py) {
            this.pixel.x = px;
            this.pixel.y = py;
            this.commitPos();
            };

            // returns the relative pixel inside a tile given a map pixel
            Actor.prototype.getTilePixel = function(pixel,tilePixel) {
            if (pixel == undefined) {
                pixel = this.pixel;
            }
            if (tilePixel == undefined) {
                tilePixel = {};
            }
            tilePixel.x = pixel.x % tileSize;
            tilePixel.y = pixel.y % tileSize;
            if (tilePixel.x < 0) {
                tilePixel.x += tileSize;
            }
            if (tilePixel.y < 0) {
                tilePixel.y += tileSize;
            }
            return tilePixel;
            };

            // updates the position's dependent variables
            Actor.prototype.commitPos = function() {

            // use map-specific tunnel teleport
            if (map) {
                map.teleport(this);
            }

            this.tile.x = Math.floor(this.pixel.x / tileSize);
            this.tile.y = Math.floor(this.pixel.y / tileSize);
            this.getTilePixel(this.pixel,this.tilePixel);
            this.distToMid.x = midTile.x - this.tilePixel.x;
            this.distToMid.y = midTile.y - this.tilePixel.y;
            };

            // sets the direction and updates its dependent variables
            Actor.prototype.setDir = function(dirEnum) {
            setDirFromEnum(this.dir, dirEnum);
            this.dirEnum = dirEnum;
            };

            // used as "pattern" parameter in getStepSizeFromTable()
            var STEP_PACMAN = 0;
            var STEP_GHOST = 1;
            var STEP_PACMAN_FRIGHT = 2;
            var STEP_GHOST_FRIGHT = 3;
            var STEP_GHOST_TUNNEL = 4;
            var STEP_ELROY1 = 5;
            var STEP_ELROY2 = 6;

            // getter function to extract a step size from speed control table
            Actor.prototype.getStepSizeFromTable = (function(){

            // Actor speed is controlled by a list of 16 values.
            // Each value is the number of steps to take in a specific frame.
            // Once the end of the list is reached, we cycle to the beginning.
            // This method allows us to represent different speeds in a low-resolution space.

            // speed control table (from Jamey Pittman)
            var stepSizes = (
                                // LEVEL 1
            "1111111111111111" + // pac-man (normal)
            "0111111111111111" + // ghosts (normal)
            "1111211111112111" + // pac-man (fright)
            "0110110101101101" + // ghosts (fright)
            "0101010101010101" + // ghosts (tunnel)
            "1111111111111111" + // elroy 1
            "1111111121111111" + // elroy 2

                                // LEVELS 2-4
            "1111211111112111" + // pac-man (normal)
            "1111111121111111" + // ghosts (normal)
            "1111211112111121" + // pac-man (fright)
            "0110110110110111" + // ghosts (fright)
            "0110101011010101" + // ghosts (tunnel)
            "1111211111112111" + // elroy 1
            "1111211112111121" + // elroy 2

                                // LEVELS 5-20
            "1121112111211121" + // pac-man (normal)
            "1111211112111121" + // ghosts (normal)
            "1121112111211121" + // pac-man (fright) (N/A for levels 17, 19 & 20)
            "0111011101110111" + // ghosts (fright)  (N/A for levels 17, 19 & 20)
            "0110110101101101" + // ghosts (tunnel)
            "1121112111211121" + // elroy 1
            "1121121121121121" + // elroy 2

                                // LEVELS 21+
            "1111211111112111" + // pac-man (normal)
            "1111211112111121" + // ghosts (normal)
            "0000000000000000" + // pac-man (fright) N/A
            "0000000000000000" + // ghosts (fright)  N/A
            "0110110101101101" + // ghosts (tunnel)
            "1121112111211121" + // elroy 1
            "1121121121121121"); // elroy 2

            return function(level, pattern) {
                var entry;
                if (level < 1) return;
                else if (level==1)                  entry = 0;
                else if (level >= 2 && level <= 4)  entry = 1;
                else if (level >= 5 && level <= 20) entry = 2;
                else if (level >= 21)               entry = 3;
                return stepSizes[entry*7*16 + pattern*16 + this.frames%16];
            };
            })();

            // updates the actor state
            Actor.prototype.update = function(j) {

            // get number of steps to advance in this frame
            var numSteps = this.getNumSteps();
            if (j >= numSteps) 
                return;

            // request to advance one step, and increment count if step taken
            this.steps += this.step();

            // update head direction
            this.steer();
            };
            //@line 1 "src/Ghost.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Ghost class

            // modes representing the ghost's current state
            var GHOST_OUTSIDE = 0;
            var GHOST_EATEN = 1;
            var GHOST_GOING_HOME = 2;
            var GHOST_ENTERING_HOME = 3;
            var GHOST_PACING_HOME = 4;
            var GHOST_LEAVING_HOME = 5;

            // Ghost constructor
            var Ghost = function() {
            // inherit data from Actor
            Actor.apply(this);

            this.randomScatter = false;
            this.faceDirEnum = this.dirEnum;
            };

            // inherit functions from Actor class
            Ghost.prototype = newChildObject(Actor.prototype);

            // displacements for ghost bouncing
            Ghost.prototype.getBounceY = (function(){

            // NOTE: The bounce animation assumes an actor is moving in straight
            // horizontal or vertical lines between the centers of each tile.
            //
            // When moving horizontal, bounce height is a function of x.
            // When moving vertical, bounce height is a function of y.

            var bounceY = {};

            // map y tile pixel to new y tile pixel
            bounceY[DIR_UP] =    [-4,-2,0,2,4,3,2,3];
            bounceY[DIR_DOWN] =  [3,5,7,5,4,5,7,8];

            // map x tile pixel to y tile pixel
            bounceY[DIR_LEFT] =  [2,3,3,4,3,2,2,2];
            bounceY[DIR_RIGHT] = [2,2,3,4,3,3,2,2];

            return function(px,py,dirEnum) {
                if (px == undefined) {
                    px = this.pixel.x;
                }
                if (py == undefined) {
                    py = this.pixel.y;
                }
                if (dirEnum == undefined) {
                    dirEnum = this.dirEnum;
                }

                if (this.mode != GHOST_OUTSIDE || !this.scared || gameMode != GAME_COOKIE) {
                    return py;
                }

                var tilePixel = this.getTilePixel({x:px,y:py});
                var tileY = Math.floor(py / tileSize);
                var y = tileY*tileSize;

                if (dirEnum == DIR_UP || dirEnum == DIR_DOWN) {
                    y += bounceY[dirEnum][tilePixel.y];
                }
                else {
                    y += bounceY[dirEnum][tilePixel.x];
                }

                return y;
            };
            })();

            Ghost.prototype.getAnimFrame = function(frames) {
            if (frames == undefined) {
                frames = this.frames;
            }
            return Math.floor(frames/8)%2; // toggle frame every 8 ticks
            };

            // reset the state of the ghost on new level or level restart
            Ghost.prototype.reset = function() {

            // signals
            this.sigReverse = false;
            this.sigLeaveHome = false;

            // modes
            this.mode = this.startMode;
            this.scared = false;
            audio.ghostReset();

            this.savedSigReverse = {};
            this.savedSigLeaveHome = {};
            this.savedMode = {};
            this.savedScared = {};
            this.savedElroy = {};
            this.savedFaceDirEnum = {};

            // call Actor's reset function to reset position and direction
            Actor.prototype.reset.apply(this);

            // faceDirEnum  = direction the ghost is facing
            // dirEnum      = direction the ghost is moving
            // (faceDirEnum represents what dirEnum will be once the ghost reaches the middle of the tile)
            this.faceDirEnum = this.dirEnum;
            };

            Ghost.prototype.save = function(t) {
            this.savedSigReverse[t] = this.sigReverse;
            this.savedSigLeaveHome[t] = this.sigLeaveHome;
            this.savedMode[t] = this.mode;
            this.savedScared[t] = this.scared;
            if (this == blinky) {
                this.savedElroy[t] = this.elroy;
            }
            this.savedFaceDirEnum[t] = this.faceDirEnum;
            Actor.prototype.save.call(this,t);
            };

            Ghost.prototype.load = function(t) {
            this.sigReverse = this.savedSigReverse[t];
            this.sigLeaveHome = this.savedSigLeaveHome[t];
            this.mode = this.savedMode[t];
            this.scared = this.savedScared[t];
            if (this == blinky) {
                this.elroy = this.savedElroy[t];
            }
            this.faceDirEnum = this.savedFaceDirEnum[t];
            Actor.prototype.load.call(this,t);
            };

            // indicates if we slow down in the tunnel
            Ghost.prototype.isSlowInTunnel = function() {
            // special case for Ms. Pac-Man (slow down only for the first three levels)
            if (gameMode == GAME_MSPACMAN || gameMode == GAME_OTTO || gameMode == GAME_COOKIE)
                return level <= 3;
            else
                return true;
            };

            // gets the number of steps to move in this frame
            Ghost.prototype.getNumSteps = function() {

            var pattern = STEP_GHOST;

            if (this.mode == GHOST_GOING_HOME || this.mode == GHOST_ENTERING_HOME)
                return 2;
            else if (this.mode == GHOST_LEAVING_HOME || this.mode == GHOST_PACING_HOME)
                return this.getStepSizeFromTable(1, STEP_GHOST_TUNNEL);
            else if (map.isTunnelTile(this.tile.x, this.tile.y) && this.isSlowInTunnel())
                pattern = STEP_GHOST_TUNNEL;
            else if (this.scared)
                pattern = STEP_GHOST_FRIGHT;
            else if (this.elroy == 1)
                pattern = STEP_ELROY1;
            else if (this.elroy == 2)
                pattern = STEP_ELROY2;

            return this.getStepSizeFromTable(level ? level : 1, pattern);
            };

            // signal ghost to reverse direction after leaving current tile
            Ghost.prototype.reverse = function() {
            this.sigReverse = true;
            };

            // signal ghost to go home
            // It is useful to have this because as soon as the ghost gets eaten,
            // we have to freeze all the actors for 3 seconds, except for the
            // ones who are already traveling to the ghost home to be revived.
            // We use this signal to change mode to GHOST_GOING_HOME, which will be
            // set after the update() function is called so that we are still frozen
            // for 3 seconds before traveling home uninterrupted.
            Ghost.prototype.goHome = function() {
            audio.silence();
            audio.eatingGhost.play();
            this.mode = GHOST_EATEN;
            };

            // Following the pattern that state changes be made via signaling (e.g. reversing, going home)
            // the ghost is commanded to leave home similarly.
            // (not sure if this is correct yet)
            Ghost.prototype.leaveHome = function() {
            this.playSounds();
            this.sigLeaveHome = true;
            };

            Ghost.prototype.playSounds = function() {
            var ghostsOutside = 0;
            var ghostsGoingHome = 0;
            for (var i=0; i<4; i++) {
                if (ghosts[i].mode == GHOST_OUTSIDE)    ghostsOutside++;
                if (ghosts[i].mode == GHOST_GOING_HOME) ghostsGoingHome++;
            }
            if (ghostsGoingHome > 0) {
                audio.ghostNormalMove.stopLoop();
                audio.ghostReturnToHome.startLoop(true);
                return;
            }
            else {
                audio.ghostReturnToHome.stopLoop();
            }
            if (ghostsOutside > 0 ) {
                if (! this.scared)
                    audio.ghostNormalMove.startLoop(true);
            }
            else {
                audio.ghostNormalMove.stopLoop();
            }
            }

            // function called when pacman eats an energizer
            Ghost.prototype.onEnergized = function() {

            this.reverse();

            // only scare me if not already going home
            if (this.mode != GHOST_GOING_HOME && this.mode != GHOST_ENTERING_HOME) {
                this.scared = true;
                this.targetting = undefined;
            }
            };

            // function called when this ghost gets eaten
            Ghost.prototype.onEaten = function() {
            this.goHome();       // go home
            this.scared = false; // turn off scared
            };

            // move forward one step
            Ghost.prototype.step = function() {
            this.setPos(this.pixel.x+this.dir.x, this.pixel.y+this.dir.y);
            return 1;
            };

            // ghost home-specific path steering
            Ghost.prototype.homeSteer = (function(){

            // steering functions to execute for each mode
            var steerFuncs = {};

            steerFuncs[GHOST_GOING_HOME] = function() {
                // at the doormat
                if (this.tile.x == map.doorTile.x && this.tile.y == map.doorTile.y) {
                    this.faceDirEnum = DIR_DOWN;
                    this.targetting = false;
                    // walk to the door, or go through if already there
                    if (this.pixel.x == map.doorPixel.x) {
                        this.mode = GHOST_ENTERING_HOME;
                        this.playSounds();
                        this.setDir(DIR_DOWN);
                        this.faceDirEnum = this.dirEnum;
                    }
                    else {
                        this.setDir(DIR_RIGHT);
                        this.faceDirEnum = this.dirEnum;
                    }
                }
            };

            steerFuncs[GHOST_ENTERING_HOME] = function() {
                if (this.pixel.y == map.homeBottomPixel) {
                    // revive if reached its seat
                    if (this.pixel.x == this.startPixel.x) {
                        this.setDir(DIR_UP);
                        this.mode = this.arriveHomeMode;
                    }
                    // sidestep to its seat
                    else {
                        this.setDir(this.startPixel.x < this.pixel.x ? DIR_LEFT : DIR_RIGHT);
                    }
                    this.faceDirEnum = this.dirEnum;
                }
            };

            steerFuncs[GHOST_PACING_HOME] = function() {
                // head for the door
                if (this.sigLeaveHome) {
                    this.sigLeaveHome = false;
                    this.mode = GHOST_LEAVING_HOME;
                    if (this.pixel.x == map.doorPixel.x)
                        this.setDir(DIR_UP);
                    else
                        this.setDir(this.pixel.x < map.doorPixel.x ? DIR_RIGHT : DIR_LEFT);
                }
                // pace back and forth
                else {
                    if (this.pixel.y == map.homeTopPixel)
                        this.setDir(DIR_DOWN);
                    else if (this.pixel.y == map.homeBottomPixel)
                        this.setDir(DIR_UP);
                }
                this.faceDirEnum = this.dirEnum;
            };

            steerFuncs[GHOST_LEAVING_HOME] = function() {
                if (this.pixel.x == map.doorPixel.x) {
                    // reached door
                    if (this.pixel.y == map.doorPixel.y) {
                        this.mode = GHOST_OUTSIDE;
                        this.setDir(DIR_LEFT); // always turn left at door?
                    }
                    // keep walking up to the door
                    else {
                        this.setDir(DIR_UP);
                    }
                    this.faceDirEnum = this.dirEnum;
                }
            };

            // return a function to execute appropriate steering function for a given ghost
            return function() { 
                var f = steerFuncs[this.mode];
                if (f)
                    f.apply(this);
            };

            })();

            // special case for Ms. Pac-Man game that randomly chooses a corner for blinky and pinky when scattering
            Ghost.prototype.isScatterBrain = function() {
            var scatter = false;
            if (ghostCommander.getCommand() == GHOST_CMD_SCATTER) {
                if (gameMode == GAME_MSPACMAN || gameMode == GAME_COOKIE) {
                    scatter = (this == blinky || this == pinky);
                }
                else if (gameMode == GAME_OTTO) {
                    scatter = true;
                }
            }
            return scatter;
            };

            // determine direction
            Ghost.prototype.steer = function() {

            var dirEnum;                         // final direction to update to
            var openTiles;                       // list of four booleans indicating which surrounding tiles are open
            var oppDirEnum = rotateAboutFace(this.dirEnum); // current opposite direction enum
            var actor;                           // actor whose corner we will target

            // special map-specific steering when going to, entering, pacing inside, or leaving home
            this.homeSteer();

            // current opposite direction enum
            oppDirEnum = rotateAboutFace(this.dirEnum); 

            // only execute rest of the steering logic if we're pursuing a target tile
            if (this.mode != GHOST_OUTSIDE && this.mode != GHOST_GOING_HOME) {
                this.targetting = false;
                return;
            }

            // AT MID-TILE (update movement direction)
            if (this.distToMid.x == 0 && this.distToMid.y == 0) {

                // trigger reversal
                if (this.sigReverse) {
                    this.faceDirEnum = oppDirEnum;
                    this.sigReverse = false;
                }

                // commit previous direction
                this.setDir(this.faceDirEnum);
            }
            // JUST PASSED MID-TILE (update face direction)
            else if (
                    this.dirEnum == DIR_RIGHT && this.tilePixel.x == midTile.x+1 ||
                    this.dirEnum == DIR_LEFT  && this.tilePixel.x == midTile.x-1 ||
                    this.dirEnum == DIR_UP    && this.tilePixel.y == midTile.y-1 ||
                    this.dirEnum == DIR_DOWN  && this.tilePixel.y == midTile.y+1) {

                // get next tile
                var nextTile = {
                    x: this.tile.x + this.dir.x,
                    y: this.tile.y + this.dir.y,
                };

                // get tiles surrounding next tile and their open indication
                openTiles = getOpenTiles(nextTile, this.dirEnum);

                if (this.scared) {
                    // choose a random turn
                    dirEnum = Math.floor(Math.random()*4);
                    while (!openTiles[dirEnum])
                        dirEnum = (dirEnum+1)%4; // look at likelihood of random turns
                    this.targetting = false;
                }
                else {

                    /* SET TARGET */

                    // target ghost door
                    if (this.mode == GHOST_GOING_HOME) {
                        this.targetTile.x = map.doorTile.x;
                        this.targetTile.y = map.doorTile.y;
                    }
                    // target corner when scattering
                    else if (!this.elroy && ghostCommander.getCommand() == GHOST_CMD_SCATTER) {

                        actor = this.isScatterBrain() ? actors[Math.floor(Math.random()*4)] : this;

                        this.targetTile.x = actor.cornerTile.x;
                        this.targetTile.y = actor.cornerTile.y;
                        this.targetting = 'corner';
                    }
                    // use custom function for each ghost when in attack mode
                    else {
                        this.setTarget();
                    }

                    /* CHOOSE TURN */

                    var dirDecided = false;
                    if (this.mode == GHOST_GOING_HOME && map.getExitDir) {
                        // If the map has a 'getExitDir' function, then we are using
                        // a custom algorithm to choose the next direction.
                        // Currently, procedurally-generated maps use this function
                        // to ensure that ghosts can return home without looping forever.
                        var exitDir = map.getExitDir(nextTile.x,nextTile.y);
                        if (exitDir != undefined && exitDir != oppDirEnum) {
                            dirDecided = true;
                            dirEnum = exitDir;
                        }
                    }

                    if (!dirDecided) {
                        // Do not constrain turns for ghosts going home. (thanks bitwave)
                        if (this.mode != GHOST_GOING_HOME) {
                            if (map.constrainGhostTurns) {
                                // edit openTiles to reflect the current map's special contraints
                                map.constrainGhostTurns(nextTile, openTiles, this.dirEnum);
                            }
                        }

                        // choose direction that minimizes distance to target
                        dirEnum = getTurnClosestToTarget(nextTile, this.targetTile, openTiles);
                    }
                }

                // Point eyeballs to the determined direction.
                this.faceDirEnum = dirEnum;
            }
            };

            Ghost.prototype.getPathDistLeft = function(fromPixel, dirEnum) {
            var distLeft = tileSize;
            var pixel = this.getTargetPixel();
            if (this.targetting == 'pacman') {
                if (dirEnum == DIR_UP || dirEnum == DIR_DOWN)
                    distLeft = Math.abs(fromPixel.y - pixel.y);
                else {
                    distLeft = Math.abs(fromPixel.x - pixel.x);
                }
            }
            return distLeft;
            };

            Ghost.prototype.setTarget = function() {
            // This sets the target tile when in chase mode.
            // The "target" is always Pac-Man when in this mode,
            // except for Clyde.  He runs away back home sometimes,
            // so the "targetting" parameter is set in getTargetTile
            // for Clyde only.

            this.targetTile = this.getTargetTile();

            if (this != clyde) {
                this.targetting = 'pacman';
            }
            };
            //@line 1 "src/Player.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Player is the controllable character (Pac-Man)

            // Player constructor
            var Player = function() {

            // inherit data from Actor
            Actor.apply(this);
            if (gameMode == GAME_MSPACMAN || gameMode == GAME_COOKIE) {
                this.frames = 1; // start with mouth open
            }

            this.nextDir = {};
            this.lastMeal = { x:-1, y:-1 };

            // determines if this player should be AI controlled
            this.ai = false;
            this.invincible = false;

            this.savedNextDirEnum = {};
            this.savedStopped = {};
            this.savedEatPauseFramesLeft = {};
            };

            // inherit functions from Actor
            Player.prototype = newChildObject(Actor.prototype);

            Player.prototype.save = function(t) {
            this.savedEatPauseFramesLeft[t] = this.eatPauseFramesLeft;
            this.savedNextDirEnum[t] = this.nextDirEnum;
            this.savedStopped[t] = this.stopped;

            Actor.prototype.save.call(this,t);
            };

            Player.prototype.load = function(t) {
            this.eatPauseFramesLeft = this.savedEatPauseFramesLeft[t];
            this.setNextDir(this.savedNextDirEnum[t]);
            this.stopped = this.savedStopped[t];

            Actor.prototype.load.call(this,t);
            };

            // reset the state of the player on new level or level restart
            Player.prototype.reset = function() {

            this.setNextDir(this.startDirEnum);
            this.stopped = false;
            this.inputDirEnum = undefined;

            this.eatPauseFramesLeft = 0;   // current # of frames left to pause after eating

            // call Actor's reset function to reset to initial position and direction
            Actor.prototype.reset.apply(this);

            };

            // sets the next direction and updates its dependent variables
            Player.prototype.setNextDir = function(nextDirEnum) {
            setDirFromEnum(this.nextDir, nextDirEnum);
            this.nextDirEnum = nextDirEnum;
            };

            // gets the number of steps to move in this frame
            Player.prototype.getNumSteps = function() {
            if (turboMode)
                return 2;

            var pattern = energizer.isActive() ? STEP_PACMAN_FRIGHT : STEP_PACMAN;
            return this.getStepSizeFromTable(level, pattern);
            };

            Player.prototype.getStepFrame = function(steps) {
            if (steps == undefined) {
                steps = this.steps;
            }
            return Math.floor(steps/2)%4;
            };

            Player.prototype.getAnimFrame = function(frame) {
            if (frame == undefined) {
                frame = this.getStepFrame();
            }
            if (gameMode == GAME_MSPACMAN || gameMode == GAME_COOKIE) { // ms. pacman starts with mouth open
                frame = (frame+1)%4;
                if (state == deadState)
                    frame = 1; // hack to force this frame when dead
            }
            if (gameMode != GAME_OTTO) {
                if (frame == 3) 
                    frame = 1;
            }
            return frame;
            };

            Player.prototype.setInputDir = function(dirEnum) {
            this.inputDirEnum = dirEnum;
            };

            Player.prototype.clearInputDir = function(dirEnum) {
            if (dirEnum == undefined || this.inputDirEnum == dirEnum) {
                this.inputDirEnum = undefined;
            }
            };

            // move forward one step
            Player.prototype.step = (function(){

            // return sign of a number
            var sign = function(x) {
                if (x<0) return -1;
                if (x>0) return 1;
                return 0;
            };

            return function() {

                // just increment if we're not in a map
                if (!map) {
                    this.setPos(this.pixel.x+this.dir.x, this.pixel.y+this.dir.y);
                    return 1;
                }

                // identify the axes of motion
                var a = (this.dir.x != 0) ? 'x' : 'y'; // axis of motion
                var b = (this.dir.x != 0) ? 'y' : 'x'; // axis perpendicular to motion

                // Don't proceed past the middle of a tile if facing a wall
                this.stopped = this.stopped || (this.distToMid[a] == 0 && !isNextTileFloor(this.tile, this.dir));
                if (!this.stopped) {
                    // Move in the direction of travel.
                    this.pixel[a] += this.dir[a];

                    // Drift toward the center of the track (a.k.a. cornering)
                    this.pixel[b] += sign(this.distToMid[b]);
                }


                this.commitPos();
                return this.stopped ? 0 : 1;
            };
            })();

            // determine direction
            Player.prototype.steer = function() {

            // if AI-controlled, only turn at mid-tile
            if (this.ai) {
                if (this.distToMid.x != 0 || this.distToMid.y != 0)
                    return;

                // make turn that is closest to target
                var openTiles = getOpenTiles(this.tile, this.dirEnum);
                this.setTarget();
                this.setNextDir(getTurnClosestToTarget(this.tile, this.targetTile, openTiles));
            }
            else {
                this.targetting = undefined;
            }

            if (this.inputDirEnum == undefined) {
                if (this.stopped) {
                    this.setDir(this.nextDirEnum);
                }
            }
            else {
                // Determine if input direction is open.
                var inputDir = {};
                setDirFromEnum(inputDir, this.inputDirEnum);
                var inputDirOpen = isNextTileFloor(this.tile, inputDir);

                if (inputDirOpen) {
                    this.setDir(this.inputDirEnum);
                    this.setNextDir(this.inputDirEnum);
                    this.stopped = false;
                }
                else {
                    if (!this.stopped) {
                        this.setNextDir(this.inputDirEnum);
                    }
                }
            }
            if (this.stopped) {
                audio.eating.stopLoop(true);
            }
            };


            // update this frame
            Player.prototype.update = function(j) {

            var numSteps = this.getNumSteps();
            if (j >= numSteps)
                return;

            // skip frames
            if (this.eatPauseFramesLeft > 0) {
                if (j == numSteps-1)
                    this.eatPauseFramesLeft--;
                return;
            }

            // call super function to update position and direction
            Actor.prototype.update.call(this,j);

            // eat something
            if (map) {
                var t = map.getTile(this.tile.x, this.tile.y);
                if (t == '.' || t == 'o') {
                    this.lastMeal.x = this.tile.x;
                    this.lastMeal.y = this.tile.y
                    // apply eating drag (unless in turbo mode)
                    if (!turboMode) {
                        this.eatPauseFramesLeft = (t=='.') ? 1 : 3;
                    }
                    audio.eating.startLoop(true);
                    map.onDotEat(this.tile.x, this.tile.y);
                    ghostReleaser.onDotEat();
                    fruit.onDotEat();
                    addScore((t=='.') ? 10 : 50);

                    if (t=='o')
                        energizer.activate();
                }
                if (t == ' ' && ! (this.lastMeal.x == this.tile.x && this.lastMeal.y == this.tile.y)) {
                    audio.eating.stopLoop(true);
                }
            }
            };
            //@line 1 "src/actors.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // create all the actors

            var blinky = new Ghost();
            blinky.name = "blinky";
            blinky.color = "#FF0000";
            blinky.pathColor = "rgba(255,0,0,0.8)";
            blinky.isVisible = true;

            var pinky = new Ghost();
            pinky.name = "pinky";
            pinky.color = "#FFB8FF";
            pinky.pathColor = "rgba(255,184,255,0.8)";
            pinky.isVisible = true;

            var inky = new Ghost();
            inky.name = "inky";
            inky.color = "#00FFFF";
            inky.pathColor = "rgba(0,255,255,0.8)";
            inky.isVisible = true;

            var clyde = new Ghost();
            clyde.name = "clyde";
            clyde.color = "#FFB851";
            clyde.pathColor = "rgba(255,184,81,0.8)";
            clyde.isVisible = true;

            var pacman = new Player();
            pacman.name = "pacman";
            pacman.color = "#FFFF00";
            pacman.pathColor = "rgba(255,255,0,0.8)";

            // order at which they appear in original arcade memory
            // (suggests drawing/update order)
            var actors = [blinky, pinky, inky, clyde, pacman];
            var ghosts = [blinky, pinky, inky, clyde];
            //@line 1 "src/targets.js"
            /////////////////////////////////////////////////////////////////
            // Targetting
            // (a definition for each actor's targetting algorithm and a draw function to visualize it)
            // (getPathDistLeft is used to obtain a smoothly interpolated path endpoint)

            // the tile length of the path drawn toward the target
            var actorPathLength = 16;

            (function() {

            // the size of the square rendered over a target tile (just half a tile)
            var targetSize = midTile.y;

            // when drawing paths, use these offsets so they don't completely overlap each other
            pacman.pathCenter = { x:0, y:0};
            blinky.pathCenter = { x:-2, y:-2 };
            pinky.pathCenter = { x:-1, y:-1 };
            inky.pathCenter = { x:1, y:1 };
            clyde.pathCenter = { x:2, y:2 };

            /////////////////////////////////////////////////////////////////
            // blinky directly targets pacman

            blinky.getTargetTile = function() {
            return { x: pacman.tile.x, y: pacman.tile.y };
            };
            blinky.getTargetPixel = function() {
            return { x: pacman.pixel.x, y: pacman.pixel.y };
            };
            blinky.drawTarget = function(ctx) {
            if (!this.targetting) return;
            ctx.fillStyle = this.color;
            if (this.targetting == 'pacman')
                renderer.drawCenterPixelSq(ctx, pacman.pixel.x, pacman.pixel.y, targetSize);
            else
                renderer.drawCenterTileSq(ctx, this.targetTile.x, this.targetTile.y, targetSize);
            };

            /////////////////////////////////////////////////////////////////
            // pinky targets four tiles ahead of pacman
            pinky.getTargetTile = function() {
            var px = pacman.tile.x + 4*pacman.dir.x;
            var py = pacman.tile.y + 4*pacman.dir.y;
            if (pacman.dirEnum == DIR_UP) {
                px -= 4;
            }
            return { x : px, y : py };
            };
            pinky.getTargetPixel = function() {
            var px = pacman.pixel.x + 4*pacman.dir.x*tileSize;
            var py = pacman.pixel.y + 4*pacman.dir.y*tileSize;
            if (pacman.dirEnum == DIR_UP) {
                px -= 4*tileSize;
            }
            return { x : px, y : py };
            };
            pinky.drawTarget = function(ctx) {
            if (!this.targetting) return;
            ctx.fillStyle = this.color;

            var pixel = this.getTargetPixel();

            if (this.targetting == 'pacman') {
                ctx.beginPath();
                ctx.moveTo(pacman.pixel.x, pacman.pixel.y);
                if (pacman.dirEnum == DIR_UP) {
                    ctx.lineTo(pacman.pixel.x, pixel.y);
                }
                ctx.lineTo(pixel.x, pixel.y);
                ctx.stroke();
                renderer.drawCenterPixelSq(ctx, pixel.x, pixel.y, targetSize);
            }
            else
                renderer.drawCenterTileSq(ctx, this.targetTile.x, this.targetTile.y, targetSize);
            };

            /////////////////////////////////////////////////////////////////
            // inky targets twice the distance from blinky to two tiles ahead of pacman
            inky.getTargetTile = function() {
            var px = pacman.tile.x + 2*pacman.dir.x;
            var py = pacman.tile.y + 2*pacman.dir.y;
            if (pacman.dirEnum == DIR_UP) {
                px -= 2;
            }
            return {
                x : blinky.tile.x + 2*(px - blinky.tile.x),
                y : blinky.tile.y + 2*(py - blinky.tile.y),
            };
            };
            inky.getJointPixel = function() {
            var px = pacman.pixel.x + 2*pacman.dir.x*tileSize;
            var py = pacman.pixel.y + 2*pacman.dir.y*tileSize;
            if (pacman.dirEnum == DIR_UP) {
                px -= 2*tileSize;
            }
            return { x: px, y: py };
            };
            inky.getTargetPixel = function() {
            var px = pacman.pixel.x + 2*pacman.dir.x*tileSize;
            var py = pacman.pixel.y + 2*pacman.dir.y*tileSize;
            if (pacman.dirEnum == DIR_UP) {
                px -= 2*tileSize;
            }
            return {
                x : blinky.pixel.x + 2*(px-blinky.pixel.x),
                y : blinky.pixel.y + 2*(py-blinky.pixel.y),
            };
            };
            inky.drawTarget = function(ctx) {
            if (!this.targetting) return;
            var pixel;

            var joint = this.getJointPixel();

            if (this.targetting == 'pacman') {
                pixel = this.getTargetPixel();
                ctx.beginPath();
                ctx.moveTo(pacman.pixel.x, pacman.pixel.y);
                if (pacman.dirEnum == DIR_UP) {
                    ctx.lineTo(pacman.pixel.x, joint.y);
                }
                ctx.lineTo(joint.x, joint.y);
                ctx.moveTo(blinky.pixel.x, blinky.pixel.y);
                ctx.lineTo(pixel.x, pixel.y);
                ctx.closePath();
                ctx.stroke();

                // draw seesaw joint
                ctx.beginPath();
                ctx.arc(joint.x, joint.y, 2,0,Math.PI*2);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fill();

                ctx.fillStyle = this.color;
                renderer.drawCenterPixelSq(ctx, pixel.x, pixel.y, targetSize);
            }
            else {
                ctx.fillStyle = this.color;
                renderer.drawCenterTileSq(ctx, this.targetTile.x, this.targetTile.y, targetSize);
            }
            };

            /////////////////////////////////////////////////////////////////
            // clyde targets pacman if >=8 tiles away, otherwise targets home

            clyde.getTargetTile = function() {
            var dx = pacman.tile.x - (this.tile.x + this.dir.x);
            var dy = pacman.tile.y - (this.tile.y + this.dir.y);
            var dist = dx*dx+dy*dy;
            if (dist >= 64) {
                this.targetting = 'pacman';
                return { x: pacman.tile.x, y: pacman.tile.y };
            }
            else {
                this.targetting = 'corner';
                return { x: this.cornerTile.x, y: this.cornerTile.y };
            }
            };
            clyde.getTargetPixel = function() {
            // NOTE: won't ever need this function for corner tile because it is always outside
            return { x: pacman.pixel.x, y: pacman.pixel.y };
            };
            clyde.drawTarget = function(ctx) {
            if (!this.targetting) return;
            ctx.fillStyle = this.color;

            if (this.targetting == 'pacman') {
                ctx.beginPath();
                if (true) {
                    // draw a radius
                    ctx.arc(pacman.pixel.x, pacman.pixel.y, tileSize*8,0, 2*Math.PI);
                    ctx.closePath();
                }
                else {
                    // draw a distance stick
                    ctx.moveTo(pacman.pixel.x, pacman.pixel.y);
                    var dx = clyde.pixel.x - pacman.pixel.x;
                    var dy = clyde.pixel.y - pacman.pixel.y;
                    var dist = Math.sqrt(dx*dx+dy*dy);
                    dx = dx/dist*tileSize*8;
                    dy = dy/dist*tileSize*8;
                    ctx.lineTo(pacman.pixel.x + dx, pacman.pixel.y + dy);
                }
                ctx.stroke();
                renderer.drawCenterPixelSq(ctx, pacman.pixel.x, pacman.pixel.y, targetSize);
            }
            else {
                // draw a radius
                if (ghostCommander.getCommand() == GHOST_CMD_CHASE) {
                    ctx.beginPath();
                    ctx.arc(pacman.pixel.x, pacman.pixel.y, tileSize*8,0, 2*Math.PI);
                    ctx.strokeStyle = "rgba(255,255,255,0.25)";
                    ctx.stroke();
                }
                renderer.drawCenterTileSq(ctx, this.targetTile.x, this.targetTile.y, targetSize);
            }
            };


            /////////////////////////////////////////////////////////////////
            // pacman targets twice the distance from pinky to pacman or target pinky

            pacman.setTarget = function() {
            if (blinky.mode == GHOST_GOING_HOME || blinky.scared) {
                this.targetTile.x = pinky.tile.x;
                this.targetTile.y = pinky.tile.y;
                this.targetting = 'pinky';
            }
            else {
                this.targetTile.x = pinky.tile.x + 2*(pacman.tile.x-pinky.tile.x);
                this.targetTile.y = pinky.tile.y + 2*(pacman.tile.y-pinky.tile.y);
                this.targetting = 'flee';
            }
            };
            pacman.drawTarget = function(ctx) {
            if (!this.ai) return;
            ctx.fillStyle = this.color;
            var px,py;

            if (this.targetting == 'flee') {
                px = pacman.pixel.x - pinky.pixel.x;
                py = pacman.pixel.y - pinky.pixel.y;
                px = pinky.pixel.x + 2*px;
                py = pinky.pixel.y + 2*py;
                ctx.beginPath();
                ctx.moveTo(pinky.pixel.x, pinky.pixel.y);
                ctx.lineTo(px,py);
                ctx.closePath();
                ctx.stroke();
                renderer.drawCenterPixelSq(ctx, px, py, targetSize);
            }
            else {
                renderer.drawCenterPixelSq(ctx, pinky.pixel.x, pinky.pixel.y, targetSize);
            };

            };
            pacman.getPathDistLeft = function(fromPixel, dirEnum) {
            var distLeft = tileSize;
            var px,py;
            if (this.targetting == 'pinky') {
                if (dirEnum == DIR_UP || dirEnum == DIR_DOWN)
                    distLeft = Math.abs(fromPixel.y - pinky.pixel.y);
                else
                    distLeft = Math.abs(fromPixel.x - pinky.pixel.x);
            }
            else { // 'flee'
                px = pacman.pixel.x - pinky.pixel.x;
                py = pacman.pixel.y - pinky.pixel.y;
                px = pinky.pixel.x + 2*px;
                py = pinky.pixel.y + 2*py;
                if (dirEnum == DIR_UP || dirEnum == DIR_DOWN)
                    distLeft = Math.abs(py - fromPixel.y);
                else
                    distLeft = Math.abs(px - fromPixel.x);
            }
            return distLeft;
            };

            })();
            //@line 1 "src/ghostCommander.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Ghost Commander
            // Determines when a ghost should be chasing a target

            // modes representing the ghosts' current command
            var GHOST_CMD_CHASE = 0;
            var GHOST_CMD_SCATTER = 1;

            var ghostCommander = (function() {

            // determine if there is to be a new command issued at the given time
            var getNewCommand = (function(){
                var t;
                var times = [{},{},{}];
                // level 1
                times[0][t=7*60] = GHOST_CMD_CHASE;
                times[0][t+=20*60] = GHOST_CMD_SCATTER;
                times[0][t+=7*60] = GHOST_CMD_CHASE;
                times[0][t+=20*60] = GHOST_CMD_SCATTER;
                times[0][t+=5*60] = GHOST_CMD_CHASE;
                times[0][t+=20*60] = GHOST_CMD_SCATTER;
                times[0][t+=5*60] = GHOST_CMD_CHASE;
                // level 2-4
                times[1][t=7*60] = GHOST_CMD_CHASE;
                times[1][t+=20*60] = GHOST_CMD_SCATTER;
                times[1][t+=7*60] = GHOST_CMD_CHASE;
                times[1][t+=20*60] = GHOST_CMD_SCATTER;
                times[1][t+=5*60] = GHOST_CMD_CHASE;
                times[1][t+=1033*60] = GHOST_CMD_SCATTER;
                times[1][t+=1] = GHOST_CMD_CHASE;
                // level 5+
                times[2][t=5*60] = GHOST_CMD_CHASE;
                times[2][t+=20*60] = GHOST_CMD_SCATTER;
                times[2][t+=5*60] = GHOST_CMD_CHASE;
                times[2][t+=20*60] = GHOST_CMD_SCATTER;
                times[2][t+=5*60] = GHOST_CMD_CHASE;
                times[2][t+=1037*60] = GHOST_CMD_SCATTER;
                times[2][t+=1] = GHOST_CMD_CHASE;

                return function(frame) {
                    var i;
                    if (level == 1)
                        i = 0;
                    else if (level >= 2 && level <= 4)
                        i = 1;
                    else
                        i = 2;
                    var newCmd = times[i][frame];

                    if (gameMode == GAME_PACMAN) {
                        return newCmd;
                    }
                    else if (frame <= 27*60) { // only revearse twice in Ms. Pac-Man (two happen in first 27 seconds)
                        if (newCmd != undefined) {
                            return GHOST_CMD_CHASE; // always chase in Ms. Pac-Man mode
                        }
                    }
                };
            })();

            var frame;   // current frame
            var command; // last command given to ghosts

            var savedFrame = {};
            var savedCommand = {};

            // save state at time t
            var save = function(t) {
                savedFrame[t] = frame;
                savedCommand[t] = command;
            };

            // load state at time t
            var load = function(t) {
                frame = savedFrame[t];
                command = savedCommand[t];
            };

            return {
                save: save,
                load: load,
                reset: function() { 
                    command = GHOST_CMD_SCATTER;
                    frame = 0;
                },
                update: function() {
                    var newCmd;
                    if (!energizer.isActive()) {
                        newCmd = getNewCommand(frame);
                        if (newCmd != undefined) {
                            command = newCmd;
                            for (i=0; i<4; i++)
                                ghosts[i].reverse();
                        }
                        frame++;
                    }
                },
                getCommand: function() {
                    return command; 
                },
                setCommand: function(cmd) {
                    command = cmd;
                },
            };
            })();
            //@line 1 "src/ghostReleaser.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Ghost Releaser

            // Determines when to release ghosts from home

            var ghostReleaser = (function(){
            // two separate counter modes for releasing the ghosts from home
            var MODE_PERSONAL = 0;
            var MODE_GLOBAL = 1;

            // ghost enumerations
            var PINKY = 1;
            var INKY = 2;
            var CLYDE = 3;

            // this is how many frames it will take to release a ghost after pacman stops eating
            var getTimeoutLimit = function() { return (level < 5) ? 4*60 : 3*60; };

            // dot limits used in personal mode to release ghost after # of dots have been eaten
            var personalDotLimit = {};
            personalDotLimit[PINKY] = function() { return 0; };
            personalDotLimit[INKY] = function() { return (level==1) ? 30 : 0; };
            personalDotLimit[CLYDE] = function() {
                if (level == 1) return 60;
                if (level == 2) return 50;
                return 0;
            };

            // dot limits used in global mode to release ghost after # of dots have been eaten
            var globalDotLimit = {};
            globalDotLimit[PINKY] = 7;
            globalDotLimit[INKY] = 17;
            globalDotLimit[CLYDE] = 32;

            var framesSinceLastDot; // frames elapsed since last dot was eaten
            var mode;               // personal or global dot counter mode
            var ghostCounts = {};   // personal dot counts for each ghost
            var globalCount;        // global dot count

            var savedGlobalCount = {};
            var savedFramesSinceLastDot = {};
            var savedGhostCounts = {};

            // save state at time t
            var save = function(t) {
                savedFramesSinceLastDot[t] = framesSinceLastDot;
                if (mode == MODE_GLOBAL) {
                    savedGlobalCount[t] = globalCount;
                }
                else if (mode == MODE_PERSONAL) {
                    savedGhostCounts[t] = {};
                    savedGhostCounts[t][PINKY] = ghostCounts[PINKY];
                    savedGhostCounts[t][INKY] = ghostCounts[INKY];
                    savedGhostCounts[t][CLYDE] = ghostCounts[CLYDE];
                }
            };

            // load state at time t
            var load = function(t) {
                framesSinceLastDot = savedFramesSinceLastDot[t];
                if (mode == MODE_GLOBAL) {
                    globalCount = savedGlobalCount[t];
                }
                else if (mode == MODE_PERSONAL) {
                    ghostCounts[PINKY] = savedGhostCounts[t][PINKY];
                    ghostCounts[INKY] = savedGhostCounts[t][INKY];
                    ghostCounts[CLYDE] = savedGhostCounts[t][CLYDE];
                }
            };

            return {
                save: save,
                load: load,
                onNewLevel: function() {
                    mode = MODE_PERSONAL;
                    framesSinceLastDot = 0;
                    ghostCounts[PINKY] = 0;
                    ghostCounts[INKY] = 0;
                    ghostCounts[CLYDE] = 0;
                },
                onRestartLevel: function() {
                    mode = MODE_GLOBAL;
                    framesSinceLastDot = 0;
                    globalCount = 0;
                },
                onDotEat: function() {
                    var i;

                    framesSinceLastDot = 0;

                    if (mode == MODE_GLOBAL) {
                        globalCount++;
                    }
                    else {
                        for (i=1;i<4;i++) {
                            if (ghosts[i].mode == GHOST_PACING_HOME) {
                                ghostCounts[i]++;
                                break;
                            }
                        }
                    }

                },
                update: function() {
                    var g;

                    // use personal dot counter
                    if (mode == MODE_PERSONAL) {
                        for (i=1;i<4;i++) {
                            g = ghosts[i];
                            if (g.mode == GHOST_PACING_HOME) {
                                if (ghostCounts[i] >= personalDotLimit[i]()) {
                                    g.leaveHome();
                                    return;
                                }
                                break;
                            }
                        }
                    }
                    // use global dot counter
                    else if (mode == MODE_GLOBAL) {
                        if (globalCount == globalDotLimit[PINKY] && pinky.mode == GHOST_PACING_HOME) {
                            pinky.leaveHome();
                            return;
                        }
                        else if (globalCount == globalDotLimit[INKY] && inky.mode == GHOST_PACING_HOME) {
                            inky.leaveHome();
                            return;
                        }
                        else if (globalCount == globalDotLimit[CLYDE] && clyde.mode == GHOST_PACING_HOME) {
                            globalCount = 0;
                            mode = MODE_PERSONAL;
                            clyde.leaveHome();
                            return;
                        }
                    }

                    // also use time since last dot was eaten
                    if (framesSinceLastDot > getTimeoutLimit()) {
                        framesSinceLastDot = 0;
                        for (i=1;i<4;i++) {
                            g = ghosts[i];
                            if (g.mode == GHOST_PACING_HOME) {
                                g.leaveHome();
                                break;
                            }
                        }
                    }
                    else
                        framesSinceLastDot++;
                },
            };
            })();
            //@line 1 "src/elroyTimer.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Elroy Timer

            // Determines when to put blinky into faster elroy modes

            var elroyTimer = (function(){

            // get the number of dots left that should trigger elroy stage #1 or #2
            var getDotsEatenLimit = (function(){
                var dotsLeft = [
                    [20,30,40,40,40,50,50,50,60,60,60,70,70,70,100,100,100,100,120,120,120], // elroy1
                    [10,15,20,20,20,25,25,25,30,30,30,40,40,40, 50, 50, 50, 50, 60, 60, 60]]; // elroy2
                return function(stage) {
                    var i = level;
                    if (i>21) i = 21;
                    var pacman_max_pellets = 244;
                    return pacman_max_pellets - dotsLeft[stage-1][i-1];
                };
            })();

            // when level restarts, blinky must wait for clyde to leave home before resuming elroy mode
            var waitForClyde;

            var savedWaitForClyde = {};

            // save state at time t
            var save = function(t) {
                savedWaitForClyde[t] = waitForClyde;
            };

            // load state at time t
            var load = function(t) {
                waitForClyde = savedWaitForClyde[t];
            };

            return {
                onNewLevel: function() {
                    waitForClyde = false;
                },
                onRestartLevel: function() {
                    waitForClyde = true;
                },
                update: function() {

                    // stop waiting for clyde when clyde leaves home
                    if (waitForClyde && clyde.mode != GHOST_PACING_HOME)
                        waitForClyde = false;

                    if (waitForClyde) {
                        blinky.elroy = 0;
                    }
                    else {
                        if (map.dotsEaten >= getDotsEatenLimit(2)) {
                            blinky.elroy = 2;
                        }
                        else if (map.dotsEaten >= getDotsEatenLimit(1)) {
                            blinky.elroy = 1;
                        }
                        else {
                            blinky.elroy = 0;
                        }
                    }
                },
                save: save,
                load: load,
            };
            })();
            //@line 1 "src/energizer.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Energizer

            // This handles how long the energizer lasts as well as how long the
            // points will display after eating a ghost.

            var energizer = (function() {

            // how many seconds to display points when ghost is eaten
            var pointsDuration = 1;

            // how long to stay energized based on current level
            var getDuration = (function(){
                var seconds = [6,5,4,3,2,5,2,2,1,5,2,1,1,3,1,1,0,1];
                return function() {
                    var i = level;
                    return (i > 18) ? 0 : 60*seconds[i-1];
                };
            })();

            // how many ghost flashes happen near the end of frightened mode based on current level
            var getFlashes = (function(){
                var flashes = [5,5,5,5,5,5,5,5,3,5,5,3,3,5,3,3,0,3];
                return function() {
                    var i = level;
                    return (i > 18) ? 0 : flashes[i-1];
                };
            })();

            // "The ghosts change colors every 14 game cycles when they start 'flashing'" -Jamey Pittman
            var flashInterval = 14;

            var count;  // how long in frames energizer has been active
            var active; // indicates if energizer is currently active
            var points; // points that the last eaten ghost was worth
            var pointsFramesLeft; // number of frames left to display points earned from eating ghost

            var savedCount = {};
            var savedActive = {};
            var savedPoints = {};
            var savedPointsFramesLeft = {};

            // save state at time t
            var save = function(t) {
                savedCount[t] = count;
                savedActive[t] = active;
                savedPoints[t] = points;
                savedPointsFramesLeft[t] = pointsFramesLeft;
            };

            // load state at time t
            var load = function(t) {
                count = savedCount[t];
                active = savedActive[t];
                points = savedPoints[t];
                pointsFramesLeft = savedPointsFramesLeft[t];
            };

            return {
                save: save,
                load: load,
                reset: function() {
                    audio.ghostTurnToBlue.stopLoop();
                    count = 0;
                    active = false;
                    points = 100;
                    pointsFramesLeft = 0;
                    for (i=0; i<4; i++)
                        ghosts[i].scared = false;
                },
                update: function() {
                    var i;
                    if (active) {
                        if (count == getDuration())
                            this.reset();
                        else
                            count++;
                    }
                },
                activate: function() { 
                    audio.ghostNormalMove.stopLoop();
                    audio.ghostTurnToBlue.startLoop();
                    active = true;
                    count = 0;
                    points = 100;
                    for (i=0; i<4; i++) {
                        ghosts[i].onEnergized();
                    }
                    if (getDuration() == 0) { // if no duration, then immediately reset
                        this.reset();
                    }
                },
                isActive: function() { return active; },
                isFlash: function() { 
                    var i = Math.floor((getDuration()-count)/flashInterval);
                    return (i<=2*getFlashes()-1) ? (i%2==0) : false;
                },

                getPoints: function() {
                    return points;
                },
                addPoints: function() {
                    addScore(points*=2);
                    pointsFramesLeft = pointsDuration*60;
                },
                showingPoints: function() { return pointsFramesLeft > 0; },
                updatePointsTimer: function() { if (pointsFramesLeft > 0) pointsFramesLeft--; },
            };
            })();
            //@line 1 "src/fruit.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Fruit

            var BaseFruit = function() {
            // pixel
            this.pixel = {x:0, y:0};

            this.fruitHistory = {};

            this.scoreDuration = 2; // number of seconds that the fruit score is on the screen
            this.scoreFramesLeft; // frames left until the picked-up fruit score is off the screen
            this.savedScoreFramesLeft = {};
            };

            BaseFruit.prototype = {
            isScorePresent: function() {
                return this.scoreFramesLeft > 0;
            },
            onNewLevel: function() {
                this.buildFruitHistory();
            },
            setCurrentFruit: function(i) {
                this.currentFruitIndex = i;
            },
            onDotEat: function() {
                if (!this.isPresent() && (map.dotsEaten == this.dotLimit1 || map.dotsEaten == this.dotLimit2)) {
                    this.initiate();
                }
            },
            save: function(t) {
                this.savedScoreFramesLeft[t] = this.scoreFramesLeft;
            },
            load: function(t) {
                this.scoreFramesLeft = this.savedScoreFramesLeft[t];
            },
            reset: function() {
                this.scoreFramesLeft = 0;
            },
            getCurrentFruit: function() {
                return this.fruits[this.currentFruitIndex];
            },
            getPoints: function() {
                return this.getCurrentFruit().points;
            },
            update: function() {
                if (this.scoreFramesLeft > 0)
                    this.scoreFramesLeft--;
            },
            isCollide: function() {
                return Math.abs(pacman.pixel.y - this.pixel.y) <= midTile.y && Math.abs(pacman.pixel.x - this.pixel.x) <= midTile.x;
            },
            testCollide: function() {
                if (this.isPresent() && this.isCollide()) {
                    addScore(this.getPoints());
                    audio.silence(true);
                    audio.eatingFruit.play();
                    setTimeout(ghosts[0].playSounds, 500);
                    this.reset();
                    this.scoreFramesLeft = this.scoreDuration*60;
                }
            },
            };

            // PAC-MAN FRUIT

            var PacFruit = function() {
            BaseFruit.call(this);
            this.fruits = [
                {name:'cherry',     points:100},
                {name:'strawberry', points:300},
                {name:'orange',     points:500},
                {name:'apple',      points:700},
                {name:'melon',      points:1000},
                {name:'galaxian',   points:2000},
                {name:'bell',       points:3000},
                {name:'key',        points:5000},
            ];

            this.order = [
                0,  // level 1
                1,  // level 2 
                2,  // level 3
                2,  // level 4
                3,  // level 5
                3,  // level 6
                4,  // level 7
                4,  // level 8
                5,  // level 9
                5,  // level 10
                6,  // level 11
                6,  // level 12
                7]; // level 13+

            this.dotLimit1 = 70;
            this.dotLimit2 = 170;

            this.duration = 9; // number of seconds that the fruit is on the screen
            this.framesLeft; // frames left until fruit is off the screen

            this.savedFramesLeft = {};
            };

            PacFruit.prototype = newChildObject(BaseFruit.prototype, {

            onNewLevel: function() {
                this.setCurrentFruit(this.getFruitIndexFromLevel(level));
                BaseFruit.prototype.onNewLevel.call(this);
            },

            getFruitFromLevel: function(i) {
                return this.fruits[this.getFruitIndexFromLevel(i)];
            },

            getFruitIndexFromLevel: function(i) {
                if (i > 13) {
                    i = 13;
                }
                return this.order[i-1];
            },

            buildFruitHistory: function() {
                this.fruitHistory = {};
                var i;
                for (i=1; i<= level; i++) {
                    this.fruitHistory[i] = this.fruits[this.getFruitIndexFromLevel(i)];
                }
            },

            initiate: function() {
                var x = 13;
                var y = 20;
                this.pixel.x = tileSize*(1+x)-1;
                this.pixel.y = tileSize*y + midTile.y;
                this.framesLeft = 60*this.duration;
            },

            isPresent: function() {
                return this.framesLeft > 0;
            },

            reset: function() {
                BaseFruit.prototype.reset.call(this);

                this.framesLeft = 0;
            },

            update: function() {
                BaseFruit.prototype.update.call(this);

                if (this.framesLeft > 0)
                    this.framesLeft--;
            },

            save: function(t) {
                BaseFruit.prototype.save.call(this,t);
                this.savedFramesLeft[t] = this.framesLeft;
            },
            load: function(t) {
                BaseFruit.prototype.load.call(this,t);
                this.framesLeft = this.savedFramesLeft[t];
            },
            });

            // MS. PAC-MAN FRUIT

            var PATH_ENTER = 0;
            var PATH_PEN = 1;
            var PATH_EXIT = 2;

            var MsPacFruit = function() {
            BaseFruit.call(this);
            this.fruits = [
                {name: 'cherry',     points: 100},
                {name: 'strawberry', points: 200},
                {name: 'orange',     points: 500},
                {name: 'pretzel',    points: 700},
                {name: 'apple',      points: 1000},
                {name: 'pear',       points: 2000},
                {name: 'banana',     points: 5000},
            ];

            this.dotLimit1 = 64;
            this.dotLimit2 = 176;

            this.pen_path = "<<<<<<^^^^^^>>>>>>>>>vvvvvv<<";

            this.savedIsPresent = {};
            this.savedPixel = {};
            this.savedPathMode = {};
            this.savedFrame = {};
            this.savedNumFrames = {};
            this.savedPath = {};
            };

            MsPacFruit.prototype = newChildObject(BaseFruit.prototype, {

            shouldRandomizeFruit: function() {
                return level > 7;
            },

            getFruitFromLevel: function(i) {
                if (i <= 7) {
                    return this.fruits[i-1];
                }
                else {
                    return undefined;
                }
            },

            onNewLevel: function() {
                if (!this.shouldRandomizeFruit()) {
                    this.setCurrentFruit(level-1);
                }
                else {
                    this.setCurrentFruit(0);
                }
                BaseFruit.prototype.onNewLevel.call(this);
            },

            buildFruitHistory: function() {
                this.fruitHistory = {};
                var i;
                for (i=1; i<= Math.max(level,7); i++) {
                    this.fruitHistory[i] = this.fruits[i-1];
                }
            },

            reset: function() {
                BaseFruit.prototype.reset.call(this);

                this.frame = 0;
                this.numFrames = 0;
                this.path = undefined;
            },

            initiatePath: function(p) {
                this.frame = 0;
                this.numFrames = p.length*16;
                this.path = p;
            },

            initiate: function() {
                if (this.shouldRandomizeFruit()) {
                    this.setCurrentFruit(getRandomInt(0,6));
                }
                var entrances = map.fruitPaths.entrances;
                var e = entrances[getRandomInt(0,entrances.length-1)];
                this.initiatePath(e.path);
                this.pathMode = PATH_ENTER;
                this.pixel.x = e.start.x;
                this.pixel.y = e.start.y;
            },

            isPresent: function() {
                return this.frame < this.numFrames;
            },

            bounceFrames: (function(){
                var U = { dx:0, dy:-1 };
                var D = { dx:0, dy:1 };
                var L = { dx:-1, dy:0 };
                var R = { dx:1, dy:0 };
                var UL = { dx:-1, dy:-1 };
                var UR = { dx:1, dy:-1 };
                var DL = { dx:-1, dy:1 };
                var DR = { dx:1, dy:1 };
                var Z = { dx:0, dy:0 };

                // A 16-frame animation for moving 8 pixels either up, down, left, or right.
                return {
                    '^': [U, U, U, U, U, U, U, U, U, Z, U, Z, Z, D, Z, D],
                    '>': [Z, UR,Z, R, Z, UR,Z, R, Z, R, Z, R, Z, DR,DR,Z],
                    '<': [Z, Z, UL,Z, L, Z, UL,Z, L, Z, L, Z, L, Z, DL,DL],
                    'v': [Z, D, D, D, D, D, D, D, D, D, D, D, U, U, Z, U],
                };
            })(),

            move: function() {
                var p = this.path[Math.floor(this.frame/16)]; // get current path frame
                var b = this.bounceFrames[p][this.frame%16]; // get current bounce animation frame
                this.pixel.x += b.dx;
                this.pixel.y += b.dy;
                this.frame++;
            },

            setNextPath: function() {
                if (this.pathMode == PATH_ENTER) {
                    this.pathMode = PATH_PEN;
                    this.initiatePath(this.pen_path);
                }
                else if (this.pathMode == PATH_PEN) {
                    this.pathMode = PATH_EXIT;
                    var exits = map.fruitPaths.exits;
                    var e = exits[getRandomInt(0,exits.length-1)];
                    this.initiatePath(e.path);
                }
                else if (this.pathMode == PATH_EXIT) {
                    this.reset();
                }
            },

            update: function() {
                BaseFruit.prototype.update.call(this);

                if (this.isPresent()) {
                    this.move();
                    if (this.frame == this.numFrames) {
                        this.setNextPath();
                    }
                }
            },

            save: function(t) {
                BaseFruit.prototype.save.call(this,t);

                this.savedPixel[t] =        this.isPresent() ? {x:this.pixel.x, y:this.pixel.y} : undefined;
                this.savedPathMode[t] =     this.pathMode;
                this.savedFrame[t] =        this.frame;
                this.savedNumFrames[t] =    this.numFrames;
                this.savedPath[t] =         this.path;
            },

            load: function(t) {
                BaseFruit.prototype.load.call(this,t);

                if (this.savedPixel[t]) {
                    this.pixel.x =      this.savedPixel[t].x;
                    this.pixel.y =      this.savedPixel[t].y;
                }
                this.pathMode =     this.savedPathMode[t];
                this.frame =        this.savedFrame[t];
                this.numFrames =    this.savedNumFrames[t]; 
                this.path =         this.savedPath[t];
            },
            });

            var fruit;
            var setFruitFromGameMode = (function() {
            var pacfruit = new PacFruit();
            var mspacfruit = new MsPacFruit();
            fruit = pacfruit;
            return function() {
                if (gameMode == GAME_PACMAN) {
                    fruit = pacfruit;
                }
                else {
                    fruit = mspacfruit;
                }
            };
            })();
            //@line 1 "src/executive.js"
            var executive = (function(){

            var framePeriod = 1000/60; // length of each frame at 60Hz (updates per second)
            var gameTime; // virtual time of the last game update

            var paused = false; // flag for pausing the state updates, while still drawing
            var running = false; // flag for truly stopping everything

            /**********/
            // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
            // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

            // requestAnimationFrame polyfill by Erik Mller
            // fixes from Paul Irish and Tino Zijdel

            var exitTo = function(s) {
                switchState(s);
                menu.disable();
            };

            (function() {
                var lastTime = 0;
                var vendors = ['ms', 'moz', 'webkit', 'o'];
                for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                            || window[vendors[x]+'CancelRequestAnimationFrame'];
                }

                if (!window.requestAnimationFrame)
                    window.requestAnimationFrame = function(callback, element) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                        var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                        timeToCall);
                        lastTime = currTime + timeToCall;
                        return id;
                    };

                if (!window.cancelAnimationFrame)
                    window.cancelAnimationFrame = function(id) {
                        clearTimeout(id);
                    };
            }());
            /**********/

            var fps;
            var updateFps = (function(){
                // TODO: fix this to reflect the average rate of the last n frames, where 0 < n < 60
                var length = 60;
                var times = [];
                var startIndex = 0;
                var endIndex = -1;
                var filled = false;

                return function(now) {
                    if (filled) {
                        startIndex = (startIndex+1) % length;
                    }
                    endIndex = (endIndex+1) % length;
                    if (endIndex == length-1) {
                        filled = true;
                    }

                    times[endIndex] = now;

                    var seconds = (now - times[startIndex]) / 1000;
                    var frames = endIndex - startIndex;
                    if (frames < 0) {
                        frames += length;
                    }
                    fps = frames / seconds;
                };
            })();
                

            var reqFrame; // id of requestAnimationFrame object
            var tick = function(now) {
                if (gameTime == undefined) {
                    gameTime = now;
                }

                // Update fps counter.
                updateFps(now);

                // Control frame-skipping by only allowing gameTime to lag behind the current time by some amount.
                var maxFrameSkip = 3;
                gameTime = Math.max(gameTime, now-maxFrameSkip*framePeriod);

                // Prevent any updates from being called when paused.
                if (paused || inGameMenu.isOpen()) {
                    gameTime = now;
                }

                hud.update();

                // Update the game until the gameTime surpasses the current time.
                while (gameTime < now) {
                    state.update();
                    gameTime += framePeriod;
                }

                // Draw.
                renderer.beginFrame();
                state.draw();
                if (hud.isValidState()) {
                    renderer.renderFunc(hud.draw);
                }
                renderer.endFrame();

                // Schedule the next tick.
                reqFrame = requestAnimationFrame(tick);
            };

            return {

                getFramePeriod: function() {
                    return framePeriod;
                },
                setUpdatesPerSecond: function(ups) {
                    framePeriod = 1000/ups;
                    //gameTime = undefined;
                    vcr.onFramePeriodChange();
                },
                init: function() {
                    var that = this;
                    window.addEventListener('focus', function() {that.start();});
                    window.addEventListener('blur', function() {that.stop();});
                    this.start(); 

                    // START PACMAN GAME
                    practiceMode = false;
                    turboMode = false;
                    newGameState.setStartLevel(2);
                    exitTo(newGameState, 60);
                },

                start: function() {
                    if (!running) {
                        reqFrame = requestAnimationFrame(tick);
                        running = true;
                    }
                },
                stop: function() {
                    if (running) {
                        cancelAnimationFrame(reqFrame);
                        running = false;
                    }
                },
                togglePause: function() { paused = !paused; },
                isPaused: function() { return paused; },
                getFps: function() { return fps; },
            };
            })();
            //@line 1 "src/states.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // States
            // (main loops for each state of the game)
            // state is set to any of these states, each containing an init(), draw(), and update()

            // current game state
            var state;

            // switches to another game state
            var switchState = function(nextState,fadeDuration, continueUpdate1, continueUpdate2) {
            state = (fadeDuration) ? fadeNextState(state,nextState,fadeDuration,continueUpdate1, continueUpdate2) : nextState;
            audio.silence();
            state.init();
            if (executive.isPaused()) {
                executive.togglePause();
            }
            };

            //////////////////////////////////////////////////////////////////////////////////////
            // Fade state

            // Creates a state that will fade from a given state to another in the given amount of time.
            // if continueUpdate1 is true, then prevState.update will be called while fading out
            // if continueUpdate2 is true, then nextState.update will be called while fading in
            var fadeNextState = function (prevState, nextState, frameDuration, continueUpdate1, continueUpdate2) {
            var frames;
            var midFrame = Math.floor(frameDuration/2);
            var inFirstState = function() { return frames < midFrame; };
            var getStateTime = function() { return frames/frameDuration*2 + (inFirstState() ? 0 : -1); };
            var initialized = false;

            return {
                init: function() {
                    frames = 0;
                    initialized = true;
                },
                draw: function() {
                    if (!initialized) return;
                    var t = getStateTime();
                    if (frames < midFrame) {
                        if (prevState) {
                            prevState.draw();
                            renderer.setOverlayColor("rgba(0,0,0,"+t+")");
                        }
                    }
                    else if (frames > midFrame) {
                        nextState.draw();
                        renderer.setOverlayColor("rgba(0,0,0,"+(1-t)+")");
                    }
                },
                update: function() {

                    // update prevState
                    if (frames < midFrame) {
                        if (continueUpdate1) {
                            prevState.update();
                        }
                    }
                    // change to nextState
                    else if (frames == midFrame) {
                        nextState.init();
                    }
                    // update nextState
                    else if (frames < frameDuration) {
                        if (continueUpdate2) {
                            nextState.update();
                        }
                    }
                    // hand over state to nextState
                    else {
                        state = nextState;
                        initialized = false;
                    }

                    frames++;
                },
            }
            };

            //////////////////////////////////////////////////////////////////////////////////////
            // Home State
            // (the home title screen state)

            var homeState = (function(){


            var menu = new Menu("CHOOSE A GAME",2*tileSize,0*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            var getIconAnimFrame = function(frame) {
                frame = Math.floor(frame/3)+1;
                frame %= 4;
                if (frame == 3) {
                    frame = 1;
                }
                return frame;
            };
            var getOttoAnimFrame = function(frame) {
                frame = Math.floor(frame/3);
                frame %= 4;
                return frame;
            };
            menu.addTextIconButton(getGameName(GAME_PACMAN),
                function() {
                    gameMode = GAME_PACMAN;
                    exitTo(preNewGameState);
                },
                function(ctx,x,y,frame) {
                    atlas.drawPacmanSprite(ctx,x,y,DIR_RIGHT,getIconAnimFrame(frame));
                });
            menu.addTextIconButton(getGameName(GAME_MSPACMAN),
                function() {
                    gameMode = GAME_MSPACMAN;
                    exitTo(preNewGameState);
                },
                function(ctx,x,y,frame) {
                    atlas.drawMsPacmanSprite(ctx,x,y,DIR_RIGHT,getIconAnimFrame(frame));
                });
            menu.addTextIconButton(getGameName(GAME_COOKIE),
                function() {
                    gameMode = GAME_COOKIE;
                    exitTo(preNewGameState);
                },
                function(ctx,x,y,frame) {
                    drawCookiemanSprite(ctx,x,y,DIR_RIGHT,getIconAnimFrame(frame), true);
                });

            menu.addSpacer(0.5);
            menu.addTextIconButton("LEARN",
                function() {
                    exitTo(learnState);
                },
                function(ctx,x,y,frame) {
                    atlas.drawGhostSprite(ctx,x,y,Math.floor(frame/8)%2,DIR_RIGHT,false,false,false,blinky.color);
                });

            return {
                init: function() {
                    menu.enable();
                    audio.coffeeBreakMusic.startLoop();
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.beginMapClip();
                    renderer.renderFunc(menu.draw,menu);
                    renderer.endMapClip();
                },
                update: function() {
                    menu.update();
                },
                getMenu: function() {
                    return menu;
                },
            };

            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Learn State

            var learnState = (function(){

            var exitTo = function(s) {
                switchState(s);
                menu.disable();
                forEachCharBtn(function (btn) {
                    btn.disable();
                });
                setAllVisibility(true);
                clearCheats();
            };

            var menu = new Menu("LEARN", 2*tileSize,-tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            menu.addSpacer(7);
            menu.addTextButton("BACK",
                function() {
                    exitTo(homeState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];
            menu.noArrowKeys = true;

            var pad = tileSize;
            var w = 30;
            var h = 30;
            var x = mapWidth/2 - 2*(w) - 1.5*pad;
            var y = 4*tileSize;
            var redBtn = new Button(x,y,w,h,function(){
                setAllVisibility(false);
                blinky.isVisible = true;
                setVisibility(blinky,true);
            });
            redBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_DOWN,undefined,undefined,undefined,blinky.color);
            });
            x += w+pad;
            var pinkBtn = new Button(x,y,w,h,function(){
                setAllVisibility(false);
                setVisibility(pinky,true);
            });
            pinkBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_DOWN,undefined,undefined,undefined,pinky.color);
            });
            x += w+pad;
            var cyanBtn = new Button(x,y,w,h,function(){
                setAllVisibility(false);
                setVisibility(inky,true);
            });
            cyanBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_DOWN,undefined,undefined,undefined,inky.color);
            });
            x += w+pad;
            var orangeBtn = new Button(x,y,w,h,function(){
                setAllVisibility(false);
                setVisibility(clyde,true);
            });
            orangeBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_DOWN,undefined,undefined,undefined,clyde.color);
            });
            var forEachCharBtn = function(callback) {
                callback(redBtn);
                callback(pinkBtn);
                callback(cyanBtn);
                callback(orangeBtn);
            };

            var setVisibility = function(g,visible) {
                g.isVisible = g.isDrawTarget = g.isDrawPath = visible;
            };

            var setAllVisibility = function(visible) {
                setVisibility(blinky,visible);
                setVisibility(pinky,visible);
                setVisibility(inky,visible);
                setVisibility(clyde,visible);
            };

            return {
                init: function() {

                    menu.enable();
                    forEachCharBtn(function (btn) {
                        btn.enable();
                    });

                    // set map
                    map = mapLearn;
                    renderer.drawMap();

                    // set game parameters
                    level = 1;
                    practiceMode = false;
                    turboMode = false;
                    gameMode = GAME_PACMAN;

                    // reset relevant game state
                    ghostCommander.reset();
                    energizer.reset();
                    ghostCommander.setCommand(GHOST_CMD_CHASE);
                    ghostReleaser.onNewLevel();
                    elroyTimer.onNewLevel();

                    // set ghost states
                    for (i=0; i<4; i++) {
                        var a = actors[i];
                        a.reset();
                        a.mode = GHOST_OUTSIDE;
                    }
                    blinky.setPos(14*tileSize-1, 13*tileSize+midTile.y);
                    pinky.setPos(15*tileSize+midTile.x, 13*tileSize+midTile.y);
                    inky.setPos(9*tileSize+midTile.x, 16*tileSize+midTile.y);
                    clyde.setPos(18*tileSize+midTile.x, 16*tileSize+midTile.y);

                    // set pacman state
                    pacman.reset();
                    pacman.setPos(14*tileSize-1,22*tileSize+midTile.y);

                    // start with red ghost
                    redBtn.onclick();

                },
                draw: function() {
                    renderer.blitMap();
                    renderer.renderFunc(menu.draw,menu);
                    forEachCharBtn(function (btn) {
                        renderer.renderFunc(btn.draw,btn);
                    });
                    renderer.beginMapClip();
                    renderer.drawPaths();
                    renderer.drawActors();
                    renderer.drawTargets();
                    renderer.endMapClip();
                },
                update: function() {
                    menu.update();
                    forEachCharBtn(function (btn) {
                        btn.update();
                    });
                    var i,j;
                    for (j=0; j<2; j++) {
                        pacman.update(j);
                        for (i=0;i<4;i++) {
                            actors[i].update(j);
                        }
                    }
                    for (i=0; i<5; i++)
                        actors[i].frames++;
                },
                getMenu: function() {
                    return menu;
                },
            };

            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Game Title
            // (provides functions for managing the game title with clickable player and enemies below it)

            var gameTitleState = (function() {

            var name,nameColor;

            var resetTitle = function() {
                if (yellowBtn.isSelected) {
                    name = getGameName();
                    nameColor = gameMode == GAME_COOKIE ? "#47b8ff" : pacman.color;
                }
                else if (redBtn.isSelected) {
                    name = getGhostNames()[0];
                    nameColor = blinky.color;
                }
                else if (pinkBtn.isSelected) {
                    name = getGhostNames()[1];
                    nameColor = pinky.color;
                }
                else if (cyanBtn.isSelected) {
                    name = getGhostNames()[2];
                    nameColor = inky.color;
                }
                else if (orangeBtn.isSelected) {
                    name = getGhostNames()[3];
                    nameColor = clyde.color;
                }
                else {
                    name = getGameName();
                    nameColor = "#FFF";
                }
            };

            var w = 20;
            var h = 30;
            var x = mapWidth/2 - 3*w;
            var y = 3*tileSize;
            var yellowBtn = new Button(x,y,w,h,function() {
                if (gameMode == GAME_MSPACMAN) {
                    gameMode = GAME_OTTO;
                }
                else if (gameMode == GAME_OTTO) {
                    gameMode = GAME_MSPACMAN;
                }
            });
            yellowBtn.setIcon(function (ctx,x,y,frame) {
                getPlayerDrawFunc()(ctx,x,y,DIR_RIGHT,pacman.getAnimFrame(pacman.getStepFrame(Math.floor((gameMode==GAME_PACMAN?frame+4:frame)/1.5))),true);
            });

            x += 2*w;
            var redBtn = new Button(x,y,w,h);
            redBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_LEFT,undefined,undefined,undefined,blinky.color);
            });

            x += w;
            var pinkBtn = new Button(x,y,w,h);
            pinkBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_LEFT,undefined,undefined,undefined,pinky.color);
            });

            x += w;
            var cyanBtn = new Button(x,y,w,h)
            cyanBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_LEFT,undefined,undefined,undefined,inky.color);
            });

            x += w;
            var orangeBtn = new Button(x,y,w,h);
            orangeBtn.setIcon(function (ctx,x,y,frame) {
                getGhostDrawFunc()(ctx,x,y,Math.floor(frame/6)%2,DIR_LEFT,undefined,undefined,undefined,clyde.color);
            });

            var forEachCharBtn = function(callback) {
                callback(yellowBtn);
                callback(redBtn);
                callback(pinkBtn);
                callback(cyanBtn);
                callback(orangeBtn);
            };
            forEachCharBtn(function(btn) {
                btn.borderBlurColor = btn.borderFocusColor = "#000";
            });

            return {
                init: function() {
                    resetTitle();
                    forEachCharBtn(function (btn) {
                        btn.enable();
                    });
                },
                shutdown: function() {
                    forEachCharBtn(function (btn) {
                        btn.disable();
                    });
                },
                draw: function() {
                    forEachCharBtn(function (btn) {
                        renderer.renderFunc(btn.draw,btn);
                    });

                    resetTitle();
                    renderer.renderFunc(function(ctx){
                        ctx.font = tileSize+"px ArcadeR";
                        ctx.fillStyle = nameColor;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "top";
                        ctx.fillText(name, mapWidth/2, tileSize);
                    });
                },
                update: function() {
                    forEachCharBtn(function (btn) {
                        btn.update();
                    });
                },
                getYellowBtn: function() {
                    return yellowBtn;
                },
            };

            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Pre New Game State
            // (the main menu for the currently selected game)

            var preNewGameState = (function() {

            var exitTo = function(s,fade) {
                gameTitleState.shutdown();
                menu.disable();
                switchState(s,fade);
            };

            var menu = new Menu("",2*tileSize,0,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");

            menu.addSpacer(2);
            menu.addTextButton("PLAY",
                function() { 
                    practiceMode = false;
                    turboMode = false;
                    newGameState.setStartLevel(1);
                    exitTo(newGameState, 60);
                });
            menu.addTextButton("PLAY TURBO",
                function() { 
                    practiceMode = false;
                    turboMode = true;
                    newGameState.setStartLevel(1);
                    exitTo(newGameState, 60);
                });
            menu.addTextButton("PRACTICE",
                function() { 
                    practiceMode = true;
                    turboMode = false;
                    exitTo(selectActState);
                });
            menu.addSpacer(0.5);
            menu.addTextButton("CUTSCENES",
                function() { 
                    exitTo(cutSceneMenuState);
                });
            menu.addTextButton("ABOUT",
                function() { 
                    exitTo(aboutGameState);
                });
            menu.addSpacer(0.5);
            menu.addTextButton("BACK",
                function() {
                    exitTo(homeState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];

            return {
                init: function() {
                    audio.startMusic.play();
/*                     menu.enable();
                    gameTitleState.init();
                    map = undefined;  */

                    practiceMode = false;
                    turboMode = false;
                    newGameState.setStartLevel(1);
                    exitTo(newGameState, 60);
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(menu.draw,menu);
                    gameTitleState.draw();
                },
                update: function() {
                    gameTitleState.update();
                },
                getMenu: function() {
                    return menu;
                },
            };
            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Select Act State

            var selectActState = (function() {

            // TODO: create ingame menu option to return to this menu (with last act played present)

            var menu;
            var numActs = 4;
            var defaultStartAct = 1;
            var startAct = defaultStartAct;

            var exitTo = function(state,fade) {
                gameTitleState.shutdown();
                menu.disable();
                switchState(state,fade);
            };


            var chooseLevelFromAct = function(act) {
                selectLevelState.setAct(act);
                exitTo(selectLevelState);
            };

            var scrollToAct = function(act) {
                // just rebuild the menu
                selectActState.setStartAct(act);
                exitTo(selectActState);
            };

            var drawArrow = function(ctx,x,y,dir) {
                ctx.save();
                ctx.translate(x,y);
                ctx.scale(1,dir);
                ctx.beginPath();
                ctx.moveTo(0,-tileSize/2);
                ctx.lineTo(tileSize,tileSize/2);
                ctx.lineTo(-tileSize,tileSize/2);
                ctx.closePath();
                ctx.fillStyle = "#FFF";
                ctx.fill();
                ctx.restore();
            };

            var buildMenu = function(act) {
                // set buttons starting at the given act
                startAct = act;

                menu = new Menu("",2*tileSize,0,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
                var i;
                var range;
                menu.addSpacer(2);
                menu.addIconButton(
                    function(ctx,x,y) {
                        drawArrow(ctx,x,y,1);
                    },
                    function() {
                        scrollToAct(Math.max(1,act-numActs));
                    });
                for (i=0; i<numActs; i++) {
                    range = getActRange(act+i);
                    menu.addTextIconButton("LEVELS "+range[0]+"-"+range[1],
                        (function(j){
                            return function() { 
                                chooseLevelFromAct(act+j);
                            };
                        })(i),
                        (function(j){
                            return function(ctx,x,y) {
                                var s = tileSize/3*2;
                                var r = tileSize/6;
                                ctx.save();
                                ctx.translate(x,y);
                                ctx.beginPath();
                                ctx.moveTo(-s,0);
                                ctx.lineTo(-s,-r);
                                ctx.quadraticCurveTo(-s,-s,-r,-s);
                                ctx.lineTo(r,-s);
                                ctx.quadraticCurveTo(s,-s,s,-r);
                                ctx.lineTo(s,r);
                                ctx.quadraticCurveTo(s,s,r,s);
                                ctx.lineTo(-r,s);
                                ctx.quadraticCurveTo(-s,s,-s,r);
                                ctx.closePath();
                                var colors = getActColor(act+j);
                                ctx.fillStyle = colors.wallFillColor;
                                ctx.strokeStyle = colors.wallStrokeColor;
                                ctx.fill();
                                ctx.stroke();
                                ctx.restore();
                            };
                        })(i));
                }
                menu.addIconButton(
                    function(ctx,x,y) {
                        drawArrow(ctx,x,y,-1);
                    },
                    function() {
                        scrollToAct(act+numActs);
                    });
                menu.addTextButton("BACK",
                    function() {
                        exitTo(preNewGameState);
                    });
                menu.backButton = menu.buttons[menu.buttonCount-1];
                menu.enable();
            };

            return {
                init: function() {
                    buildMenu(startAct);
                    gameTitleState.init();
                },
                setStartAct: function(act) {
                    startAct = act;
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(menu.draw,menu);
                    gameTitleState.draw();
                },
                update: function() {
                    gameTitleState.update();
                },
                getMenu: function() {
                    return menu;
                },
            };
            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Select Level State

            var selectLevelState = (function() {

            var menu;
            var act = 1;

            var exitTo = function(state,fade) {
                gameTitleState.shutdown();
                menu.disable();
                switchState(state,fade);
            };

            var playLevel = function(i) {
                // TODO: set level (will have to set up fruit history correctly)
                newGameState.setStartLevel(i);
                exitTo(newGameState, 60);
            };

            var buildMenu = function(act) {
                var range = getActRange(act);

                menu = new Menu("",2*tileSize,0,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
                var i;
                menu.addSpacer(2);
                if (range[0] < range[1]) {
                    for (i=range[0]; i<=range[1]; i++) {
                        menu.addTextIconButton("LEVEL "+i,
                            (function(j){
                                return function() { 
                                    playLevel(j);
                                };
                            })(i),
                            (function(j){
                                return function(ctx,x,y) {
                                    var f = fruit.getFruitFromLevel(j);
                                    if (f) {
                                        atlas.drawFruitSprite(ctx,x,y,f.name);
                                    }
                                };
                            })(i));
                    }
                }
                menu.addSpacer(0.5);
                menu.addTextButton("BACK",
                    function() {
                        exitTo(selectActState);
                    });
                menu.backButton = menu.buttons[menu.buttonCount-1];
                menu.enable();
            };

            return {
                init: function() {
                    setFruitFromGameMode();
                    buildMenu(act);
                    gameTitleState.init();
                },
                setAct: function(a) {
                    act = a;
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(menu.draw,menu);
                    gameTitleState.draw();
                },
                update: function() {
                    gameTitleState.update();
                },
                getMenu: function() {
                    return menu;
                },
            };
            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // About Game State
            // (the screen shows some information about the game)

            var aboutGameState = (function() {

            var exitTo = function(s,fade) {
                gameTitleState.shutdown();
                menu.disable();
                switchState(s,fade);
            };

            var menu = new Menu("",2*tileSize,0,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");

            menu.addSpacer(8);
            menu.addTextButton("BACK",
                function() {
                    exitTo(preNewGameState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];

            var desc;
            var numDescLines;

            var drawDesc = function(ctx){
                ctx.font = tileSize+"px ArcadeR";
                ctx.fillStyle = "#FFF";
                ctx.textBaseline = "top";
                ctx.textAlign = "center";
                var y = 12*tileSize;
                var i;
                for (i=0; i<numDescLines; i++) {
                    ctx.fillText(desc[i],14*tileSize,y+i*2*tileSize);
                }
            };

            return {
                init: function() {
                    menu.enable();
                    gameTitleState.init();
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(menu.draw,menu);
                    gameTitleState.draw();
                    desc = getGameDescription();
                    numDescLines = desc.length;
                    renderer.renderFunc(drawDesc);
                },
                update: function() {
                    gameTitleState.update();
                },
                getMenu: function() {
                    return menu;
                },
            };
            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Cut Scene Menu State
            // (the screen that shows a list of the available cutscenes for the current game)

            var cutSceneMenuState = (function() {

            var exitTo = function(s,fade) {
                gameTitleState.shutdown();
                menu.disable();
                switchState(s,fade);
            };

            var exitToCutscene = function(s) {
                if (s) {
                    gameTitleState.shutdown();
                    menu.disable();
                    playCutScene(s,cutSceneMenuState);
                }
            };

            var menu = new Menu("",2*tileSize,0,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");

            menu.addSpacer(2);
            menu.addTextButton("CUTSCENE 1",
                function() { 
                    exitToCutscene(cutscenes[gameMode][0]);
                });
            menu.addTextButton("CUTSCENE 2",
                function() { 
                    exitToCutscene(cutscenes[gameMode][1]);
                });
            menu.addTextButton("CUTSCENE 3",
                function() { 
                    exitToCutscene(cutscenes[gameMode][2]);
                });
            menu.addSpacer();
            menu.addTextButton("BACK",
                function() {
                    exitTo(preNewGameState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];

            return {
                init: function() {
                    menu.enable();
                    gameTitleState.init();
                    level = 0;
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(menu.draw,menu);
                    gameTitleState.draw();
                },
                update: function() {
                    gameTitleState.update();
                },
                getMenu: function() {
                    return menu;
                },
            };
            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // Score State
            // (the high score screen state)

            var scoreState = (function(){

            var exitTo = function(s) {
                switchState(s);
                menu.disable();
            };

            var menu = new Menu("", 2*tileSize,mapHeight-6*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            menu.addTextButton("BACK",
                function() {
                    exitTo(homeState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];

            var frame = 0;

            var bulbs = {};
            var numBulbs;
            (function(){
                var x = -1.5*tileSize;
                var y = -1*tileSize;
                var w = 18*tileSize;
                var h = 29*tileSize;
                var s = 3;

                var i=0;
                var x0 = x;
                var y0 = y;
                var addBulb = function(x,y) { bulbs[i++] = { x:x, y:y }; };
                for (; y0<y+h; y0+=s) { addBulb(x0,y0); }
                for (; x0<x+w; x0+=s) { addBulb(x0,y0); }
                for (; y0>y; y0-=s) { addBulb(x0,y0); }
                for (; x0>x; x0-=s) { addBulb(x0,y0); }

                numBulbs = i;
            })();

            var drawScoreBox = function(ctx) {

                // draw chaser lights around the marquee
                ctx.fillStyle = "#555";
                var i,b,s=2;
                for (i=0; i<numBulbs; i++) {
                    b = bulbs[i];
                    ctx.fillRect(b.x, b.y, s, s);
                }
                ctx.fillStyle = "#FFF";
                for (i=0; i<63; i++) {
                    b = bulbs[(i*4+Math.floor(frame/2))%numBulbs];
                    ctx.fillRect(b.x, b.y, s, s);
                }

                ctx.font = tileSize+"px ArcadeR";
                ctx.textBaseline = "top";
                ctx.textAlign = "right";
                var scoreColor = "#AAA";
                var captionColor = "#444";

                var x,y;
                x = 9*tileSize;
                y = 0;
                ctx.fillStyle = "#FFF"; ctx.fillText("HIGH SCORES", x+4*tileSize,y);
                y += tileSize*4;

                var drawContrails = function(x,y) {
                    ctx.lineWidth = 1.0;
                    ctx.lineCap = "round";
                    ctx.strokeStyle = "rgba(255,255,255,0.5)";

                    ctx.save();
                    ctx.translate(-2.5,0);

                    var dy;
                    for (dy=-4; dy<=4; dy+=2) {
                        ctx.beginPath();
                        ctx.moveTo(x+tileSize,y+dy);
                        ctx.lineTo(x+tileSize*(Math.random()*0.5+1.5),y+dy);
                        ctx.stroke();
                    }
                    ctx.restore();

                };

                ctx.fillStyle = scoreColor; ctx.fillText(highScores[0], x,y);
                atlas.drawPacmanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);
                y += tileSize*2;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[1], x,y);
                drawContrails(x+2*tileSize,y+tileSize/2);
                atlas.drawPacmanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);

                y += tileSize*3;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[2], x,y);
                atlas.drawMsPacmanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);
                y += tileSize*2;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[3], x,y);
                drawContrails(x+2*tileSize,y+tileSize/2);
                atlas.drawMsPacmanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);

                y += tileSize*3;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[6], x,y);
                atlas.drawOttoSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,0);
                y += tileSize*2;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[7], x,y);
                drawContrails(x+2*tileSize,y+tileSize/2);
                atlas.drawOttoSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,0);

                y += tileSize*3;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[4], x,y);
                atlas.drawCookiemanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);
                y += tileSize*2;
                ctx.fillStyle = scoreColor; ctx.fillText(highScores[5], x,y);
                drawContrails(x+2*tileSize,y+tileSize/2);
                atlas.drawCookiemanSprite(ctx,x+2*tileSize,y+tileSize/2,DIR_LEFT,1);
            };

            var drawFood = function(ctx) {
                ctx.globalAlpha = 0.5;
                ctx.font = tileSize + "px sans-serif";
                ctx.textBaseline = "middle";
                ctx.textAlign = "left";

                var x = 20*tileSize;
                var y = 0;

                ctx.fillStyle = "#ffb8ae";
                ctx.fillRect(x-1,y-1.5,2,2);
                ctx.fillStyle = "#FFF";
                ctx.fillText("10",x+tileSize,y);
                y += 1.5*tileSize;

                ctx.fillStyle = "#ffb8ae";
                ctx.beginPath();
                ctx.arc(x,y-0.5,tileSize/2,0,Math.PI*2);
                ctx.fill();
                ctx.fillStyle = "#FFF";
                ctx.fillText("50",x+tileSize,y);

                y += 3*tileSize;
                atlas.drawGhostSprite(ctx,x,y,0,DIR_RIGHT,true);
                atlas.drawGhostPoints(ctx,x+2*tileSize,y,200);

                var alpha = ctx.globalAlpha;

                y += 2*tileSize;
                ctx.globalAlpha = alpha*0.5;
                atlas.drawGhostSprite(ctx,x,y,0,DIR_RIGHT,true);
                ctx.globalAlpha = alpha;
                atlas.drawGhostSprite(ctx,x+2*tileSize,y,0,DIR_RIGHT,true);
                atlas.drawGhostPoints(ctx,x+4*tileSize,y,400);

                y += 2*tileSize;
                ctx.globalAlpha = alpha*0.5;
                atlas.drawGhostSprite(ctx,x,y,0,DIR_RIGHT,true);
                atlas.drawGhostSprite(ctx,x+2*tileSize,y,0,DIR_RIGHT,true);
                ctx.globalAlpha = alpha;
                atlas.drawGhostSprite(ctx,x+4*tileSize,y,0,DIR_RIGHT,true);
                atlas.drawGhostPoints(ctx,x+6*tileSize,y,800);

                y += 2*tileSize;
                ctx.globalAlpha = alpha*0.5;
                atlas.drawGhostSprite(ctx,x,y,0,DIR_RIGHT,true);
                atlas.drawGhostSprite(ctx,x+2*tileSize,y,0,DIR_RIGHT,true);
                atlas.drawGhostSprite(ctx,x+4*tileSize,y,0,DIR_RIGHT,true);
                ctx.globalAlpha = alpha;
                atlas.drawGhostSprite(ctx,x+6*tileSize,y,0,DIR_RIGHT,true);
                atlas.drawGhostPoints(ctx,x+8*tileSize,y,1600);

                var mspac_fruits = [
                    {name: 'cherry',     points: 100},
                    {name: 'strawberry', points: 200},
                    {name: 'orange',     points: 500},
                    {name: 'pretzel',    points: 700},
                    {name: 'apple',      points: 1000},
                    {name: 'pear',       points: 2000},
                    {name: 'banana',     points: 5000},
                ];

                var pac_fruits = [
                    {name:'cherry',     points:100},
                    {name:'strawberry', points:300},
                    {name:'orange',     points:500},
                    {name:'apple',      points:700},
                    {name:'melon',      points:1000},
                    {name:'galaxian',   points:2000},
                    {name:'bell',       points:3000},
                    {name:'key',        points:5000},
                ];

                var i,f;
                y += 3*tileSize;
                for (i=0; i<pac_fruits.length; i++) {
                    f = pac_fruits[i];
                    atlas.drawFruitSprite(ctx,x,y,f.name);
                    atlas.drawPacFruitPoints(ctx,x+2*tileSize,y,f.points);
                    y += 2*tileSize;
                }
                x += 6*tileSize;
                y = 13.5*tileSize;
                for (i=0; i<mspac_fruits.length; i++) {
                    f = mspac_fruits[i];
                    atlas.drawFruitSprite(ctx,x,y,f.name);
                    atlas.drawMsPacFruitPoints(ctx,x+2*tileSize,y,f.points);
                    y += 2*tileSize;
                }
                ctx.globalAlpha = 1;
            };

            return {
                init: function() {
                    menu.enable();
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.renderFunc(drawScoreBox);
                    renderer.renderFunc(drawFood);
                    renderer.renderFunc(menu.draw,menu);
                },
                update: function() {
                    menu.update();
                    frame++;
                },
                getMenu: function() {
                    return menu;
                },
            };

            })();

            //////////////////////////////////////////////////////////////////////////////////////
            // About State
            // (the about screen state)

            var aboutState = (function(){

            var exitTo = function(s) {
                switchState(s);
                menu.disable();
            };

            var menu = new Menu("", 2*tileSize,mapHeight-11*tileSize,mapWidth-4*tileSize,3*tileSize,tileSize,tileSize+"px ArcadeR", "#EEE");
            menu.addTextButton("GO TO PROJECT PAGE",
                function() {
                    window.open("https://github.com/shaunew/Pac-Man");
                });
            menu.addTextButton("BACK",
                function() {
                    exitTo(homeState);
                });
            menu.backButton = menu.buttons[menu.buttonCount-1];

            var drawBody = function(ctx) {
                ctx.font = tileSize+"px ArcadeR";
                ctx.textBaseline = "top";
                ctx.textAlign = "left";

                var x,y;
                x = 2*tileSize;
                y = 0*tileSize;
                ctx.fillStyle = "#0FF";
                ctx.fillText("DEVELOPER", x,y);
                y += tileSize*2;
                ctx.fillStyle = "#777";
                ctx.fillText("SHAUN WILLIAMS", x,y);

                y += tileSize*4;
                ctx.fillStyle = "#0FF";
                ctx.fillText("REVERSE-ENGINEERS",x,y);
                y += tileSize*2;
                ctx.fillStyle = "#777";
                ctx.fillText("JAMEY PITTMAN",x,y);
                y += tileSize*2;
                ctx.fillText("BART GRANTHAM",x,y);

                y += tileSize*4;
                ctx.fillStyle = "#FF0";
                ctx.fillText("PAC-MAN",x,y);
                y += tileSize*2;
                ctx.fillStyle = "#777";
                ctx.fillText("NAMCO",x,y);

                y += tileSize*4;
                ctx.fillStyle = "#FF0";
                ctx.fillText("MS. PAC-MAN / CRAZY OTTO",x,y);
                y += tileSize*2;
                ctx.fillStyle = "#777";
                ctx.fillText("GENERAL COMPUTING",x,y);
            };

            return {
                init: function() {
                    menu.enable();
                    galagaStars.init();
                },
                draw: function() {
                    renderer.clearMapFrame();
                    renderer.beginMapClip();
                    renderer.renderFunc(galagaStars.draw);
                    renderer.renderFunc(drawBody);
                    renderer.renderFunc(menu.draw,menu);
                    renderer.endMapClip();
                },
                update: function() {
                    galagaStars.update();
                    menu.update();
                },
                getMenu: function() {
                    return menu;
                },
            };

            })();

            ////////////////////////////////////////////////////
            // New Game state
            // (state when first starting a new game)

            var newGameState = (function() {
            var frames;
            var duration = 0;
            var startLevel = 1;

            return {
                init: function() {
                    clearCheats();
                    frames = 0;
                    level = startLevel-1;
                    extraLives = practiceMode ? Infinity : 3;
                    setScore(0);
                    setFruitFromGameMode();
                    readyNewState.init();
                    
                },
                setStartLevel: function(i) {
                    startLevel = i;
                },
                draw: function() {
                    if (!map)
                        return;
                    renderer.blitMap();
                    renderer.drawScore();
                    renderer.drawMessage("PLAYER ONE", "#0FF", 9, 14);
                    renderer.drawReadyMessage();
                },
                update: function() {
                    if (frames == duration*60) {
                        extraLives--;
                        state = readyNewState;
                        renderer.drawMap();
                    }
                    else 
                        frames++;
                },
            };
            })();

            ////////////////////////////////////////////////////
            // Ready state
            // (state when map is displayed and pausing before play)

            var readyState =  (function(){
            var frames;
            var duration = .5;

            return {
                init: function() {
                    audio.startMusic.play();
                    var i;
                    for (i=0; i<5; i++)
                        actors[i].reset();
                    ghostCommander.reset();
                    fruit.reset();
                    energizer.reset();
                    map.resetTimeEaten();
                    frames = 0;
                    vcr.init();
                },
                draw: function() {
                    if (!map)
                        return;
                    renderer.blitMap();
                    renderer.drawScore();
                    renderer.drawActors();
                    renderer.drawReadyMessage();
                },
                update: function() {
                    if (frames == duration*60)
                        switchState(playState);
                    else
                        frames++;
                },
            };
            })();

            ////////////////////////////////////////////////////
            // Ready New Level state
            // (ready state when pausing before new level)

            var readyNewState = newChildObject(readyState, {

            init: function() {

                // increment level and ready the next map
                level++;
                if (gameMode == GAME_PACMAN) {
                    map = mapPacman;
                }
                else if (gameMode == GAME_MSPACMAN || gameMode == GAME_OTTO) {
                    setNextMsPacMap();
                }
                else if (gameMode == GAME_COOKIE) {
                    setNextCookieMap();
                }
                map.resetCurrent();
                fruit.onNewLevel();
                renderer.drawMap();

                // notify other objects of new level
                ghostReleaser.onNewLevel();
                elroyTimer.onNewLevel();

                // inherit attributes from readyState
                readyState.init.call(this);
            },
            });

            ////////////////////////////////////////////////////
            // Ready Restart Level state
            // (ready state when pausing before restarted level)

            var readyRestartState = newChildObject(readyState, {

            init: function() {
                extraLives--;
                ghostReleaser.onRestartLevel();
                elroyTimer.onRestartLevel();
                renderer.drawMap();

                // inherit attributes from readyState
                readyState.init.call(this);
            },
            });

            ////////////////////////////////////////////////////
            // Play state
            // (state when playing the game)

            var playState = {
            init: function() { 
                if (practiceMode) {
                    vcr.reset();
                }
            },
            draw: function() {
                renderer.setLevelFlash(false);
                renderer.blitMap();
                renderer.drawScore();
                renderer.beginMapClip();
                renderer.drawFruit();
                renderer.drawPaths();
                renderer.drawActors();
                renderer.drawTargets();
                renderer.endMapClip();
            },

            // handles collision between pac-man and ghosts
            // returns true if collision happened
            isPacmanCollide: function() {
                var i,g;
                for (i = 0; i<4; i++) {
                    g = ghosts[i];
                    if (g.tile.x == pacman.tile.x && g.tile.y == pacman.tile.y && g.mode == GHOST_OUTSIDE) {
                        if (g.scared) { // eat ghost
                            energizer.addPoints();
                            g.onEaten();
                        }
                        else if (pacman.invincible) // pass through ghost
                            continue;
                        else // killed by ghost
                            switchState(deadState);
                        return true;
                    }
                }
                return false;
            },
            update: function() {
                
                if (vcr.isSeeking()) {
                    vcr.seek();
                }
                else {
                    // record current state
                    if (vcr.getMode() == VCR_RECORD) {
                        vcr.record();
                    }

                    var i,j; // loop index
                    var maxSteps = 2;
                    var skip = false;

                    // skip this frame if needed,
                    // but update ghosts running home
                    if (energizer.showingPoints()) {
                        for (j=0; j<maxSteps; j++)
                            for (i=0; i<4; i++)
                                if (ghosts[i].mode == GHOST_GOING_HOME || ghosts[i].mode == GHOST_ENTERING_HOME)
                                    ghosts[i].update(j);
                        energizer.updatePointsTimer();
                        skip = true;
                    }
                    else { // make ghosts go home immediately after points disappear
                        for (i=0; i<4; i++)
                            if (ghosts[i].mode == GHOST_EATEN) {
                                ghosts[i].mode = GHOST_GOING_HOME;
                                ghosts[i].targetting = 'door';
                            }
                            ghosts[0].playSounds();
                    }
                    
                    if (!skip) {

                        // update counters
                        ghostReleaser.update();
                        ghostCommander.update();
                        elroyTimer.update();
                        fruit.update();
                        energizer.update();

                        // update actors one step at a time
                        for (j=0; j<maxSteps; j++) {

                            // advance pacman
                            pacman.update(j);

                            // test collision with fruit
                            fruit.testCollide();

                            // finish level if all dots have been eaten
                            if (map.allDotsEaten()) {
                                //this.draw(); 
                                switchState(finishState);
                                audio.extend.play();
                                break;
                            }

                            // test pacman collision before and after updating ghosts
                            // (redundant to prevent pass-throughs)
                            // (if collision happens, stop immediately.)
                            if (this.isPacmanCollide()) break;
                            for (i=0;i<4;i++) actors[i].update(j);
                            if (this.isPacmanCollide()) break;
                        }

                        // update frame counts
                        for (i=0; i<5; i++)
                            actors[i].frames++;
                    }
                }
            },
            };

            ////////////////////////////////////////////////////
            // Script state
            // (a state that triggers functions at certain times)

            var scriptState = (function(){

            return {
                init: function() {
                    this.frames = 0;        // frames since state began
                    this.triggerFrame = 0;  // frames since last trigger

                    var trigger = this.triggers[0];
                    this.drawFunc = trigger ? trigger.draw : undefined;   // current draw function
                    this.updateFunc = trigger ? trigger.update : undefined; // current update function
                },
                update: function() {

                    // if trigger is found for current time,
                    // call its init() function
                    // and store its draw() and update() functions
                    var trigger = this.triggers[this.frames];
                    if (trigger) {
                        if (trigger.init) trigger.init();
                        this.drawFunc = trigger.draw;
                        this.updateFunc = trigger.update;
                        this.triggerFrame = 0;
                    }

                    // call the last trigger's update function
                    if (this.updateFunc) 
                        this.updateFunc(this.triggerFrame);

                    this.frames++;
                    this.triggerFrame++;
                },
                draw: function() {
                    // call the last trigger's draw function
                    if (this.drawFunc) 
                        this.drawFunc(this.triggerFrame);
                },
            };
            })();

            ////////////////////////////////////////////////////
            // Seekable Script state
            // (a script state that can be controled by the VCR)

            var seekableScriptState = newChildObject(scriptState, {

            init: function() {
                scriptState.init.call(this);
                this.savedFrames = {};
                this.savedTriggerFrame = {};
                this.savedDrawFunc = {};
                this.savedUpdateFunc = {};
            },

            save: function(t) {
                this.savedFrames[t] = this.frames;
                this.savedTriggerFrame[t] = this.triggerFrame;
                this.savedDrawFunc[t] = this.drawFunc;
                this.savedUpdateFunc[t] = this.updateFunc;
            },
            load: function(t) {
                this.frames = this.savedFrames[t];
                this.triggerFrame = this.savedTriggerFrame[t];
                this.drawFunc = this.savedDrawFunc[t];
                this.updateFunc = this.savedUpdateFunc[t];
            },
            update: function() {
                if (vcr.isSeeking()) {
                    vcr.seek();
                }
                else {
                    if (vcr.getMode() == VCR_RECORD) {
                        vcr.record();
                    }
                    scriptState.update.call(this);
                }
            },
            draw: function() {
                if (this.drawFunc) {
                    scriptState.draw.call(this);
                }
            },
            });

            ////////////////////////////////////////////////////
            // Dead state
            // (state when player has lost a life)

            var deadState = (function() {

            // this state will always have these drawn
            var commonDraw = function() {
                renderer.blitMap();
                renderer.drawScore();
            };

            return newChildObject(seekableScriptState, {

                // script functions for each time
                triggers: {
                    0: { // freeze
                        init: function() {
                            audio.die.play();
                        },
                        update: function() {
                            var i;
                            for (i=0; i<4; i++) 
                                actors[i].frames++; // keep animating ghosts
                        },
                        draw: function() {
                            commonDraw();
                            renderer.beginMapClip();
                            renderer.drawFruit();
                            renderer.drawActors();
                            renderer.endMapClip();
                        }
                    },
                    60: {
                        draw: function() { // isolate pacman
                            commonDraw();
                            renderer.beginMapClip();
                            renderer.drawPlayer();
                            renderer.endMapClip();
                        },
                    },
                    120: {
                        draw: function(t) { // dying animation
                            commonDraw();
                            renderer.beginMapClip();
                            renderer.drawDyingPlayer(t/75);
                            renderer.endMapClip();
                        },
                    },
                    195: {
                        draw: function() {
                            commonDraw();
                            renderer.beginMapClip();
                            renderer.drawDyingPlayer(1);
                            renderer.endMapClip();
                        },
                    },
                    240: {
                        draw: function() {
                            commonDraw();
                            renderer.beginMapClip();
                            renderer.drawDyingPlayer(1);
                            renderer.endMapClip();
                        },
                        init: function() { // leave
                            switchState( extraLives == 0 ? overState : readyRestartState);
                        }
                    },
                },
            });
            })();

            ////////////////////////////////////////////////////
            // Finish state
            // (state when player has completed a level)

            var finishState = (function(){

            // this state will always have these drawn
            var commonDraw = function() {
                renderer.blitMap();
                renderer.drawScore();

                renderer.beginMapClip();
                renderer.drawPlayer();
                renderer.endMapClip();
            };

            // flash the floor and draw
            var flashFloorAndDraw = function(on) {
                renderer.setLevelFlash(on);
                commonDraw();
            };

            return newChildObject(seekableScriptState, {

                // script functions for each time
                triggers: {
                    0:   { draw: function() {
                            renderer.setLevelFlash(false);
                            renderer.blitMap();
                            renderer.drawScore();
                            renderer.beginMapClip();
                            renderer.drawFruit();
                            renderer.drawActors();
                            renderer.drawTargets();
                            renderer.endMapClip();
                    } },
                    120:  { draw: function() { flashFloorAndDraw(true); } },
                    132: { draw: function() { flashFloorAndDraw(false); } },
                    144: { draw: function() { flashFloorAndDraw(true); } },
                    156: { draw: function() { flashFloorAndDraw(false); } },
                    168: { draw: function() { flashFloorAndDraw(true); } },
                    180: { draw: function() { flashFloorAndDraw(false); } },
                    192: { draw: function() { flashFloorAndDraw(true); } },
                    204: { draw: function() { flashFloorAndDraw(false); } },
                    216: {
                        init: function() {
                            if (!triggerCutsceneAtEndLevel()) {
                                switchState(readyNewState,60);
                            }
                        }
                    },
                },
            });
            })();

            ////////////////////////////////////////////////////
            // Game Over state
            // (state when player has lost last life)

            var overState = (function() {
            var frames;
            return {
                init: function() {
                    frames = 0;
                },
                draw: function() {
                    renderer.blitMap();
                    renderer.drawScore();
                    renderer.drawMessage("GAME  OVER", "#F00", 9, 20);
                },
                update: function() {
                    if (frames == 120) {
                        switchState(homeState,60);
                    }
                    else
                        frames++;
                },
            };
            })();

            //@line 1 "src/input.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Input
            // (Handles all key presses and touches)

            (function(){

            // A Key Listener class (each key maps to an array of callbacks)
            var KeyEventListener = function() {
                this.listeners = {};
            };
            KeyEventListener.prototype = {
                add: function(key, callback, isActive) {
                    this.listeners[key] = this.listeners[key] || [];
                    this.listeners[key].push({
                        isActive: isActive,
                        callback: callback,
                    });
                },
                exec: function(key, e) {
                    var keyListeners = this.listeners[key];
                    if (!keyListeners) {
                        return;
                    }
                    var i,l;
                    var numListeners = keyListeners.length;
                    for (i=0; i<numListeners; i++) {
                        l = keyListeners[i];
                        if (!l.isActive || l.isActive()) {
                            e.preventDefault();
                            if (l.callback()) { // do not propagate keys if returns true
                                break;
                            }
                        }
                    }
                },
            };

            // declare key event listeners
            var keyDownListeners = new KeyEventListener();
            var keyUpListeners = new KeyEventListener();

            // helper functions for adding custom key listeners
            var addKeyDown = function(key,callback,isActive) { keyDownListeners.add(key,callback,isActive); };
            var addKeyUp   = function(key,callback,isActive) { keyUpListeners.add(key,callback,isActive); };

            // boolean states of each key
            var keyStates = {};

            // hook my key listeners to the window's listeners
            window.addEventListener("keydown", function(e) {
                var key = (e||window.event).keyCode;

                // only execute at first press event
                if (!keyStates[key]) {
                    keyStates[key] = true;
                    keyDownListeners.exec(key, e);
                }
            });
            window.addEventListener("keyup",function(e) {
                var key = (e||window.event).keyCode;

                keyStates[key] = false;
                keyUpListeners.exec(key, e);
            });


            // key enumerations

            var KEY_ENTER = 13;
            var KEY_ESC = 27;

            var KEY_LEFT = 37;
            var KEY_RIGHT = 39;
            var KEY_UP = 38;
            var KEY_DOWN = 40;

            var KEY_SHIFT = 16;
            var KEY_CTRL = 17;
            var KEY_ALT = 18;

            var KEY_SPACE = 32;

            var KEY_M = 77;
            var KEY_N = 78;
            var KEY_Q = 81;
            var KEY_W = 87;
            var KEY_E = 69;
            var KEY_R = 82;
            var KEY_T = 84;

            var KEY_A = 65;
            var KEY_S = 83;
            var KEY_D = 68;
            var KEY_F = 70;
            var KEY_G = 71;

            var KEY_I = 73;
            var KEY_O = 79;
            var KEY_P = 80;

            var KEY_1 = 49;
            var KEY_2 = 50;

            var KEY_END = 35;

            // Custom Key Listeners

            // Menu Navigation Keys
            var menu;
            var isInMenu = function() {
                menu = (state.getMenu && state.getMenu());
                if (!menu && inGameMenu.isOpen()) {
                    menu = inGameMenu.getMenu();
                }
                return menu;
            };
            addKeyDown(KEY_ESC,   function(){ menu.backButton ? menu.backButton.onclick():0; return true; }, isInMenu);
            addKeyDown(KEY_ENTER, function(){ menu.clickCurrentOption(); }, isInMenu);
            var isMenuKeysAllowed = function() {
                var menu = isInMenu();
                return menu && !menu.noArrowKeys;
            };
            addKeyDown(KEY_UP,    function(){ menu.selectPrevOption(); }, isMenuKeysAllowed);
            addKeyDown(KEY_DOWN,  function(){ menu.selectNextOption(); }, isMenuKeysAllowed);
            var isInGameMenuButtonClickable = function() {
                return hud.isValidState() && !inGameMenu.isOpen();
            };
            addKeyDown(KEY_ESC, function() { inGameMenu.getMenuButton().onclick(); return true; }, isInGameMenuButtonClickable);

            // Move Pac-Man
            var isPlayState = function() { return state == learnState || state == newGameState || state == playState || state == readyNewState || state == readyRestartState; };
            addKeyDown(KEY_LEFT,  function() { pacman.setInputDir(DIR_LEFT); },  isPlayState);
            addKeyDown(KEY_RIGHT, function() { pacman.setInputDir(DIR_RIGHT); }, isPlayState);
            addKeyDown(KEY_UP,    function() { pacman.setInputDir(DIR_UP); },    isPlayState);
            addKeyDown(KEY_DOWN,  function() { pacman.setInputDir(DIR_DOWN); },  isPlayState);
            addKeyUp  (KEY_LEFT,  function() { pacman.clearInputDir(DIR_LEFT); },  isPlayState);
            addKeyUp  (KEY_RIGHT, function() { pacman.clearInputDir(DIR_RIGHT); }, isPlayState);
            addKeyUp  (KEY_UP,    function() { pacman.clearInputDir(DIR_UP); },    isPlayState);
            addKeyUp  (KEY_DOWN,  function() { pacman.clearInputDir(DIR_DOWN); },  isPlayState);

            // Slow-Motion
            var isPracticeMode = function() { return isPlayState() && practiceMode; };
            //isPracticeMode = function() { return true; };
            addKeyDown(KEY_1, function() { executive.setUpdatesPerSecond(30); }, isPracticeMode);
            addKeyDown(KEY_2,  function() { executive.setUpdatesPerSecond(15); }, isPracticeMode);
            addKeyUp  (KEY_1, function() { executive.setUpdatesPerSecond(60); }, isPracticeMode);
            addKeyUp  (KEY_2,  function() { executive.setUpdatesPerSecond(60); }, isPracticeMode);

            // Toggle VCR
            var canSeek = function() { return !isInMenu() && vcr.getMode() != VCR_NONE; };
            addKeyDown(KEY_SHIFT, function() { vcr.startSeeking(); },   canSeek);
            addKeyUp  (KEY_SHIFT, function() { vcr.startRecording(); }, canSeek);

            // Adjust VCR seeking
            var isSeekState = function() { return vcr.isSeeking(); };
            addKeyDown(KEY_UP,   function() { vcr.nextSpeed(1); },  isSeekState);
            addKeyDown(KEY_DOWN, function() { vcr.nextSpeed(-1); }, isSeekState);

            // Skip Level
            var canSkip = function() {
                return isPracticeMode() && 
                    (state == newGameState ||
                    state == readyNewState ||
                    state == readyRestartState ||
                    state == playState ||
                    state == deadState ||
                    state == finishState ||
                    state == overState);
            };
            addKeyDown(KEY_N, function() { switchState(readyNewState, 60); }, canSkip);
            addKeyDown(KEY_M, function() { switchState(finishState); }, function() { return state == playState; });

            // Draw Actor Targets (fishpoles)
            addKeyDown(KEY_Q, function() { blinky.isDrawTarget = !blinky.isDrawTarget; }, isPracticeMode);
            addKeyDown(KEY_W, function() { pinky.isDrawTarget = !pinky.isDrawTarget; }, isPracticeMode);
            addKeyDown(KEY_E, function() { inky.isDrawTarget = !inky.isDrawTarget; }, isPracticeMode);
            addKeyDown(KEY_R, function() { clyde.isDrawTarget = !clyde.isDrawTarget; }, isPracticeMode);
            addKeyDown(KEY_T, function() { pacman.isDrawTarget = !pacman.isDrawTarget; }, isPracticeMode);

            // Draw Actor Paths
            addKeyDown(KEY_A, function() { blinky.isDrawPath = !blinky.isDrawPath; }, isPracticeMode);
            addKeyDown(KEY_S, function() { pinky.isDrawPath = !pinky.isDrawPath; }, isPracticeMode);
            addKeyDown(KEY_D, function() { inky.isDrawPath = !inky.isDrawPath; }, isPracticeMode);
            addKeyDown(KEY_F, function() { clyde.isDrawPath = !clyde.isDrawPath; }, isPracticeMode);
            addKeyDown(KEY_G, function() { pacman.isDrawPath = !pacman.isDrawPath; }, isPracticeMode);

            // Miscellaneous Cheats
            addKeyDown(KEY_I, function() { pacman.invincible = !pacman.invincible; }, isPracticeMode);
            addKeyDown(KEY_O, function() { turboMode = !turboMode; }, isPracticeMode);
            addKeyDown(KEY_P, function() { pacman.ai = !pacman.ai; }, isPracticeMode);

            addKeyDown(KEY_END, function() { executive.togglePause(); });

            })();

            var initSwipe = function() {

            // position of anchor
            var x = 0;
            var y = 0;

            // current distance from anchor
            var dx = 0;
            var dy = 0;

            // minimum distance from anchor before direction is registered
            var r = 4;

            var touchStart = function(event) {
                event.preventDefault();
                var fingerCount = event.touches.length;
                if (fingerCount == 1) {

                    // commit new anchor
                    x = event.touches[0].pageX;
                    y = event.touches[0].pageY;

                }
                else {
                    touchCancel(event);
                }
            };

            var touchMove = function(event) {
                event.preventDefault();
                var fingerCount = event.touches.length;
                if (fingerCount == 1) {

                    // get current distance from anchor
                    dx = event.touches[0].pageX - x;
                    dy = event.touches[0].pageY - y;

                    // if minimum move distance is reached
                    if (dx*dx+dy*dy >= r*r) {

                        // commit new anchor
                        x += dx;
                        y += dy;

                        // register direction
                        if (Math.abs(dx) >= Math.abs(dy)) {
                            pacman.setInputDir(dx>0 ? DIR_RIGHT : DIR_LEFT);
                        }
                        else {
                            pacman.setInputDir(dy>0 ? DIR_DOWN : DIR_UP);
                        }
                    }
                }
                else {
                    touchCancel(event);
                }
            };

            var touchEnd = function(event) {
                event.preventDefault();
            };

            var touchCancel = function(event) {
                event.preventDefault();
                x=y=dx=dy=0;
            };

            var touchTap = function(event) {
                // tap to clear input directions
                pacman.clearInputDir(undefined);
            };

            // register touch events
            document.onclick = touchTap;
            document.ontouchstart = touchStart;
            document.ontouchend = touchEnd;
            document.ontouchmove = touchMove;
            document.ontouchcancel = touchCancel;
            };
            //@line 1 "src/cutscenes.js"
            ////////////////////////////////////////////////
            // Cutscenes
            //

            var playCutScene = function(cutScene, nextState) {

            // redraw map buffer with fruit list but no map structure
            map = undefined;
            renderer.drawMap(true);

            // miss the audio silence and time it cleanly for pacman cut scene 1
            setTimeout(audio.coffeeBreakMusic.startLoop, 1200);
            cutScene.nextState = nextState;
            switchState(cutScene, 60);

            };

            var pacmanCutscene1 = newChildObject(scriptState, {
            init: function() {
                scriptState.init.call(this);

                // initialize actor positions
                pacman.setPos(232, 164);
                blinky.setPos(257, 164);

                // initialize actor directions
                blinky.setDir(DIR_LEFT);
                blinky.faceDirEnum = DIR_LEFT;
                pacman.setDir(DIR_LEFT);

                // initialize misc actor properties
                blinky.scared = false;
                blinky.mode = GHOST_OUTSIDE;

                // clear other states
                backupCheats();
                clearCheats();
                energizer.reset();

                // temporarily override actor step sizes
                pacman.getNumSteps = function() {
                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_PACMAN);
                };
                blinky.getNumSteps = function() {
                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                };

                // temporarily override steering functions
                pacman.steer = blinky.steer = function(){};
            },
            triggers: {

                // Blinky chases Pac-Man
                0: {
                    update: function() {
                        var j;
                        for (j=0; j<2; j++) {
                            pacman.update(j);
                            blinky.update(j);
                        }
                        pacman.frames++;
                        blinky.frames++;
                    },
                    draw: function() {
                        renderer.blitMap();
                        renderer.beginMapClip();
                        renderer.drawPlayer();
                        renderer.drawGhost(blinky);
                        renderer.endMapClip();
                    },
                },

                // Pac-Man chases Blinky
                260: {
                    init: function() {
                        pacman.setPos(-193, 155);
                        blinky.setPos(-8, 164);

                        // initialize actor directions
                        blinky.setDir(DIR_RIGHT);
                        blinky.faceDirEnum = DIR_RIGHT;
                        pacman.setDir(DIR_RIGHT);

                        // initialize misc actor properties
                        blinky.scared = true;

                        // temporarily override step sizes
                        pacman.getNumSteps = function() {
                            return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_PACMAN_FRIGHT);
                        };
                        blinky.getNumSteps = function() {
                            return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_GHOST_FRIGHT);
                        };
                    },
                    update: function() {
                        var j;
                        for (j=0; j<2; j++) {
                            pacman.update(j);
                            blinky.update(j);
                        }
                        pacman.frames++;
                        blinky.frames++;
                    },
                    draw: function() {
                        renderer.blitMap();
                        renderer.beginMapClip();
                        renderer.drawGhost(blinky);
                        renderer.renderFunc(function(ctx) {
                            var frame = Math.floor(pacman.steps/4) % 4; // slower to switch animation frame when giant
                            if (frame == 3) {
                                frame = 1;
                            }
                            drawGiantPacmanSprite(ctx, pacman.pixel.x, pacman.pixel.y, pacman.dirEnum, frame);
                        });
                        renderer.endMapClip();
                    },
                },

                // end
                640: {
                    init: function() {
                        // disable custom steps
                        delete pacman.getNumSteps;
                        delete blinky.getNumSteps;

                        // disable custom steering
                        delete pacman.steer;
                        delete blinky.steer;

                        // exit to next level
                        restoreCheats();
                        switchState(pacmanCutscene1.nextState, 60);
                    },
                },
            },
            });

            var mspacmanCutscene1 = (function() {

            // create new players pac and mspac for this scene
            var pac = new Player();
            var mspac = new Player();

            // draws pac or mspac
            var drawPlayer = function(ctx,player) {
                var frame = player.getAnimFrame();
                var func;
                if (player == pac) {
                    func = gameMode == GAME_MSPACMAN ? atlas.drawPacmanSprite : atlas.drawOttoSprite;
                }
                else if (player == mspac) {
                    func = gameMode == GAME_MSPACMAN ? atlas.drawMsPacmanSprite : atlas.drawMsOttoSprite;
                }
                func(ctx, player.pixel.x, player.pixel.y, player.dirEnum, frame);
            };

            // draws all actors
            var draw = function() {
                renderer.blitMap();
                renderer.beginMapClip();
                renderer.renderFunc(function(ctx) {
                    drawPlayer(ctx,pac);
                    drawPlayer(ctx,mspac);
                });
                renderer.drawGhost(inky);
                renderer.drawGhost(pinky);
                renderer.endMapClip();
            };

            // updates all actors
            var update = function() {
                var j;
                for (j=0; j<2; j++) {
                    pac.update(j);
                    mspac.update(j);
                    inky.update(j);
                    pinky.update(j);
                }
                pac.frames++;
                mspac.frames++;
                inky.frames++;
                pinky.frames++;
            };

            var exit = function() {
                // disable custom steps
                delete inky.getNumSteps;
                delete pinky.getNumSteps;

                // disable custom steering
                delete inky.steer;
                delete pinky.steer;

                // disable custom animation steps
                delete inky.getAnimFrame;
                delete pinky.getAnimFrame;

                // exit to next level
                restoreCheats();
                switchState(mspacmanCutscene1.nextState, 60);
            };

            return newChildObject(scriptState, {

                init: function() {
                    scriptState.init.call(this);

                    // chosen by trial-and-error to match animations
                    mspac.frames = 20;
                    pac.frames = 12;

                    // initialize actor states
                    pac.setPos(-10, 99);
                    pac.setDir(DIR_RIGHT);
                    mspac.setPos(232, 180);
                    mspac.setDir(DIR_LEFT);
                    
                    // initial ghost states
                    inky.frames = 0;
                    inky.mode = GHOST_OUTSIDE;
                    inky.scared = false;
                    inky.setPos(pac.pixel.x-42, 99);
                    inky.setDir(DIR_RIGHT);
                    inky.faceDirEnum = DIR_RIGHT;
                    pinky.frames = 3;
                    pinky.mode = GHOST_OUTSIDE;
                    pinky.scared = false;
                    pinky.setPos(mspac.pixel.x+49, 180);
                    pinky.setDir(DIR_LEFT);
                    pinky.faceDirEnum = DIR_LEFT;

                    // clear other states
                    backupCheats();
                    clearCheats();
                    energizer.reset();

                    // step player animation every four frames
                    pac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };
                    mspac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };

                    // step ghost animation every six frames
                    inky.getAnimFrame = function() { return Math.floor(this.frames/8)%2; };
                    pinky.getAnimFrame = function() { return Math.floor(this.frames/8)%2; };

                    // set actor step sizes
                    pac.getNumSteps = function() { return 1; };
                    mspac.getNumSteps = function() { return 1; };
                    inky.getNumSteps = function() { return 1; };
                    pinky.getNumSteps = function() { return 1; };

                    // set steering functions
                    pac.steer = function(){};
                    mspac.steer = function(){};
                    inky.steer = function(){};
                    pinky.steer = function(){};
                },
                triggers: {

                    // Inky chases Pac, Pinky chases Mspac
                    0: {
                        update: function() {
                            update();
                            if (inky.pixel.x == 105) {
                                // speed up the ghosts
                                inky.getNumSteps = function() {
                                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                                };
                                pinky.getNumSteps = function() {
                                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                                };
                            }
                        },
                        draw: draw,
                    },

                    // MsPac and Pac converge with ghosts chasing
                    300: (function(){

                        // bounce animation when ghosts bump heads
                        var inkyBounceX =  [ 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
                        var inkyBounceY =  [-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1];
                        var pinkyBounceX = [ 0, 0, 0, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0];
                        var pinkyBounceY = [ 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0];
                        var inkyBounceFrame = 0;
                        var pinkyBounceFrame = 0;
                        var inkyBounceFrameLen = inkyBounceX.length;
                        var pinkyBounceFrameLen = pinkyBounceX.length;

                        // ramp animation for players
                        var rampX = [0, 1, 1, 1, 1, 0, 0];
                        var rampY = [0, 0,-1,-1,-1, 0, 0];
                        var rampFrame = 0;
                        var rampFrameLen = rampX.length;

                        // climbing
                        var climbFrame = 0;

                        // meeting
                        var meetFrame = 0;

                        var ghostMode;
                        var GHOST_RUN = 0;
                        var GHOST_BUMP = 1;

                        var playerMode;
                        var PLAYER_RUN = 0;
                        var PLAYER_RAMP = 1;
                        var PLAYER_CLIMB = 2;
                        var PLAYER_MEET = 3;
                            
                        return {
                            init: function() {
                                // reset frames
                                inkyBounceFrame = pinkyBounceFrame = rampFrame = climbFrame = meetFrame = 0;

                                // set modes
                                ghostMode = GHOST_RUN;
                                playerMode = PLAYER_RUN;

                                // set initial positions and directions
                                mspac.setPos(-8,143);
                                mspac.setDir(DIR_RIGHT);

                                pinky.setPos(-81,143);
                                pinky.faceDirEnum = DIR_RIGHT;
                                pinky.setDir(DIR_RIGHT);

                                pac.setPos(223+8+3,142);
                                pac.setDir(DIR_LEFT);

                                inky.setPos(302,143);
                                inky.faceDirEnum = DIR_LEFT;
                                inky.setDir(DIR_LEFT);

                                // set ghost speed
                                inky.getNumSteps = pinky.getNumSteps = function() {
                                    return "11211212"[this.frames%8];
                                };
                            },
                            update: function() {
                                var j;

                                // update players
                                if (playerMode == PLAYER_RUN) {
                                    for (j=0; j<2; j++) {
                                        pac.update(j);
                                        mspac.update(j);
                                    }
                                    if (mspac.pixel.x == 102) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_RAMP) {
                                    pac.pixel.x -= rampX[rampFrame];
                                    pac.pixel.y += rampY[rampFrame];
                                    pac.commitPos();
                                    mspac.pixel.x += rampX[rampFrame];
                                    mspac.pixel.y += rampY[rampFrame];
                                    mspac.commitPos();
                                    rampFrame++;
                                    if (rampFrame == rampFrameLen) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_CLIMB) {
                                    if (climbFrame == 0) {
                                        // set initial climb state for mspac
                                        mspac.pixel.y -= 2;
                                        mspac.commitPos();
                                        mspac.setDir(DIR_UP);

                                        // set initial climb state for pac
                                        pac.pixel.x -= 1;
                                        pac.commitPos();
                                        pac.setDir(DIR_UP);
                                    }
                                    else {
                                        for (j=0; j<2; j++) {
                                            pac.update(j);
                                            mspac.update(j);
                                        }
                                    }
                                    climbFrame++;
                                    if (mspac.pixel.y == 91) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_MEET) {
                                    if (meetFrame == 0) {
                                        // set initial meet state for mspac
                                        mspac.pixel.y++;
                                        mspac.setDir(DIR_RIGHT);
                                        mspac.commitPos();

                                        // set initial meet state for pac
                                        pac.pixel.y--;
                                        pac.pixel.x++;
                                        pac.setDir(DIR_LEFT);
                                        pac.commitPos();
                                    }
                                    if (meetFrame > 18) {
                                        // pause player frames after a certain period
                                        pac.frames--;
                                        mspac.frames--;
                                    }
                                    if (meetFrame == 78) {
                                        exit();
                                    }
                                    meetFrame++;
                                }
                                pac.frames++;
                                mspac.frames++;

                                // update ghosts
                                if (ghostMode == GHOST_RUN) {
                                    for (j=0; j<2; j++) {
                                        inky.update(j);
                                        pinky.update(j);
                                    }

                                    // stop at middle
                                    inky.pixel.x = Math.max(120, inky.pixel.x);
                                    inky.commitPos();
                                    pinky.pixel.x = Math.min(105, pinky.pixel.x);
                                    pinky.commitPos();

                                    if (pinky.pixel.x == 105) {
                                        ghostMode++;
                                    }
                                }
                                else if (ghostMode == GHOST_BUMP) {
                                    if (inkyBounceFrame < inkyBounceFrameLen) {
                                        inky.pixel.x += inkyBounceX[inkyBounceFrame];
                                        inky.pixel.y += inkyBounceY[inkyBounceFrame];
                                    }
                                    if (pinkyBounceFrame < pinkyBounceFrameLen) {
                                        pinky.pixel.x += pinkyBounceX[pinkyBounceFrame];
                                        pinky.pixel.y += pinkyBounceY[pinkyBounceFrame];
                                    }
                                    inkyBounceFrame++;
                                    pinkyBounceFrame++;
                                }
                                inky.frames++;
                                pinky.frames++;
                            },
                            draw: function() {
                                renderer.blitMap();
                                renderer.beginMapClip();
                                renderer.renderFunc(function(ctx) {
                                    drawPlayer(ctx,pac);
                                    drawPlayer(ctx,mspac);
                                });
                                if (inkyBounceFrame < inkyBounceFrameLen) {
                                    renderer.drawGhost(inky);
                                }
                                if (pinkyBounceFrame < pinkyBounceFrameLen) {
                                    renderer.drawGhost(pinky);
                                }
                                if (playerMode == PLAYER_MEET) {
                                    renderer.renderFunc(function(ctx) {
                                        drawHeartSprite(ctx, 112, 73);
                                    });
                                }
                                renderer.endMapClip();
                            },
                        }; // returned object
                    })(), // trigger at 300
                }, // triggers
            }); // returned object
            })(); // mspacCutscene1

            var mspacmanCutscene2 = (function() {

            // create new players pac and mspac for this scene
            var pac = new Player();
            var mspac = new Player();

            // draws pac or mspac
            var drawPlayer = function(ctx,player) {
                var frame = player.getAnimFrame();
                var func;
                if (player == pac) {
                    func = gameMode == GAME_MSPACMAN ? atlas.drawPacmanSprite : atlas.drawOttoSprite;
                }
                else if (player == mspac) {
                    func = gameMode == GAME_MSPACMAN ? atlas.drawMsPacmanSprite : atlas.drawMsOttoSprite;
                }
                func(ctx, player.pixel.x, player.pixel.y, player.dirEnum, frame);
            };

            // draws all actors
            var draw = function() {
                renderer.blitMap();
                renderer.beginMapClip();
                renderer.renderFunc(function(ctx) {
                    drawPlayer(ctx,pac);
                    drawPlayer(ctx,mspac);
                });
                renderer.endMapClip();
            };

            // updates all actors
            var update = function() {
                var j;
                for (j=0; j<7; j++) {
                    pac.update(j);
                    mspac.update(j);
                }
                pac.frames++;
                mspac.frames++;
            };

            var exit = function() {
                // exit to next level
                restoreCheats();
                switchState(mspacmanCutscene2.nextState, 60);
            };

            var getChaseSteps = function() { return 3; };
            var getFleeSteps = function() { return "32"[this.frames%2]; };
            var getDartSteps = function() { return 7; };

            return newChildObject(scriptState, {

                init: function() {
                    scriptState.init.call(this);

                    // chosen by trial-and-error to match animations
                    mspac.frames = 20;
                    pac.frames = 12;

                    // step player animation every four frames
                    pac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };
                    mspac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };

                    // set steering functions
                    pac.steer = function(){};
                    mspac.steer = function(){};
                    
                    backupCheats();
                    clearCheats();
                },
                triggers: {
                    0: {
                        draw: function() {
                            renderer.blitMap();
                        },
                    },

                    160: {
                        init: function() {
                            pac.setPos(-8, 67);
                            pac.setDir(DIR_RIGHT);

                            mspac.setPos(-106, 68);
                            mspac.setDir(DIR_RIGHT);

                            pac.getNumSteps = getFleeSteps;
                            mspac.getNumSteps = getChaseSteps;
                        },
                        update: update,
                        draw: draw,
                    },
                    410: {
                        init: function() {
                            pac.setPos(329, 163);
                            pac.setDir(DIR_LEFT);

                            mspac.setPos(223+8, 164);
                            mspac.setDir(DIR_LEFT);

                            pac.getNumSteps = getChaseSteps;
                            mspac.getNumSteps = getFleeSteps;
                        },
                        update: update,
                        draw: draw,
                    },
                    670: {
                        init: function() {
                            pac.setPos(-8,142);
                            pac.setDir(DIR_RIGHT);

                            mspac.setPos(-106, 143);
                            mspac.setDir(DIR_RIGHT);

                            pac.getNumSteps = getFleeSteps;
                            mspac.getNumSteps = getChaseSteps;
                        },
                        update: update,
                        draw: draw,
                    },
                    930: {
                        init: function() {
                            pac.setPos(233+148,99);
                            pac.setDir(DIR_LEFT);

                            mspac.setPos(233,100);
                            mspac.setDir(DIR_LEFT);

                            pac.getNumSteps = getDartSteps;
                            mspac.getNumSteps = getDartSteps;
                        },
                        update: function() {
                            if (pac.pixel.x <= 17 && pac.dirEnum == DIR_LEFT) {
                                pac.setPos(-2,195);
                                pac.setDir(DIR_RIGHT);

                                mspac.setPos(-2-148,196);
                                mspac.setDir(DIR_RIGHT);
                            }
                            update();
                        },
                        draw: draw,
                    },
                    1140: {
                        init: exit,
                    },
                }, // triggers
            }); // returned object
            })(); // mspacCutscene2

            var cookieCutscene1 = newChildObject(scriptState, {

            init: function() {
                scriptState.init.call(this);

                // initialize actor positions
                pacman.setPos(232, 164);
                blinky.setPos(257, 164);

                // initialize actor directions
                blinky.setDir(DIR_LEFT);
                blinky.faceDirEnum = DIR_LEFT;
                pacman.setDir(DIR_LEFT);

                // initialize misc actor properties
                blinky.scared = false;
                blinky.mode = GHOST_OUTSIDE;

                // clear other states
                backupCheats();
                clearCheats();
                energizer.reset();

                // temporarily override actor step sizes
                pacman.getNumSteps = function() {
                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_PACMAN);
                };
                blinky.getNumSteps = function() {
                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                };

                // temporarily override steering functions
                pacman.steer = blinky.steer = function(){};
            },
            triggers: {

                // Blinky chases Pac-Man
                0: {
                    update: function() {
                        var j;
                        for (j=0; j<2; j++) {
                            pacman.update(j);
                            blinky.update(j);
                        }
                        pacman.frames++;
                        blinky.frames++;
                    },
                    draw: function() {
                        renderer.blitMap();
                        renderer.beginMapClip();
                        renderer.drawPlayer();
                        renderer.drawGhost(blinky);
                        renderer.endMapClip();
                    },
                },

                // Pac-Man chases Blinky
                260: {
                    init: function() {
                        pacman.setPos(-193, 164);
                        blinky.setPos(-8, 155);

                        // initialize actor directions
                        blinky.setDir(DIR_RIGHT);
                        blinky.faceDirEnum = DIR_RIGHT;
                        pacman.setDir(DIR_RIGHT);

                        // initialize misc actor properties
                        blinky.scared = true;

                        // temporarily override step sizes
                        pacman.getNumSteps = function() {
                            return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_PACMAN_FRIGHT);
                        };
                        blinky.getNumSteps = function() {
                            return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_GHOST_FRIGHT);
                        };
                    },
                    update: function() {
                        var j;
                        for (j=0; j<2; j++) {
                            pacman.update(j);
                            blinky.update(j);
                        }
                        pacman.frames++;
                        blinky.frames++;
                    },
                    draw: function() {
                        renderer.blitMap();
                        renderer.beginMapClip();
                        renderer.drawPlayer();
                        renderer.renderFunc(function(ctx) {
                            var y = blinky.getBounceY(blinky.pixel.x, blinky.pixel.y, DIR_RIGHT);
                            var x = blinky.pixel.x;
                            ctx.save();
                            ctx.translate(x,y);
                            var s = 16/6;
                            ctx.scale(s,s);
                            drawCookie(ctx,0,0);
                            ctx.restore();
                        });
                        renderer.endMapClip();
                    },
                },

                // end
                640: {
                    init: function() {
                        // disable custom steps
                        delete pacman.getNumSteps;
                        delete blinky.getNumSteps;

                        // disable custom steering
                        delete pacman.steer;
                        delete blinky.steer;

                        // exit to next level
                        restoreCheats();
                        switchState(cookieCutscene1.nextState, 60);
                    },
                },
            },
            });

            var cookieCutscene2 = (function() {

            /*
            NOTE:
            This is a copy-paste of mspacmanCutscene1.
            pac is replaced with a scared ghost (bouncing cookie)
            mspac is replaced with Cookie-Man
            */

            // create new players pac and mspac for this scene
            var pac = new Ghost();
            pac.scared = true;
            pac.mode = GHOST_OUTSIDE;
            var mspac = new Player();

            // draws pac or mspac
            var drawPlayer = function(ctx,player) {
                var frame = player.getAnimFrame();
                var func;
                if (player == pac) {
                    var y = player.getBounceY(player.pixel.x, player.pixel.y, player.dirEnum);
                    atlas.drawMuppetSprite(ctx, player.pixel.x, y, 0, player.dirEnum, true, false);
                }
                else if (player == mspac) {
                    drawCookiemanSprite(ctx, player.pixel.x, player.pixel.y, player.dirEnum, frame, true);
                }
            };

            // draws all actors
            var draw = function() {
                renderer.blitMap();
                renderer.beginMapClip();
                renderer.renderFunc(function(ctx) {
                    drawPlayer(ctx,pac);
                    drawPlayer(ctx,mspac);
                });
                renderer.drawGhost(inky);
                renderer.drawGhost(pinky);
                renderer.endMapClip();
            };

            // updates all actors
            var update = function() {
                var j;
                for (j=0; j<2; j++) {
                    pac.update(j);
                    mspac.update(j);
                    inky.update(j);
                    pinky.update(j);
                }
                pac.frames++;
                mspac.frames++;
                inky.frames++;
                pinky.frames++;
            };

            var exit = function() {
                // disable custom steps
                delete inky.getNumSteps;
                delete pinky.getNumSteps;

                // disable custom steering
                delete inky.steer;
                delete pinky.steer;

                // disable custom animation steps
                delete inky.getAnimFrame;
                delete pinky.getAnimFrame;

                // exit to next level
                restoreCheats();
                switchState(cookieCutscene2.nextState, 60);
            };

            return newChildObject(scriptState, {

                init: function() {
                    scriptState.init.call(this);

                    // chosen by trial-and-error to match animations
                    mspac.frames = 14;
                    pac.frames = 12;

                    // initialize actor states
                    pac.setPos(-10, 99);
                    pac.setDir(DIR_RIGHT);
                    mspac.setPos(232, 180);
                    mspac.setDir(DIR_LEFT);
                    
                    // initial ghost states
                    inky.frames = 0;
                    inky.mode = GHOST_OUTSIDE;
                    inky.scared = false;
                    inky.setPos(pac.pixel.x-42, 99);
                    inky.setDir(DIR_RIGHT);
                    inky.faceDirEnum = DIR_RIGHT;
                    pinky.frames = 3;
                    pinky.mode = GHOST_OUTSIDE;
                    pinky.scared = false;
                    pinky.setPos(mspac.pixel.x+49, 180);
                    pinky.setDir(DIR_LEFT);
                    pinky.faceDirEnum = DIR_LEFT;

                    // clear other states
                    backupCheats();
                    clearCheats();
                    energizer.reset();

                    // step player animation every four frames
                    pac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };
                    mspac.getStepFrame = function() { return Math.floor(this.frames/4)%4; };

                    // step ghost animation every six frames
                    inky.getAnimFrame = function() { return Math.floor(this.frames/8)%2; };
                    pinky.getAnimFrame = function() { return Math.floor(this.frames/8)%2; };

                    // set actor step sizes
                    pac.getNumSteps = function() { return 1; };
                    mspac.getNumSteps = function() { return 1; };
                    inky.getNumSteps = function() { return 1; };
                    pinky.getNumSteps = function() { return 1; };

                    // set steering functions
                    pac.steer = function(){};
                    mspac.steer = function(){};
                    inky.steer = function(){};
                    pinky.steer = function(){};
                },
                triggers: {

                    // Inky chases Pac, Pinky chases Mspac
                    0: {
                        update: function() {
                            update();
                            if (inky.pixel.x == 105) {
                                // speed up the ghosts
                                inky.getNumSteps = function() {
                                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                                };
                                pinky.getNumSteps = function() {
                                    return Actor.prototype.getStepSizeFromTable.call(this, 5, STEP_ELROY2);
                                };
                            }
                        },
                        draw: draw,
                    },

                    // MsPac and Pac converge with ghosts chasing
                    300: (function(){

                        // bounce animation when ghosts bump heads
                        var inkyBounceX =  [ 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
                        var inkyBounceY =  [-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1];
                        var pinkyBounceX = [ 0, 0, 0, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0, 0];
                        var pinkyBounceY = [ 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0,-1, 0,-1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0];
                        var inkyBounceFrame = 0;
                        var pinkyBounceFrame = 0;
                        var inkyBounceFrameLen = inkyBounceX.length;
                        var pinkyBounceFrameLen = pinkyBounceX.length;

                        // ramp animation for players
                        var rampX = [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1];
                        var rampY = [0, 0,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0];
                        var rampFrame = 0;
                        var rampFrameLen = rampX.length;

                        // climbing
                        var climbFrame = 0;

                        // meeting
                        var meetFrame = 0;

                        var ghostMode;
                        var GHOST_RUN = 0;
                        var GHOST_BUMP = 1;

                        var playerMode;
                        var PLAYER_RUN = 0;
                        var PLAYER_RAMP = 1;
                        var PLAYER_CLIMB = 2;
                        var PLAYER_MEET = 3;
                            
                        return {
                            init: function() {
                                // reset frames
                                inkyBounceFrame = pinkyBounceFrame = rampFrame = climbFrame = meetFrame = 0;

                                // set modes
                                ghostMode = GHOST_RUN;
                                playerMode = PLAYER_RUN;

                                // set initial positions and directions
                                mspac.setPos(-8,143);
                                mspac.setDir(DIR_RIGHT);

                                pinky.setPos(-81,143);
                                pinky.faceDirEnum = DIR_RIGHT;
                                pinky.setDir(DIR_RIGHT);

                                pac.setPos(223+8+3,142);
                                pac.setDir(DIR_LEFT);

                                inky.setPos(302,143);
                                inky.faceDirEnum = DIR_LEFT;
                                inky.setDir(DIR_LEFT);

                                // set ghost speed
                                inky.getNumSteps = pinky.getNumSteps = function() {
                                    return "11211212"[this.frames%8];
                                };
                            },
                            update: function() {
                                var j;

                                // update players
                                if (playerMode == PLAYER_RUN) {
                                    for (j=0; j<2; j++) {
                                        pac.update(j);
                                        mspac.update(j);
                                    }
                                    if (mspac.pixel.x == 102) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_RAMP) {
                                    pac.pixel.x -= rampX[rampFrame];
                                    pac.pixel.y += rampY[rampFrame];
                                    pac.commitPos();
                                    mspac.pixel.x += rampX[rampFrame];
                                    mspac.pixel.y += rampY[rampFrame];
                                    mspac.commitPos();
                                    rampFrame++;
                                    if (rampFrame == rampFrameLen) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_CLIMB) {
                                    if (climbFrame == 0) {
                                        // set initial climb state for mspac
                                        mspac.pixel.y -= 2;
                                        mspac.commitPos();
                                        mspac.setDir(DIR_UP);
                                    }
                                    else {
                                        for (j=0; j<2; j++) {
                                            mspac.update(j);
                                        }
                                    }
                                    climbFrame++;
                                    if (mspac.pixel.y == 91) {
                                        playerMode++;
                                    }
                                }
                                else if (playerMode == PLAYER_MEET) {
                                    if (meetFrame == 0) {
                                        // set initial meet state for mspac
                                        mspac.pixel.y++;
                                        mspac.setDir(DIR_RIGHT);
                                        mspac.commitPos();
                                    }
                                    if (meetFrame > 18) {
                                        // pause player frames after a certain period
                                        mspac.frames--;
                                    }
                                    if (meetFrame == 78) {
                                        exit();
                                    }
                                    meetFrame++;
                                }
                                pac.frames++;
                                mspac.frames++;

                                // update ghosts
                                if (ghostMode == GHOST_RUN) {
                                    for (j=0; j<2; j++) {
                                        inky.update(j);
                                        pinky.update(j);
                                    }

                                    // stop at middle
                                    inky.pixel.x = Math.max(120, inky.pixel.x);
                                    inky.commitPos();
                                    pinky.pixel.x = Math.min(105, pinky.pixel.x);
                                    pinky.commitPos();

                                    if (pinky.pixel.x == 105) {
                                        ghostMode++;
                                    }
                                }
                                else if (ghostMode == GHOST_BUMP) {
                                    if (inkyBounceFrame < inkyBounceFrameLen) {
                                        inky.pixel.x += inkyBounceX[inkyBounceFrame];
                                        inky.pixel.y += inkyBounceY[inkyBounceFrame];
                                    }
                                    if (pinkyBounceFrame < pinkyBounceFrameLen) {
                                        pinky.pixel.x += pinkyBounceX[pinkyBounceFrame];
                                        pinky.pixel.y += pinkyBounceY[pinkyBounceFrame];
                                    }
                                    inkyBounceFrame++;
                                    pinkyBounceFrame++;
                                }
                                inky.frames++;
                                pinky.frames++;
                            },
                            draw: function() {
                                renderer.blitMap();
                                renderer.beginMapClip();
                                renderer.renderFunc(function(ctx) {
                                    if (playerMode <= PLAYER_RAMP) {
                                        drawPlayer(ctx,pac);
                                    }
                                    drawPlayer(ctx,mspac);
                                });
                                if (inkyBounceFrame < inkyBounceFrameLen) {
                                    renderer.drawGhost(inky);
                                }
                                if (pinkyBounceFrame < pinkyBounceFrameLen) {
                                    renderer.drawGhost(pinky);
                                }
                                if (playerMode == PLAYER_MEET) {
                                    renderer.renderFunc(function(ctx) {
                                        drawHeartSprite(ctx, 112, 73);
                                    });
                                }
                                renderer.endMapClip();
                            },
                        }; // returned object
                    })(), // trigger at 300
                }, // triggers
            }); // returned object
            })(); // mspacCutscene1

            var cutscenes = [
            [pacmanCutscene1], // GAME_PACMAN
            [mspacmanCutscene1, mspacmanCutscene2], // GAME_MSPACMAN
            [cookieCutscene1, cookieCutscene2], // GAME_COOKIE
            [mspacmanCutscene1, mspacmanCutscene2], // GAME_OTTO
            ];

            var isInCutScene = function() {
            var scenes = cutscenes[gameMode];
            var i,len = scenes.length;
            for (i=0; i<len; i++) {
                if (state == scenes[i]) {
                    return true;
                }
            }
            return false;
            };

            // TODO: no cutscene after board 17 (last one after completing board 17)
            var triggerCutsceneAtEndLevel = function() {
            if (gameMode == GAME_PACMAN) {
                if (level == 2) {
                    playCutScene(pacmanCutscene1, readyNewState);
                    return true;
                }
                /*
                else if (level == 5) {
                    playCutScene(pacmanCutscene2, readyNewState);
                    return true;
                }
                else if (level >= 9 && (level-9)%4 == 0) {
                    playCutScene(pacmanCutscene3, readyNewState);
                    return true;
                }
                */
            }
            else if (gameMode == GAME_MSPACMAN || gameMode == GAME_OTTO) {
                if (level == 2) {
                    playCutScene(mspacmanCutscene1, readyNewState);
                    return true;
                }
                else if (level == 5) {
                    playCutScene(mspacmanCutscene2, readyNewState);
                    return true;
                }
            }
            else if (gameMode == GAME_COOKIE) {
                if (level == 2) {
                    playCutScene(cookieCutscene1, readyNewState);
                    return true;
                }
                else if (level == 5) {
                    playCutScene(cookieCutscene2, readyNewState);
                    return true;
                }
            }

            // no cutscene triggered
            return false;
            };

            //@line 1 "src/maps.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Maps

            // Definitions of playable maps

            // current map
            var map;

            // actor starting states

            blinky.startDirEnum = DIR_LEFT;
            blinky.startPixel = {
            x: 14*tileSize-1,
            y: 14*tileSize+midTile.y
            };
            blinky.cornerTile = {
            x: 28-1-2,
            y: 0
            };
            blinky.startMode = GHOST_OUTSIDE;
            blinky.arriveHomeMode = GHOST_LEAVING_HOME;

            pinky.startDirEnum = DIR_DOWN;
            pinky.startPixel = {
            x: 14*tileSize-1,
            y: 17*tileSize+midTile.y,
            };
            pinky.cornerTile = {
            x: 2,
            y: 0
            };
            pinky.startMode = GHOST_PACING_HOME;
            pinky.arriveHomeMode = GHOST_PACING_HOME;

            inky.startDirEnum = DIR_UP;
            inky.startPixel = {
            x: 12*tileSize-1,
            y: 17*tileSize + midTile.y,
            };
            inky.cornerTile = {
            x: 28-1,
            y: 36 - 2,
            };
            inky.startMode = GHOST_PACING_HOME;
            inky.arriveHomeMode = GHOST_PACING_HOME;

            clyde.startDirEnum = DIR_UP;
            clyde.startPixel = {
            x: 16*tileSize-1,
            y: 17*tileSize + midTile.y,
            };
            clyde.cornerTile = {
            x: 0,
            y: 36-2,
            };
            clyde.startMode = GHOST_PACING_HOME;
            clyde.arriveHomeMode = GHOST_PACING_HOME;

            pacman.startDirEnum = DIR_LEFT;
            pacman.startPixel = {
            x: 14*tileSize-1,
            y: 26*tileSize + midTile.y,
            };

            // Learning Map
            var mapLearn = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "__||||||||||||||||||||||||__" +
            "__|                      |__" +
            "__| ||||| |||||||| ||||| |__" +
            "__| ||||| |||||||| ||||| |__" +
            "__| ||    ||    ||    || |__" +
            "__| || || || || || || || |__" +
            "||| || || || || || || || |||" +
            "       ||    ||    ||       " +
            "||| ||||| |||||||| ||||| |||" +
            "__| ||||| |||||||| ||||| |__" +
            "__|    ||          ||    |__" +
            "__| || || |||||||| || || |__" +
            "__| || || |||||||| || || |__" +
            "__| ||    ||    ||    || |__" +
            "__| || || || || || || || |__" +
            "||| || || || || || || || |||" +
            "       ||    ||    ||       " +
            "||| |||||||| || |||||||| |||" +
            "__| |||||||| || |||||||| |__" +
            "__|                      |__" +
            "__||||||||||||||||||||||||__" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "____________________________"));

            mapLearn.name = "Pac-Man";
            mapLearn.wallStrokeColor = "#47b897"; // from Pac-Man Plus
            mapLearn.wallFillColor = "#000";
            mapLearn.pelletColor = "#ffb8ae";
            mapLearn.shouldDrawMapOnly = true;

            // Original Pac-Man map
            var mapPacman = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "||||||||||||||||||||||||||||" +
            "|............||............|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|o||||.|||||.||.|||||.||||o|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|..........................|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|......||....||....||......|" +
            "||||||.||||| || |||||.||||||" +
            "_____|.||||| || |||||.|_____" +
            "_____|.||          ||.|_____" +
            "_____|.|| |||--||| ||.|_____" +
            "||||||.|| |______| ||.||||||" +
            "      .   |______|   .      " +
            "||||||.|| |______| ||.||||||" +
            "_____|.|| |||||||| ||.|_____" +
            "_____|.||          ||.|_____" +
            "_____|.|| |||||||| ||.|_____" +
            "||||||.|| |||||||| ||.||||||" +
            "|............||............|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|o..||.......  .......||..o|" +
            "|||.||.||.||||||||.||.||.|||" +
            "|||.||.||.||||||||.||.||.|||" +
            "|......||....||....||......|" +
            "|.||||||||||.||.||||||||||.|" +
            "|.||||||||||.||.||||||||||.|" +
            "|..........................|" +
            "||||||||||||||||||||||||||||" +
            "____________________________" +
            "____________________________"));

            mapPacman.name = "Pac-Man";
            //mapPacman.wallStrokeColor = "#47b897"; // from Pac-Man Plus
            mapPacman.wallStrokeColor = "#2121ff"; // from original
            mapPacman.wallFillColor = "#000";
            mapPacman.pelletColor = "#ffb8ae";
            mapPacman.constrainGhostTurns = function(tile,openTiles) {
            // prevent ghost from turning up at these tiles
            if ((tile.x == 12 || tile.x == 15) && (tile.y == 14 || tile.y == 26)) {
                openTiles[DIR_UP] = false;
            }
            };

            // Levels are grouped into "acts."
            // In Ms. Pac-Man (and Cookie-Man) a map only changes after the end of an act.
            // The levels within an act progress in difficulty.
            // But the beginning of an act is generally easier than the end of the previous act to stave frustration.
            // Completing an act results in a cutscene.
            var getLevelAct = function(level) {
            // Act 1: (levels 1,2)
            // Act 2: (levels 3,4,5)
            // Act 3: (levels 6,7,8,9)
            // Act 4: (levels 10,11,12,13)
            // Act 5: (levels 14,15,16,17)
            // ...
            if (level <= 2) {
                return 1;
            }
            else if (level <= 5) {
                return 2;
            }
            else {
                return 3 + Math.floor((level - 6)/4);
            }
            };

            var getActColor = function(act) {
            if (gameMode == GAME_PACMAN) {
                return {
                    wallFillColor: mapPacman.wallFillColor,
                    wallStrokeColor: mapPacman.wallStrokeColor,
                    pelletColor: mapPacman.pelletColor,
                };
            }
            else if (gameMode == GAME_MSPACMAN || gameMode == GAME_OTTO) {
                return getMsPacActColor(act);
            }
            else if (gameMode == GAME_COOKIE) {
                return getCookieActColor(act);
            }
            };

            var getActRange = function(act) {
            if (act == 1) {
                return [1,2];
            }
            else if (act == 2) {
                return [3,5];
            }
            else {
                var start = act*4-6;
                return [start, start+3];
            }
            };

            var getCookieActColor = function(act) {
            var colors = [
                "#359c9c", "#80d8fc", // turqoise
                "#c2b853", "#e6f1e7", // yellow
                "#86669c", "#f2c1db", // purple
                "#ed0a04", "#e8b4cd", // red
                "#2067c1", "#63e0b6", // blue
                "#c55994", "#fd61c3", // pink
                "#12bc76", "#b4e671", // green
                "#5036d9", "#618dd4", // violet
                "#939473", "#fdfdf4", // grey
            ];
            var i = ((act-1)*2) % colors.length;
            return {
                wallFillColor: colors[i],
                wallStrokeColor: colors[i+1],
                pelletColor: "#ffb8ae",
            };
            };

            var setNextCookieMap = function() {
            // cycle the colors
            var i;
            var act = getLevelAct(level);
            if (!map || level == 1 || act != getLevelAct(level-1)) {
                map = mapgen();
                var colors = getCookieActColor(act);
                map.wallFillColor = colors.wallFillColor;
                map.wallStrokeColor = colors.wallStrokeColor;
                map.pelletColor = colors.pelletColor;
            }
            };

            // Ms. Pac-Man map 1

            var getMsPacActColor = function(act) {
            act -= 1;
            var mapIndex = (act <= 1) ? act : (act%2)+2;
            var maps = [mapMsPacman1, mapMsPacman2, mapMsPacman3, mapMsPacman4];
            var map = maps[mapIndex];
            if (act >= 4) {
                return [
                    {
                        wallFillColor: "#ffb8ff",
                        wallStrokeColor: "#FFFF00",
                        pelletColor: "#00ffff",
                    },
                    {
                        wallFillColor: "#FFB8AE",
                        wallStrokeColor: "#FF0000",
                        pelletColor: "#dedeff",
                    },
                    {
                        wallFillColor: "#de9751",
                        wallStrokeColor: "#dedeff",
                        pelletColor: "#ff0000",
                    },
                    {
                        wallFillColor: "#2121ff",
                        wallStrokeColor: "#ffb851",
                        pelletColor: "#dedeff",
                    },
                ][act%4];
            }
            else {
                return {
                    wallFillColor: map.wallFillColor,
                    wallStrokeColor: map.wallStrokeColor,
                    pelletColor: map.pelletColor,
                };
            }
            };

            var setNextMsPacMap = function() {
            var maps = [mapMsPacman1, mapMsPacman2, mapMsPacman3, mapMsPacman4];

            // The third and fourth maps repeat indefinitely after the second map.
            // (i.e. act1=map1, act2=map2, act3=map3, act4=map4, act5=map3, act6=map4, ...)
            var act = getLevelAct(level)-1;
            var mapIndex = (act <= 1) ? act : (act%2)+2;
            map = maps[mapIndex];
            if (act >= 4) {
                var colors = getMsPacActColor(act+1);
                map.wallFillColor = colors.wallFillColor;
                map.wallStrokeColor = colors.wallStrokeColor;
                map.pelletColor = colors.pelletColor;
            }
            };

            var mapMsPacman1 = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "||||||||||||||||||||||||||||" +
            "|......||..........||......|" +
            "|o||||.||.||||||||.||.||||o|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|..........................|" +
            "|||.||.|||||.||.|||||.||.|||" +
            "__|.||.|||||.||.|||||.||.|__" +
            "|||.||.|||||.||.|||||.||.|||" +
            "   .||.......||.......||.   " +
            "|||.||||| |||||||| |||||.|||" +
            "__|.||||| |||||||| |||||.|__" +
            "__|.                    .|__" +
            "__|.||||| |||--||| |||||.|__" +
            "__|.||||| |______| |||||.|__" +
            "__|.||    |______|    ||.|__" +
            "__|.|| || |______| || ||.|__" +
            "|||.|| || |||||||| || ||.|||" +
            "   .   ||          ||   .   " +
            "|||.|||||||| || ||||||||.|||" +
            "__|.|||||||| || ||||||||.|__" +
            "__|.......   ||   .......|__" +
            "__|.|||||.||||||||.|||||.|__" +
            "|||.|||||.||||||||.|||||.|||" +
            "|............  ............|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|.||||.||....||....||.||||.|" +
            "|o||||.||.||||||||.||.||||o|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|..........................|" +
            "||||||||||||||||||||||||||||" +
            "____________________________" +
            "____________________________"));

            mapMsPacman1.name = "Ms. Pac-Man 1";
            mapMsPacman1.wallFillColor = "#FFB8AE";
            mapMsPacman1.wallStrokeColor = "#FF0000";
            mapMsPacman1.pelletColor = "#dedeff";
            mapMsPacman1.fruitPaths = {
                    "entrances": [
                        { "start": { "y": 164, "x": 228 }, "path": "<<<<vvv<<<<<<<<<^^^" }, 
                        { "start": { "y": 164, "x": -4 }, "path": ">>>>vvvvvv>>>>>>>>>>>>>>>^^^<<<^^^" }, 
                        { "start": { "y": 92, "x": -4 }, "path": ">>>>^^^^>>>vvvv>>>vvv>>>>>>>>>vvvvvv<<<" }, 
                        { "start": { "y": 92, "x": 228 }, "path": "<<<<vvvvvvvvv<<<^^^<<<vvv<<<" }
                    ], 
                    "exits": [
                        { "path": "<vvv>>>>>>>>>^^^>>>>" }, 
                        { "path": "<<<<vvv<<<<<<<<<^^^<<<<" }, 
                        { "path": "<<<<<<<^^^^^^<<<<<<^^^<<<<" }, 
                        { "path": "<vvv>>>>>>>>>^^^^^^^^^^^^>>>>" }
                    ]
                };

            // Ms. Pac-Man map 2

            var mapMsPacman2 = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "||||||||||||||||||||||||||||" +
            "       ||..........||       " +
            "|||||| ||.||||||||.|| ||||||" +
            "|||||| ||.||||||||.|| ||||||" +
            "|o...........||...........o|" +
            "|.|||||||.||.||.||.|||||||.|" +
            "|.|||||||.||.||.||.|||||||.|" +
            "|.||......||.||.||......||.|" +
            "|.||.|||| ||....|| ||||.||.|" +
            "|.||.|||| |||||||| ||||.||.|" +
            "|......|| |||||||| ||......|" +
            "||||||.||          ||.||||||" +
            "||||||.|| |||--||| ||.||||||" +
            "|......|| |______| ||......|" +
            "|.||||.|| |______| ||.||||.|" +
            "|.||||.   |______|   .||||.|" +
            "|...||.|| |||||||| ||.||...|" +
            "|||.||.||          ||.||.|||" +
            "__|.||.|||| |||| ||||.||.|__" +
            "__|.||.|||| |||| ||||.||.|__" +
            "__|.........||||.........|__" +
            "__|.|||||||.||||.|||||||.|__" +
            "|||.|||||||.||||.|||||||.|||" +
            "   ....||...    ...||....   " +
            "|||.||.||.||||||||.||.||.|||" +
            "|||.||.||.||||||||.||.||.|||" +
            "|o..||.......||.......||..o|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|..........................|" +
            "||||||||||||||||||||||||||||" +
            "____________________________" +
            "____________________________"));

            mapMsPacman2.name = "Ms. Pac-Man 2";
            mapMsPacman2.wallFillColor = "#47b8ff";
            mapMsPacman2.wallStrokeColor = "#dedeff";
            mapMsPacman2.pelletColor = "#ffff00";
            mapMsPacman2.fruitPaths = {
                    "entrances": [
                        { "start": { "y": 212, "x": 228 }, "path": "<<<<^^^<<<<<<<<^^^<" }, 
                        { "start": { "y": 212, "x": -4 }, "path": ">>>>^^^>>>>>>>>vvv>>>>>^^^^^^<" }, 
                        { "start": { "y": 36, "x": -4 }, "path": ">>>>>>>vvv>>>vvvvvvv>>>>>>>>>vvvvvv<<<" }, 
                        { "start": { "y": 36, "x": 228 }, "path": "<<<<<<<vvv<<<vvvvvvvvvvvvv<<<" }
                    ], 
                    "exits": [
                        { "path": "vvv>>>>>>>>vvv>>>>" }, 
                        { "path": "vvvvvv<<<<<^^^<<<<<<<<vvv<<<<" }, 
                        { "path": "<<<<<<<^^^^^^^^^^^^^<<<^^^<<<<<<<" }, 
                        { "path": "vvv>>>>>^^^^^^^^^^>>>>>^^^^^^<<<<<^^^>>>>>>>" }
                    ]
                };

            // Ms. Pac-Man map 3

            var mapMsPacman3 = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "||||||||||||||||||||||||||||" +
            "|.........||....||.........|" +
            "|.|||||||.||.||.||.|||||||.|" +
            "|o|||||||.||.||.||.|||||||o|" +
            "|.||.........||.........||.|" +
            "|.||.||.||||.||.||||.||.||.|" +
            "|....||.||||.||.||||.||....|" +
            "||||.||.||||.||.||||.||.||||" +
            "||||.||..............||.||||" +
            " ....|||| |||||||| ||||.... " +
            "|.|| |||| |||||||| |||| ||.|" +
            "|.||                    ||.|" +
            "|.|||| || |||--||| || ||||.|" +
            "|.|||| || |______| || ||||.|" +
            "|.     || |______| ||     .|" +
            "|.|| |||| |______| |||| ||.|" +
            "|.|| |||| |||||||| |||| ||.|" +
            "|.||                    ||.|" +
            "|.|||| ||||| || ||||| ||||.|" +
            "|.|||| ||||| || ||||| ||||.|" +
            "|......||....||....||......|" +
            "|||.||.||.||||||||.||.||.|||" +
            "|||.||.||.||||||||.||.||.|||" +
            "|o..||.......  .......||..o|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|.||||.|||||.||.|||||.||||.|" +
            "|......||....||....||......|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|......||..........||......|" +
            "||||||||||||||||||||||||||||" +
            "____________________________" +
            "____________________________"));

            mapMsPacman3.name = "Ms. Pac-Man 3";
            mapMsPacman3.wallFillColor = "#de9751";
            mapMsPacman3.wallStrokeColor = "#dedeff";
            mapMsPacman3.pelletColor = "#ff0000";
            mapMsPacman3.fruitPaths = {
                    "entrances": [
                        { "start": { "y": 100, "x": 228 }, "path": "<<<<<vv<<<<<vvvvvv<<<" }, 
                        { "start": { "y": 100, "x": -4 }, "path": ">>>>>vv>>>>>>>>>>>>>>vvvvvv<<<" }, 
                        { "start": { "y": 100, "x": -4 }, "path": ">>>>>vv>>>>>>>>>>>>>>vvvvvv<<<" }, 
                        { "start": { "y": 100, "x": 228 }, "path": "<<vvvvv<<<vvv<<<<<<<<" }
                    ], 
                    "exits": [
                        { "path": "<vvv>>>vvv>>>^^^>>>>>^^^^^^^^^^^>>" }, 
                        { "path": "<<<<vvv<<<vvv<<<^^^<<<<<^^^^^^^^^^^<<" }, 
                        { "path": "<<<<vvv<<<vvv<<<^^^<<<<<^^^^^^^^^^^<<" }, 
                        { "path": "<vvv>>>vvv>>>^^^^^^<<<^^^^^^>>>>>^^>>>>>" }
                    ]
                };
            mapMsPacman3.constrainGhostTurns = function(tile,openTiles,dirEnum) {
            // prevent ghost from turning down when exiting tunnels
            if (tile.y == 12) {
                if ((tile.x == 1 && dirEnum == DIR_RIGHT) || (tile.x == 26 && dirEnum == DIR_LEFT)) {
                    openTiles[DIR_DOWN] = false;
                }
            }
            };

            // Ms. Pac-Man map 4

            var mapMsPacman4 = new Map(28, 36, (
            "____________________________" +
            "____________________________" +
            "____________________________" +
            "||||||||||||||||||||||||||||" +
            "|..........................|" +
            "|.||.||||.||||||||.||||.||.|" +
            "|o||.||||.||||||||.||||.||o|" +
            "|.||.||||.||....||.||||.||.|" +
            "|.||......||.||.||......||.|" +
            "|.||||.||.||.||.||.||.||||.|" +
            "|.||||.||.||.||.||.||.||||.|" +
            "|......||....||....||......|" +
            "|||.|||||||| || ||||||||.|||" +
            "__|.|||||||| || ||||||||.|__" +
            "__|....||          ||....|__" +
            "||| ||.|| |||--||| ||.|| |||" +
            "    ||.|| |______| ||.||    " +
            "||||||.   |______|   .||||||" +
            "||||||.|| |______| ||.||||||" +
            "    ||.|| |||||||| ||.||    " +
            "||| ||.||          ||.|| |||" +
            "__|....||||| || |||||....|__" +
            "__|.||.||||| || |||||.||.|__" +
            "__|.||....   ||   ....||.|__" +
            "__|.|||||.|| || ||.|||||.|__" +
            "|||.|||||.|| || ||.|||||.|||" +
            "|.........||    ||.........|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|.||||.||.||||||||.||.||||.|" +
            "|.||...||..........||...||.|" +
            "|o||.|||||||.||.|||||||.||o|" +
            "|.||.|||||||.||.|||||||.||.|" +
            "|............||............|" +
            "||||||||||||||||||||||||||||" +
            "____________________________" +
            "____________________________"));

            mapMsPacman4.name = "Ms. Pac-Man 4";
            mapMsPacman4.wallFillColor = "#2121ff";
            mapMsPacman4.wallStrokeColor = "#ffb851";
            mapMsPacman4.pelletColor = "#dedeff";
            mapMsPacman4.fruitPaths = {
                    "entrances": [
                        { "start": { "y": 156, "x": 228 }, "path": "<<<<vv<<<vv<<<<<<^^^" }, 
                        { "start": { "y": 156, "x": -4 }, "path": ">>>>vv>>>vv>>>>>>vvv>>>^^^^^^" }, 
                        { "start": { "y": 132, "x": -4 }, "path": ">>>>^^^^^>>>^^^>>>vvv>>>vvv>>>>>>vvvvvv<<<" }, 
                        { "start": { "y": 132, "x": 228 }, "path": "<<<<^^<<<vvv<<<vvv<<<" }
                    ], 
                    "exits": [
                        { "path": "<vvv>>>>>>^^>>>^^>>>>" }, 
                        { "path": "<<<<vvv<<<<<<^^<<<^^<<<<" }, 
                        { "path": "<<<<<<<^^^<<<^^^<<<vv<<<<" }, 
                        { "path": "<vvv>>>>>>^^^^^^^^^>>>vv>>>>" }
                    ]
                };
            //@line 1 "src/vcr.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // VCR
            // This coordinates the recording, rewinding, and replaying of the game state.
            // Inspired by Braid.

            var VCR_NONE = -1;
            var VCR_RECORD = 0;
            var VCR_REWIND = 1;
            var VCR_FORWARD = 2;
            var VCR_PAUSE = 3;

            var vcr = (function() {

            var mode;

            // controls whether to increment the frame before recording.
            var initialized;

            // current time
            var time;

            // tracking speed
            var speedIndex;
            var speeds = [-8,-4,-2,-1,0,1,2,4,8];
            var speedCount = speeds.length;
            var speedColors = [
                "rgba(255,255,0,0.25)",
                "rgba(255,255,0,0.20)",
                "rgba(255,255,0,0.15)",
                "rgba(255,255,0,0.10)",
                "rgba(0,0,0,0)",
                "rgba(0,0,255,0.10)",
                "rgba(0,0,255,0.15)",
                "rgba(0,0,255,0.20)",
                "rgba(0,0,255,0.25)",
            ];

            // This is the number of "footprint" frames to display along the seek direction around a player
            // to create the rewind/forward blurring.  
            // This is also inversely used to determine the number of footprint frames to display OPPOSITE the seek direction
            // around a player.
            //
            // For example: 
            //   nextFrames = speedPrints[speedIndex];
            //   prevFrames = speedPrints[speedCount-1-speedIndex];
            var speedPrints = [
                18,// -8x
                13,// -4x
                8, // -2x
                3, // -1x
                3, //  0x
                10,//  1x
                15,//  2x
                20,//  4x
                25,//  8x
            ];

            // The distance between each footprint used in the rewind/forward blurring.
            // Step size grows when seeking speed increases to show emphasize time dilation.
            var speedPrintStep = [
                6,  // -8x
                5,  // -4x
                4,  // -2x
                3,  // -1x
                3,  //  0x
                3,  //  1x
                4,  //  2x
                5,  //  4x
                6,  //  8x
            ];

            // current frame associated with current time
            // (frame == time % maxFrames)
            var frame;

            // maximum number of frames to record
            var maxFrames = 15*60;

            // rolling bounds of the recorded frames
            var startFrame; // can't rewind past this
            var stopFrame; // can't replay past this

            // reset the VCR
            var reset = function() {
                time = 0;
                frame = 0;
                startFrame = 0;
                stopFrame = 0;
                states = {};
                startRecording();
            };

            // load the state of the current time
            var load = function() {
                var i;
                for (i=0; i<5; i++) {
                    actors[i].load(frame);
                }
                elroyTimer.load(frame);
                energizer.load(frame);
                fruit.load(frame);
                ghostCommander.load(frame);
                ghostReleaser.load(frame);
                map.load(frame,time);
                loadGame(frame);
                if (state == deadState) {
                    deadState.load(frame);
                }
                else if (state == finishState) {
                    finishState.load(frame);
                }
            };

            // save the state of the current time
            var save = function() {
                var i;
                for (i=0; i<5; i++) {
                    actors[i].save(frame);
                }
                elroyTimer.save(frame);
                energizer.save(frame);
                fruit.save(frame);
                ghostCommander.save(frame);
                ghostReleaser.save(frame);
                map.save(frame);
                saveGame(frame);
                if (state == deadState) {
                    deadState.save(frame);
                }
                else if (state == finishState) {
                    finishState.save(frame);
                }
            };

            // erase any states after the current time
            // (only necessary for saves that do interpolation)
            var eraseFuture = function() {
                map.eraseFuture(time);
                stopFrame = frame;
            };

            // increment or decrement the time
            var addTime = function(dt) {
                time += dt;
                frame = (frame+dt)%maxFrames;
                if (frame < 0) {
                    frame += maxFrames;
                }
            };

            // measures the modular distance if increasing from x0 to x1 on our circular frame buffer.
            var getForwardDist = function(x0,x1) {
                return (x0 <= x1) ? x1-x0 : x1+maxFrames-x0;
            };

            // caps the time increment or decrement to prevent going over our rolling bounds.
            var capSeekTime = function(dt) {
                if (!initialized || dt == 0) {
                    return 0;
                }
                var maxForward = getForwardDist(frame,stopFrame);
                var maxReverse = getForwardDist(startFrame,frame);
                return (dt > 0) ? Math.min(maxForward,dt) : Math.max(-maxReverse,dt);
            };

            var init = function() {
                mode = VCR_NONE;
            };

            // seek to the state at the given relative time difference.
            var seek = function(dt) {
                if (dt == undefined) {
                    dt = speeds[speedIndex];
                }
                if (initialized) {
                    addTime(capSeekTime(dt));
                    load();
                }
            };

            // record a new state.
            var record = function() {
                if (initialized) {
                    addTime(1);
                    if (frame == startFrame) {
                        startFrame = (startFrame+1)%maxFrames;
                    }
                    stopFrame = frame;
                }
                else {
                    initialized = true;
                }
                save();
            };

            var startRecording = function() {
                mode = VCR_RECORD;
                initialized = false;
                eraseFuture();
                seekUpBtn.disable();
                seekDownBtn.disable();
                seekToggleBtn.setIcon(function(ctx,x,y,frame) {
                    drawRewindSymbol(ctx,x,y,"#FFF");
                });
                seekToggleBtn.setText();
            };

            var refreshSeekDisplay = function() {
                seekToggleBtn.setText(speeds[speedIndex]+"x");
            };

            var startSeeking = function() {
                speedIndex = 3;
                updateMode();
                seekUpBtn.enable();
                seekDownBtn.enable();
                seekToggleBtn.setIcon(undefined);
                refreshSeekDisplay();
            };

            var nextSpeed = function(di) {
                if (speeds[speedIndex+di] != undefined) {
                    speedIndex = speedIndex+di;
                }
                updateMode();
                refreshSeekDisplay();
            };

            var x,y,w,h;
            var pad = 5;
            x = mapWidth+1;
            h = 25;
            w = 25;
            y = mapHeight/2-h/2;
            var seekUpBtn = new Button(x,y-h-pad,w,h,
                function() {
                    nextSpeed(1);
                });
            seekUpBtn.setIcon(function(ctx,x,y,frame) {
                drawUpSymbol(ctx,x,y,"#FFF");
            });
            var seekDownBtn = new Button(x,y+h+pad,w,h,
                function() {
                    nextSpeed(-1);
                });
            seekDownBtn.setIcon(function(ctx,x,y,frame) {
                drawDownSymbol(ctx,x,y,"#FFF");
            });
            var seekToggleBtn = new ToggleButton(x,y,w,h,
                function() {
                    return mode != VCR_RECORD;
                },
                function(on) {
                    on ? startSeeking() : startRecording();
                });
            seekToggleBtn.setIcon(function(ctx,x,y,frame) {
                drawRewindSymbol(ctx,x,y,"#FFF");
            });
            seekToggleBtn.setFont((tileSize-1)+"px ArcadeR", "#FFF");
            var slowBtn = new ToggleButton(-w-pad-1,y,w,h,
                function() {
                    return executive.getFramePeriod() == 1000/15;
                },
                function(on) {
                    executive.setUpdatesPerSecond(on ? 15 : 60);
                });
            slowBtn.setIcon(function(ctx,x,y) {
                atlas.drawSnail(ctx,x,y,1);
            });

            var onFramePeriodChange = function() {
                if (slowBtn.isOn()) {
                    slowBtn.setIcon(function(ctx,x,y) {
                        atlas.drawSnail(ctx,x,y,0);
                    });
                }
                else {
                    slowBtn.setIcon(function(ctx,x,y) {
                        atlas.drawSnail(ctx,x,y,1);
                    });
                }
            };

            var onHudEnable = function() {
                if (practiceMode) {
                    if (mode == VCR_NONE || mode == VCR_RECORD) {
                        seekUpBtn.disable();
                        seekDownBtn.disable();
                    }
                    else {
                        seekUpBtn.enable();
                        seekDownBtn.enable();
                    }
                    seekToggleBtn.enable();
                    slowBtn.enable();
                }
            };

            var onHudDisable = function() {
                if (practiceMode) {
                    seekUpBtn.disable();
                    seekDownBtn.disable();
                    seekToggleBtn.disable();
                    slowBtn.disable();
                }
            };

            var isValidState = function() {
                return (
                    !inGameMenu.isOpen() && (
                    state == playState ||
                    state == finishState ||
                    state == deadState));
            };

            var draw = function(ctx) {
                if (practiceMode) {
                    if (isValidState() && vcr.getMode() != VCR_RECORD) {
                        // change the hue to reflect speed
                        renderer.setOverlayColor(speedColors[speedIndex]);
                    }

                    if (seekUpBtn.isEnabled) {
                        seekUpBtn.draw(ctx);
                    }
                    if (seekDownBtn.isEnabled) {
                        seekDownBtn.draw(ctx);
                    }
                    if (seekToggleBtn.isEnabled) {
                        seekToggleBtn.draw(ctx);
                    }
                    if (slowBtn.isEnabled) {
                        slowBtn.draw(ctx);
                    }
                }
            };

            var updateMode = function() {
                var speed = speeds[speedIndex];
                if (speed == 0) {
                    mode = VCR_PAUSE;
                }
                else if (speed < 0) {
                    mode = VCR_REWIND;
                }
                else if (speed > 0) {
                    mode = VCR_FORWARD;
                }
            };

            return {
                init: init,
                reset: reset,
                seek: seek,
                record: record,
                draw: draw,
                onFramePeriodChange: onFramePeriodChange,
                onHudEnable: onHudEnable,
                onHudDisable: onHudDisable,
                eraseFuture: eraseFuture,
                startRecording: startRecording,
                startSeeking: startSeeking,
                nextSpeed: nextSpeed,
                isSeeking: function() {
                    return (
                        mode == VCR_REWIND ||
                        mode == VCR_FORWARD ||
                        mode == VCR_PAUSE);
                },
                getTime: function() { return time; },
                getFrame: function() { return frame; },
                getMode: function() { return mode; },

                drawHistory: function(ctx,callback) {
                    if (!this.isSeeking()) {
                        return;
                    }

                    // determine start frame
                    var maxReverse = getForwardDist(startFrame,frame);
                    var start = (frame - Math.min(maxReverse,speedPrints[speedIndex])) % maxFrames;
                    if (start < 0) {
                        start += maxFrames;
                    }

                    // determine end frame
                    var maxForward = getForwardDist(frame,stopFrame);
                    var end = (frame + Math.min(maxForward,speedPrints[speedCount-1-speedIndex])) % maxFrames;

                    var backupAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = 0.2;
                    
                    var t = start;
                    var step = speedPrintStep[speedIndex];
                    if (start > end) {
                        for (; t<maxFrames; t+=step) {
                            callback(t);
                        }
                        t %= maxFrames;
                    }
                    for (; t<end; t+=step) {
                        callback(t);
                    }

                    ctx.globalAlpha = backupAlpha;
                },
            };
            })();
            //@line 1 "src/main.js"
            //////////////////////////////////////////////////////////////////////////////////////
            // Entry Point

           
            loadHighScores();
            initRenderer();
            atlas.create();
            initSwipe();
            var anchor = window.location.hash.substring(1);
            if (anchor == "learn") {
                switchState(learnState);
            }
            else if (anchor == "cheat_pac" || anchor == "cheat_mspac") {
                gameMode = (anchor == "cheat_pac") ? GAME_PACMAN : GAME_MSPACMAN;
                practiceMode = true;
                switchState(newGameState);
                for (var i=0; i<4; i++) {
                    ghosts[i].isDrawTarget = true;
                    ghosts[i].isDrawPath = true;
                }
            }
            else {
                switchState(homeState);
            }
            executive.init();

          

            /*         function StartGame() { 
            practiceMode = false;
            turboMode = false;
            newGameState.setStartLevel(1);
            exitTo(newGameState, 60);
            };

            StartGame() */


        })

        document.querySelector('#minesweeper').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'
            
            let boardWidth = 0;
            let boardHeight = 0;
            let bombAmount = 0;
            let minesweepMenu = document.querySelector(".minesweepMenu");
            
            boardWidth = 16;
            boardHeight = 16;
            bombAmount = 40;
            

            setTimeout(() => {
                createBoard();
            }, 10)


            const minesweepBoard = document.querySelector(".minesweepBoard");
            // let width = 10;
            let flags = 0;
            let squares = [];
            let isGameOver = false;

            let gameOverMinesweep = (square) =>{
                isGameOver = true;

                //Show ALL the bombs
                squares.forEach(square => {
                    if(square.classList.contains('bomb')){
                        square.innerHTML = '\u{1F4A3}';
                        square.classList.remove('bomb');
                        square.classList.add('gameOverMinesweep');
                    }
                });
            };

            let checkForWin = () => {
                let matches = 0;
                for(let i = 0; i< squares.length; i++){
                    if(squares[i].classList.contains('flag') && squares[i].classList.contains('bomb')){
                        matches++;
                    }
                    if(matches === bombAmount){
                        console.log('YOU WIN!');
                        isGameOver = true;
                    }
                }
            }

            let addFlag = (square) =>{
                if(isGameOver){
                    return;
                }
                if(!square.classList.contains('checked') && (flags < bombAmount)){
                    if(!square.classList.contains('flag')){
                        square.classList.add('flag');
                        square.innerHTML = '';
                        flags++;
                        checkForWin();
                    }
                    else{
                        square.classList.remove('flag');
                        square.innerHTML = '';
                        flags--;
                    }
                }
            };

            //check neighboring squares once square is clicked
            let checkSquare = (square, currentId) =>{
                const isLeftEdge = (currentId % boardWidth === 0);
                const isRightEdge = (currentId % boardWidth === boardWidth - 1);

                setTimeout(() =>{
                    if(currentId > 0 && !isLeftEdge){
                        const newId = squares[parseInt(currentId) - 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId < squares.length && !isRightEdge){
                        const newId = squares[parseInt(currentId) + 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId > (boardWidth - 1)){
                        const newId = squares[parseInt(currentId) - boardWidth].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId < (squares.length - boardWidth)){
                        const newId = squares[parseInt(currentId) + boardWidth].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId > (boardWidth - 1) && !isLeftEdge){
                        const newId = squares[parseInt(currentId) - boardWidth - 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId > (boardWidth - 1) && !isRightEdge){
                        const newId = squares[parseInt(currentId) - boardWidth + 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId < (squares.length - boardWidth) && !isLeftEdge){
                        const newId = squares[parseInt(currentId) + boardWidth - 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    if(currentId < (squares.length - boardWidth) && !isRightEdge){
                        const newId = squares[parseInt(currentId) + boardWidth + 1].id;
                        const newSquare = document.getElementById(newId);
                        click(newSquare);
                    }
                    
                }, 10);
            };

            let click = (square) => {
                let currentId = square.id;
                if(isGameOver){
                    return;
                }
                if(square.classList.contains('checked') || square.classList.contains('flag'))
                {
                    return;
                }
                if(square.classList.contains('bomb')){
                    gameOverMinesweep(square);
                }
                else{
                    let total = square.getAttribute('data');
                    if(total != 0){
                        square.classList.add('checked');
                        square.innerHTML = total;
                        square.classList.add(`bombCountIs${total}`);
                        return;
                    }
                    checkSquare(square, currentId);
                }
                square.classList.add('checked');
            };

            //create Board
            let createBoard = () => {
                
                minesweepBoard.innerHTML = "";
                minesweepBoard.style.width = 26 * boardWidth + "px";
                minesweepBoard.style.height = 26 * boardHeight + "px";
                minesweepBoard.style.margin = 5 + "px";
                minesweepBoard.style.display = "flex";
                minesweepMenu.style.display = "none";

                //get shuffled game array with random bombs
                
                const bombArray = Array(bombAmount).fill('bomb');
                const emptyArray = Array(boardWidth * boardHeight - bombAmount).fill('valid');
                const gameArray = emptyArray.concat(bombArray);

                const shuffledArray = gameArray.sort(() => Math.random() - 0.5);
                for (let i = 0; i < boardWidth * boardHeight; i++) {
                    const square = document.createElement("div");
                    square.setAttribute("id", i);
                    square.classList.add(shuffledArray[i]);
                    minesweepBoard.appendChild(square);
                    squares.push(square);

                    //normal click
                    square.addEventListener('click', () =>{
                        click(square);
                    });

                    //add flag with right click
                    square.oncontextmenu = (e) =>{
                        e.preventDefault();
                        addFlag(square);
                    }
                }

                //add numbers
                for (let i = 0; i < squares.length; i++) {
                    let total = 0;
                    const isLeftEdge = (i % boardWidth === 0);
                    const isRightEdge = (i % boardWidth === boardWidth - 1);

                    if(squares[i].classList.contains('valid')){
                        // left square check
                        if(i > 0 && !isLeftEdge && squares[i - 1].classList.contains('bomb')){
                            total++;
                        }

                        //right square check
                        if(i < (squares.length - 1) && !isRightEdge && squares[i + 1].classList.contains('bomb')){
                            total++;
                        }

                        //upper square check
                        if(i > (boardWidth - 1) && squares[i - boardWidth].classList.contains('bomb')){
                            total++;
                        }

                        //lower square check
                        if(i < (squares.length - boardWidth) && squares[i + boardWidth].classList.contains('bomb')){
                            total++;
                        }

                        //upper left square check
                        if(i > (boardWidth - 1) && !isLeftEdge && squares[i - 1 - boardWidth].classList.contains('bomb')){
                            total++
                        }

                        //upper right square check
                        if(i > (boardWidth - 1) && !isRightEdge && squares[i + 1 - boardWidth].classList.contains('bomb')){
                            total++;
                        }

                        //lower left square check
                        if(i < (squares.length - boardWidth) && !isLeftEdge && squares[i - 1 + boardWidth].classList.contains('bomb')){
                            total++;
                        }

                        //lower right square check
                        if(i < (squares.length - boardWidth) && !isRightEdge && squares[i + 1 + boardWidth].classList.contains('bomb')){
                            total++;
                        }
                        squares[i].setAttribute('data', total);
                    }
                }
            };

        })

        document.querySelector('#bubbletrouble').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'
            document.querySelector('#canvasBubbleTrouble').style.display = 'block'
            // consts
            const K_LEFT = 37;
            const K_UP = 38;
            const K_RIGHT = 39;
            const K_DOWN = 40;

            // colours
            const C_BACKG = '#222';
            var ballColours = [
                '#F25F5C',
                '#FFE066',
                '#70C1B3',
                '#DD9892',
            ]

            // engine vars
            var t = 0; // gametime
            var speed = .35; // gamespeed
            var fps = 120;// max is 1000
            var f = 1000.0/fps*speed;
            var freeze = false;


            // control vars
            var downKeys = {}; // key: Key code, value: down/up

            // ball/physics vars
            var balls = [];// list of ball objects
            var g = 0.001; // gravity
            var splitp = 0.5; // proportion of parent's radius children balls' radiuses should be

            // player vars
            var playerx = 0; // x coord middle of player
            var playerw = 0; // total width player
            var playerh = 0;

            // shot vars
            var shotx = -1;
            var shoth = -1;

            // stage vars
            var stageDiff = 5; // difficulty heuristic for stage
            var sizeFactor = 935; // factor for increasing difficulty with size (standard size)
            var minBalls = 1;
            var maxBalls = 4;

            // game vars
            var lives = 4;
            var stageNo = 1;

            var c = document.getElementById('canvasBubbleTrouble'),
            cx = c.getContext('2d');

            //#region game
            function newStage(){
                clearAll();

                balls = []; // clear balls
                playerx = c.width/2; // center player

                //reset shot
                shoth = -1;
                shotx = -1;

                //update min no of balls if need be (req radius for difficulty too big)
                if((100*stageDiff)/(15*minBalls)*(c.width/sizeFactor)>320){
                    minBalls+=1;
                    maxBalls+=1;
                }

                var n = Math.floor(Math.random()*(maxBalls-minBalls+1))+minBalls; // no balls: random int min-max
                // work out radiuses of balls so as to achieve req difficulty heuristic
                var r = (100*stageDiff)/(15*n);
                r*=(c.width/sizeFactor); // factor in screen width

                var dd = c.width/(n+1); // delta d: space between each ball
                //spawn balls
                for (var i=0;i<n;i++){
                    balls.push(newBall((i+1)*dd,c.height/2,0.2,0,r,getRandomBallColour()));
                }
            }
            //#endregion

            //#region updating
            function updateBalls(){

                if(balls.length<=0){
                    // won stage
                    stageDiff+=5;
                    stageNo+=1;
                    newStage();
                    return;
                }

                var et = 0.9; //not 100% efficient energy transfer
                for(var i=0; i<balls.length; i++){
                    var ball=balls[i];

                    // player collision
                    if(ballHits(ball.x,ball.y,ball.r,playerx-playerw/2,c.height,playerw,playerh)){
                        // died
                        lives-=1;
                        if(lives==0){
                            // out of lives (reset)
                            lives = 4;
                            stageDiff = 5;
                            stageNo = 1;
                        }

                        ball.colour = '#fff';
                        drawBall(ball);

                        freeze=true;
                        setTimeout(function(){
                            freeze=false;
                            newStage();
                        },1000);
                    }

                    var minvel = Math.min(-Math.log(ball.r)/5,-0.5);
                    //wall collisions
                    if(ball.y+ball.vy*f+ball.r>c.height){
                        ball.y=c.height-ball.r;
                        ball.vy=Math.min(ball.vy*-1*et,minvel);
                    }
                    else if(ball.y-ball.r<0){
                        ball.y=ball.r+5;
                        ball.vy=Math.min(ball.vy*-1*et,-1*minvel);
                    }
                    if(ball.x+ball.vx*f+ball.r>c.width){
                        ball.x=c.width-ball.r;
                        ball.vx*=-1;
                    }else if(ball.x-ball.r<0){
                        ball.x=ball.r;
                        ball.vx*=-1;
                    }

                    //updt vels
                    ball.x=ball.x+ball.vx*f;
                    ball.y=ball.y+ball.vy*f;

                    ball.vy=ball.vy+g*f;
                }
            }

            function updatePlayer(){
                // controls
                if(downKeys[K_RIGHT]){
                    playerx+=f/3;
                }
                if(downKeys[K_LEFT]){
                    playerx-=f/3;
                }
                if(downKeys[K_UP]){
                    //shoot
                    if(shoth<=-1 && shotx<=-1){
                        shotx = playerx;
                        shoth = playerh;
                    }
                }

                // bounds
                if(playerx+playerw/2>c.width){
                    playerx=c.width-playerw/2;
                }
                if(playerx-playerw/2<0){
                    playerx=playerw/2;
                }

            }

            function updateShots(){
                if(shoth<=-1 && shotx<=-1){
                    return;
                }

                // grow
                if(shoth<c.height){
                    shoth+=f;
                }else{
                    shoth = -1;
                    shotx = -1;
                    return; // maybe impl sticky here
                }

                // collision work
                for (var i=balls.length-1;i>=0;i--){
                    const ball = balls[i];
                    if(shotHits(ball.x,ball.y,ball.r,shotx,shoth)){
                        // reset shot
                        shoth = -1;
                        shotx = -1;


                        if(ball.r>16*(c.width/sizeFactor)){
                            //(factors in screen width) ^
                            ball.vy*=splitp;
                            ball.vy-=0.4;
                            ball.r*=splitp;

                            // clone
                            var child = JSON.parse(JSON.stringify(ball));
                            child.vx*=-1;
                            
                            balls.push(child);
                        }else{
                            balls.splice(i,1);
                        }
                    }
                }

            }
            //#endregion

            //#region calculation
            function shotHits(cx,cy,r,sx,sh) {
                h=c.height-sh;
                if(sx-cx<=r && cx-sx<=r){
                    if(h<cy){
                        // above centre = easy case
                        return true;
                    }else{
                        return Math.pow(cx-sx,2)+Math.pow(cy-h,2)<=Math.pow(r,2);
                    }
                }
                return false;
            }

            function clamp(value, min, max){
                //limits value to range min..max
                return Math.max(Math.min(value,max),min);
            }

            function ballHits(cx,cy,r,x,y,w,h){
                var closestX = clamp(cx,x,x+w);
                var closestY = clamp(cy,y-h,y);

                var distanceX = cx-closestX;
                var distanceY = cy-closestY;

                return (distanceX*distanceX)+(distanceY*distanceY)<(r*r);
            }
            //#endregion

            //#region drawing
            function drawBall(ball){
                cx.fillStyle = ball.colour;
                cx.beginPath();
                cx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
                cx.closePath();
                cx.fill();
            }

            function drawBalls(){
                for(var i=0; i<balls.length; i++){
                    drawBall(balls[i]);
                }
            }

            function drawPlayer(){
                cx.strokeStyle = C_BACKG;

                cx.beginPath();
                cx.lineWidth = 3;

                var body = c.height; // y coord base of body
                var bodh = 20; // body height
                var bodw = 5; // body width

                // head
                var headw = 5;
                var headh = 2;

                cx.moveTo(playerx+headw,body-bodh-headh/2);
                cx.fillStyle = '#C9ADA7';
                cx.beginPath();
                cx.ellipse(playerx,body-bodh-headh/2,headw,headh,0,0,7);
                cx.closePath();
                cx.fill();
                cx.stroke();

                // body
                cx.fillStyle = '#9A8C98';
                cx.beginPath();
                cx.moveTo(playerx-bodw,body);
                cx.ellipse(playerx,body-bodh/2,bodw,bodh/2,0,Math.PI,2*Math.PI);
                cx.lineTo(playerx+bodw,body);
                cx.closePath();
                cx.fill();
                cx.stroke();

                // hat
                var hatw = bodw*1.3; // half hat width
                var hatt = 10; // hat thickness
                var hath = 8; // hat height
                var haty = body-bodh-2*headh/2; // y coord base of hat

                // hat base line
                cx.moveTo(playerx+hatw,haty);
                cx.fillStyle = '#4A4E69';
                cx.beginPath();
                cx.lineTo(playerx-hatw,haty);
                
                // hat above
                var div = 1.5; // determines width of triangle tip
                cx.lineTo(playerx-hatw,haty-hatt) // up
                cx.lineTo(playerx-hatw/div,haty-hatt); // right
                cx.lineTo(playerx,haty-hatt-hath); // tip
                cx.lineTo(playerx+hatw/div,haty-hatt); //down
                cx.lineTo(playerx+hatw,haty-hatt); //right
                cx.lineTo(playerx+hatw,haty); // down
                cx.closePath();
                cx.fill();
                cx.stroke();

                playerh = bodh + 2*headh + hath + 3;
                playerw = 2*hatw + 4;
            }

            function drawShots(){
                cx.strokeStyle = '#9FA09F';
                cx.lineWidth = 1;
                cx.beginPath();
                cx.moveTo(shotx,c.height);
                cx.lineTo(shotx,c.height-shoth);
                cx.stroke();
            }

            function drawOverlay(){
                cx.font = '20px Arial';
                cx.fillStyle = '#eee';

                // lives
                var livesString = '';
                for(var i=0; i<lives; i++){
                    livesString+='\u2764';
                }
                cx.fillText(livesString,10,40);

                // stage
                cx.font = '40px Arial';
                var stageString = '\u2691 '+stageNo.toString();
                cx.fillText(stageString,c.width/2,40);
            }
            //#endregion

            //#region clearing
            function clearAll(){
                //background
                cx.fillStyle = C_BACKG;
                cx.fillRect(0, 0, c.width, c.height);
            }

            function clearBall(ball){
                cx.fillStyle = C_BACKG;
                cx.fillRect(ball.x-ball.r-3,ball.y-ball.r-3,(ball.r+3)*2,(ball.r+3)*2);
            }

            function clearBalls(){
                for(var i=0; i< balls.length; i++){
                    clearBall(balls[i]);
                }
            }

            function clearPlayer(){
                cx.fillStyle = C_BACKG;
                cx.fillRect(playerx-playerw/2,c.height-playerh,
                            playerw,playerh);
            }

            function clearShots(){
                cx.fillStyle = C_BACKG;
                cx.fillRect(shotx-3,0,
                            6,c.height);
            }

            function clearOverlay(){
                cx.fillStyle = C_BACKG;
                cx.fillRect(0,0,
                            c.width,43);
            }
            //#endregion

            function newBall(x,y,vx=0,vy=0,r=70,colour='#fff'){
                return {
                x:x,
                y:y,
                r:r,
                vx:vx,
                vy:vy,
                colour:colour,
                m:20,//mass
                }
            }

            function getRandomBallColour(){
                return ballColours[Math.floor(Math.random()*ballColours.length)];
            }



            (function() {        
                function resizeCanvas() {
            /*         c.width = window.innerWidth;
                    c.height = window.innerHeight; */

                    clearAll();
                }
                window.addEventListener('resize', resizeCanvas, false);
                resizeCanvas();
                
                init();
                var timer=setInterval(function(){
                    if(freeze){
                        // nothing ...
                    }else{
                        clear();
                        update();
                        draw();
                    }
                    t+=f;
                },f);
                
                function init(){
                    // key listening
                    window.addEventListener("keydown",function(e){
                        downKeys[e.keyCode]=true;
                    }, false);
                    window.addEventListener("keyup",function(e){
                        downKeys[e.keyCode]=false;
                    }, false);

                    clearAll();

                    newStage();
                }
                
                function update(){
                    updatePlayer();
                    updateShots();
                    updateBalls();
                }
                
                function draw(){
                    drawBalls();
                    drawShots();
                    drawPlayer();
                    drawOverlay();
                }
                
                function clear(){
                    clearOverlay();
                    clearShots();
                    clearPlayer();
                    clearBalls();
                }
            })();
        })
   
        document.querySelector('#arenaOnslaught').addEventListener('click', () => {  
            document.querySelector('#startScreen').style.display = 'none'


            /**
		 * horde - A quick game
		 * @var object
		 */
		var horde = {};

		horde.canvasFallbackContent = "<div class=\"fallback\"><p>Your browser does not appear to support <a href=\"http://en.wikipedia.org/wiki/HTML5\">HTML5</a>.</p><p>Please try one of the following, more standards compliant browsers: <a href=\"http://www.google.com/chrome\">Chrome</a>, <a href=\"http://www.apple.com/safari/\">Safari</a>, <a href=\"http://www.mozilla.com/firefox/\">Firefox</a> or <a href=\"http://www.opera.com/\">Opera</a>.</p></div>";

		// Bind a function to a particular context
		var bind = function (context, fn) {
			if (typeof fn == "string") {
				fn = context[fn];
			}
			return function () {
				fn.apply(context, arguments);
			};
		};

		// requestAnimationFrame shim
		if (typeof requestAnimationFrame == "undefined") {
			var requestAnimationFrame = (
				window.mozRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				function (callback) {
					setTimeout(function () {
						callback(Date.now());
					}, 17); // ~60 FPS
				}
			);
		}

		/**
		 * Context corrected window.setInterval() wrapper
		 * @param {number} when Milliseconds between intervals
		 * @param {object} fn Function to call each interval
		 * @param {object} context Value of "this" when calling function
		 * @return {number} Interval ID
		 */
		horde.setInterval = function horde_setInterval (when, fn, context) {
			var f = function horde_setInterval_anon () {
				fn.call(context);
			};
			return window.setInterval(f, when);
		};

		/**
		 * Context corrected window.setTimeout() wrapper
		 * @param {number} when Milliseconds before calling fn
		 * @param {object} fn Function to call
		 * @param {object} context Value of "this" when calling fn
		 * @return {number} Timeout ID
		 */
		horde.setTimeout = function horde_setTimeout (when, fn, context) {
			var f = function horde_setTimeout_anon () {
				fn.call(context);
			};
			return window.setTimeout(f, when);
		};

		/**
		 * Context corrected .addEventListener() wrapper
		 * @param {string} type Type of event
		 * @param {object} fn Function to call
		 * @param {object} target Object on which to listen
		 * @param {object} context Value of "this" when calling function
		 * @return {void}
		 */
		horde.on = function horde_on (type, fn, target, context) {
			target.addEventListener(type, function horde_on_anon (e) {
				fn.call(context, e);
			}, false);
		};

		/**
		 * Stops an event
		 * @param {object} e Event
		 * @return {void}
		 */
		horde.stopEvent = function horde_stopEvent (e) {
			e.cancelBubble = true;
			e.stopPropagation();
			e.preventDefault();
		};

		/**
		 * Returns the current UNIX time
		 * @return {number} Millisecodns since epoch
		 */
		horde.now = function horde_now () {
			return Date.now();
		};

		/**
		 * Creates a canvas elements and adds it to the document
		 * @param {string} id Element ID attribute
		 * @param {number} width Width of the canvas in pixels
		 * @param {number} height Height of the canvas in pixels
		 * @param {boolean} hidden Whether or not this canvas is visible
		 * @return {object} <canvas> element
		 */
		horde.makeCanvas = function horde_makeCanvas (id, width, height, hidden) {
			var canvas = document.createElement("canvas");
			canvas.id = id;
			canvas.width = Number(width) || 0;
			canvas.height = Number(height) || 0;
			if (hidden !== true) {
				canvas.innerHTML = horde.canvasFallbackContent;
				var stage = document.getElementById("stage");
				stage.appendChild(canvas);
			}
			return canvas;
		};

		/**
		 * Returns the x,y offset of an element on the page
		 * @param {DOMElement} node DOM Element
		 * @return {object} x,y offset
		 */
		horde.getOffset = function horde_getOffset (node) {
			var offset = {
				x: node.offsetLeft, y: node.offsetTop
			};
			while (true) {
				node = node.parentNode;
				if (node === document.body) {
					break;
				}
				offset.x += node.offsetLeft;
				offset.y += node.offsetTop;
			}

			scrollTop = horde.getScrollTop();
			offset.x -= scrollTop.x;
			offset.y -= scrollTop.y;

			return offset;
		};


		/**
		 * Returns object of the number of pixels the window is scrolled
		 * in both the x and y directions with top left as 0,0
		 * @return {object} Object containing "x" : scrollLeft and "y" : scrollTop
		 */
		horde.getScrollTop = function horde_getScrollTop() {
			if (typeof pageYOffset !== 'undefined') {
				//most browsers
				return { x: pageXOffset, y: pageYOffset };
			}
			else {
				var B = document.body; //IE 'quirks'
				var D = document.documentElement; //IE with doctype
				D = (D.clientHeight) ? D : B;
				return { x: D.scrollLeft, y: D.scrollTop };
			}
		}

		/**
		 * Returns a random number between min and max
		 * @param {number} min Minimum number
		 * @param {number} max Maximum number
		 * @return {number} Random number between min and max
		 */
		horde.randomRange = function horde_randomRange (min, max) {
			return (Math.round(Math.random() * (max - min)) + min);
		};

		horde.clamp = function horde_clamp (value, min, max) {
			return Math.min(Math.max(value, min), max);
		};

		/**
		 * Returns a randomly generated direction
		 * @return {horde.Vector2} Direction vector
		 */
		horde.randomDirection = function horde_randomDirection () {
			var d = new horde.Vector2(
				horde.randomRange(-10, 10),
				horde.randomRange(-10, 10)
			);
			d.normalize();
			return d;
		};

		/**
		 * Creates an object of a given type
		 * @param {string} type Object Type (maps to object_types.js)
		 * @param {boolean} supressInit Supress the init for this object?
		 * @return {object} New game object
		 */
		horde.makeObject = function horde_makeObject (type, supressInit) {
			var obj = new horde.Object();
			obj.type = type;
			for (var x in horde.objectTypes[type]) {
				obj[x] = horde.objectTypes[type][x];
			}
			if (supressInit !== true) {
				obj.init();
			}
			return obj;
		};

		/**
		 * Directions enumeration
		 */
		horde.directions = {
			UP: 0,
			UP_RIGHT: 1,
			RIGHT: 2,
			DOWN_RIGHT: 3,
			DOWN: 4,
			DOWN_LEFT: 5,
			LEFT: 6,
			UP_LEFT: 7,
			toVector: function (d) {
				if (d < 0) d += 8; // Fix for -1 should be UP_LEFT.
				if (d > 7) d -= 8; // Fix for -1 should be UP_LEFT.
				switch (d) {
					case horde.directions.UP:
						return new horde.Vector2(0, -1);
						break;
					case horde.directions.UP_RIGHT:
						return new horde.Vector2(1, -1);
						break;
					case horde.directions.RIGHT:
						return new horde.Vector2(1, 0);
						break;
					case horde.directions.DOWN_RIGHT:
						return new horde.Vector2(1, 1);
						break;
					case horde.directions.DOWN:
						return new horde.Vector2(0, 1);
						break;
					case horde.directions.DOWN_LEFT:
						return new horde.Vector2(-1, 1);
						break;
					case horde.directions.LEFT:
						return new horde.Vector2(-1, 0);
						break;
					case horde.directions.UP_LEFT:
						return new horde.Vector2(-1, -1);
						break;
				}
			},
			fromVector: function (v) {
				if (v.x > -0.25 && v.x < 0.25 && v.y < 0) {
					return horde.directions.UP;
				}
				if (v.x > -0.25 && v.x < 0.25 && v.y > 0) {
					return horde.directions.DOWN;
				}
				if (v.x > 0 && v.y > -0.25 && v.y < 0.25) {
					return horde.directions.RIGHT;
				}
				if (v.x < 0 && v.y > -0.25 && v.y < 0.25) {
					return horde.directions.LEFT;
				}
				if (v.x > 0 && v.y < 0) {
					return horde.directions.UP_RIGHT;
				}
				if (v.x > 0 && v.y > 0) {
					return horde.directions.DOWN_RIGHT;
				}
				if (v.x < 0 && v.y > 0) {
					return horde.directions.DOWN_LEFT;
				}
				if (v.x < 0 && v.y < 0) {
					return horde.directions.UP_LEFT;
				}
			}
		};

		horde.x = function (s, p) {
			var k = 0;
			var r = "";
			for (var y = 0; y < p.length; ++y) {
				k += p.charCodeAt(y);
			}
			for (var x = 0; x < s.length; ++x) {
				r += String.fromCharCode(k ^ s.charCodeAt(x));
			}
			return r;
		};

		(function define_logger () {

			var log = [];

			horde.log = function horde_log (info) {
				log.push(info);
				console.log(info);
			};

		}());

		(function define_horde_Timer () {

			/**
			 * General purpose timer
			 * @constructor
			 */
			horde.Timer = function horde_Timer () {
				this.elapsed_ms = 0;
				this.ttl = 0;
			};

			var Timer = horde.Timer;
			var proto = Timer.prototype;

			/**
			 * Returns the current time
			 * @return {number} Milliseconds since epoch
			 */
			Timer.now = function horde_Timer_now () {
				return Date.now();
			};

			/**
			 * Starts the timer
			 * @param {number} ttl Time to live
			 * @return {void}
			 */
			proto.start = function horde_Timer_proto_start (ttl) {
				if (ttl) {
					this.ttl = Number(ttl);
				}
				this.elapsed_ms = 0;
			};

			/**
			 * Updates the elapsed time of this timer
			 * @param {number} elapsed Elapsed milliseconds
			 * @return {void}
			 */
			proto.update = function horde_Timer_proto_update (elapsed) {
				this.elapsed_ms += elapsed;
			};

			/**
			 * Resets the timer's start time to now (same as calling start())
			 * @return {void}
			 */
			proto.reset = function horde_Timer_proto_reset () {
				this.start();
			};

			/**
			 * Returns the elapsed time since start (in milliseconds)
			 * @return {number} Elapsed time since start (in milliseconds)
			 */
			proto.elapsed = function horde_Timer_proto_elapsed () {
				return this.elapsed_ms;
			};

			/**
			 * Returns if this timer is expired or not based on it's TTL
			 * @return {boolean} True if elapsed > ttl otherwise false
			 */
			proto.expired = function horde_Timer_proto_expired () {
				if (this.ttl > 0) {
					return this.elapsed_ms > this.ttl;
				}
				return false;
			};

			}());

		(function define_horde_sound () {

		horde.sound = {};

		var api = "html5";
		var format = ".mp3";
		var muted = false;
		var sounds = {};
		var disabled = false;

		horde.sound.init = function horde_sound_init (callback) {

			if (typeof(Audio) == "undefined") {
				disabled = true;
				return;
			} else {
				disabled = false;
			}

			switch (api) {
				case "ios":
					callback();
					break;
				case "sm2":
					soundManager.useFastPolling = true;
					soundManager.useHighPerformance = true;
					soundManager.autoLoad = true;
					soundManager.multiShot = true;
					soundManager.volume = 100;
					soundManager.onload = callback;
					soundManager.useHTML5Audio = false;

					soundManager.onerror = (function (init) {
						return function () {
							api = "html5";
							init(callback);
						};
					}(arguments.callee));
					break;
				case "html5":
					var audio = document.createElement("audio");

					if (audio.canPlayType) {
						//audio.canPlayType('audio/ogg; codecs="vorbis"');
						if (!audio.canPlayType("audio/mpeg;")) {
							//format = ".ogg";
							api = null;
						}
					}

					callback();
					break;
			}
		};

		horde.sound.create = function horde_sound_create (id, url, loops, volume) {

			if (disabled) return;

			loops = Boolean(loops);
			url += format;
			url += '?raw=true';

			if (volume === undefined) {
				volume = 100;
			}

			switch (api) {
				case "sm2":
					var params = {
						id: id,
						url: url,
						volume: volume
					};
					if (loops) {
						params.onfinish = function () {
							this.play();
						};
					}
					var sound = soundManager.createSound(params);
					sound.load();
					break;
				case "html5":
					var audio = new Audio();
					audio.preload = "auto";
					audio.src = url;
					if (loops) {
						audio.addEventListener("ended", function () {
							this.currentTime = 0;
							this.play();
						}, false);
					} else {
						audio.addEventListener("ended", function () {
							this.pause();
							this.currentTime = 0;
						}, false);
					}
					audio.load();
					audio.volume = volume / 100;
					sounds[id] = audio;
					break;
			}
		};

		horde.sound.isPlaying = function (id) {
			if (disabled) return;
			switch (api) {
				case "sm2":
					var sound = soundManager.getSoundById(id);
					if (sound) {
						return (sound.playState === 1);
					}
					return false;
				case "html5":
					return (sounds[id].currentTime > 0);
			}
		};

		horde.sound.play = function horde_sound_play (id) {
			if (disabled) return;
			if (muted) {
				return false;
			}
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://play/" + id);
					location.href = ("jsbridge://" + id);
					break;
				case "sm2":
					soundManager.play(id);
					break;
				case "html5":
					try {
						sounds[id].pause();
						sounds[id].currentTime = 0;
						sounds[id].play();
					} catch (e) {}
					break;
			}
		};

		horde.sound.stop = function horde_sound_stop (id) {
			if (disabled) return;
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://stop/" + id);
					break;
				case "sm2":
					soundManager.stop(id);
					break;
				case "html5":
					sounds[id].pause();
					sounds[id].currentTime = 0;
					break;
			}
		};

		horde.sound.stopAll = function horde_sound_stopAll () {
			if (disabled) return;
			switch (api) {
				case "ios":
					//location.href = ("jsbridge://stopAll");
					break;
				case "sm2":
					soundManager.stopAll();
					break;
				case "html5":
					try {
						for (var id in sounds) {
							sounds[id].pause();
							sounds[id].currentTime = 0;
						}
					} catch (e) {
						console.log("[ERROR horde.sound.stopAll]", e);
					}
					break;
			}
		};

		horde.sound.pauseAll = function horde_sound_pauseAll () {
			if (disabled) return;
			switch (api) {
				case "sm2":
					soundManager.pauseAll();
					break;
				case "html5":
					for (var id in sounds) {
						if (sounds[id].currentTime > 0) {
							sounds[id].pause();
						}
					}
					break;
			}
		};

		horde.sound.resumeAll = function horde_sound_resumeAll () {
			if (disabled) return;
			switch (api) {
				case "sm2":
					soundManager.resumeAll();
					break;
				case "html5":
					for (var id in sounds) {
						if (sounds[id].currentTime > 0) {
							sounds[id].play();
						}
					}
					break;
			}
		};

		horde.sound.toggleMuted = function horde_sound_toggleMuted () {
			horde.sound.setMuted(!horde.sound.isMuted());
		};

		horde.sound.isMuted = function horde_sound_isMuted () {
			return muted;
		};

		horde.sound.setMuted = function horde_sound_setMuted (muteSound) {
			if (muted === muteSound) {
				return;
			}
			muted = muteSound;
			if (muted) {
				horde.sound.pauseAll();
			} else {
				horde.sound.resumeAll();
			}
		};

		}());

		(function define_horde_Size () {

			/**
			 * Object for dealing with sizes
			 * @param {number} width Width
			 * @param {number} height Height
			 * @constructor
			 */
			horde.Size = function horde_Size (width, height) {
				this.width = Number(width) || 0;
				this.height = Number(height) || 0;
			};
				
			}());

		(function define_horde_Vector2 () {

		/**
		 * Object for dealing with 2D vectors
		 * @param {number} x X value
		 * @param {number} y Y value
		 * @constructor
		 */
		horde.Vector2 = function horde_Vector2 (x, y) {
			this.x = Number(x) || 0;
			this.y = Number(y) || 0;
		};

		var Vector2 = horde.Vector2;
		var proto = Vector2.prototype;

		/**
		 * Creates a vector from a horde.Size object
		 * @param {horde.Size} size Size
		 * @return {horde.Vector2} Vector representation of a size
		 */
		Vector2.fromSize = function horde_Vector2_fromSize (size) {
			return new horde.Vector2(size.width, size.height);
		};

		/**
		 * Creates a vector from a heading (and optionaly a magnitude)
		 * @param {number} heading Heading in radians
		 * @param {number} mag Magnitude (Optional; Defaults to 1)
		 * @return {horde.Vector2}
		 */
		Vector2.fromHeading = function horde_Vector2_fromHeading (heading, mag) {
			mag = Number(mag) || 1;
			return new horde.Vector2(
				Math.sin(heading) * mag,
				-Math.cos(heading) * mag
			);
		};

		/**
		 * Clones this vector
		 * @return {horde.Vector2} A clone of this vector
		 */
		proto.clone = function horde_Vector2_proto_clone () {
			return new horde.Vector2(this.x, this.y);
		};

		/**
		 * Scales this vector by a number
		 * @param {number} n Number to scale this vector by
		 * @return {horde.Vector2} This vector scaled by n
		 */
		proto.scale = function horde_Vector2_proto_scale (n) {
			this.x *= n;
			this.y *= n;
			return this;
		};

		proto.add = function horde_Vector2_proto_add (b) {
			this.x += b.x;
			this.y += b.y;
			return this;
		};

		proto.subtract = function horde_Vector2_proto_subtract (b) {
			this.x -= b.x;
			this.y -= b.y;
			return this;
		};
			
		proto.zero = function horde_Vector2_proto_zero () {
			this.x = 0;
			this.y = 0;
			return this;
		};

		proto.invert = function horde_Vector2_proto_invert () {
			this.x *= -1;
			this.y *= -1;
			return this;
		};

		proto.magnitude = function horde_Vector2_proto_magnitude () {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};

		proto.normalize = function horde_Vector2_proto_normalize () {
			var mag = this.magnitude();
			if (mag === 0) {
				return this;
			} else {
				return this.scale(1 / mag);
			}
		};

		proto.toString = function horde_Vector2_proto_toString () {
			return this.x + ", " + this.y;
		};

		proto.floor = function horde_Vector2_proto_floor () {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		};

		proto.abs = function horde_Vector2_proto_abs () {
			this.x = Math.abs(this.x);
			this.y = Math.abs(this.y);
			return this;
		};

		proto.angle = function horde_Vector2_proto_angle () {
			return this.heading() * (180 / Math.PI);
		};

		proto.heading = function horde_Vector2_proto_heading () {
			return Math.atan2(this.x, -this.y);
		};

		}());

		(function define_horde_Rect () {

			/**
			 * Object for dealing with rectangles
			 * @param {number} left Left coordinate of the rectangle
			 * @param {number} top Top coordinate of the rectangle
			 * @param {number} width Width of the rectangle
			 * @param {number} height Height of the rectangle
			 * @constructor
			 */
			horde.Rect = function horde_Rect (left, top, width, height) {
				this.left = Number(left) || 0;
				this.top = Number(top) || 0;
				this.width = Number(width) || 0;
				this.height = Number(height) || 0;
			};

			var Rect = horde.Rect;
			var proto = Rect.prototype;

			/**
			 * Checks for intersection of two rectangles
			 * @param {horde.Rect} a First rectangle
			 * @param {horde.Rect} b Second rectangle
			 * @return {boolean} True if a and b intersect otherwise false
			 */
			Rect.intersects = function horde_Rect_intersects (a, b) {
				return (
					a.left <= (b.left + b.width) && 
					b.left <= (a.left + a.width) &&
					a.top <= (b.top + b.height) &&
					b.top <= (a.top + a.height)
				);
			};

			/**
			 * Returns the center of the rectangle as a vector
			 * @return {horde.Vector2} Vector representing the center point of this rectangle
			 */
			proto.center = function horde_Rect_proto_center () {
				var sizev = new horde.Vector2(this.width, this.height);
				return new horde.Vector2(this.left, this.top).add(sizev.scale(0.5));
			};

			/**
			 * Checks for intersection of this rectangle and another
			 * @param {horde.Rect} rect Rectangle to check
			 * @return {boolean} True if rect intersects with this rectangle otherwise false
			 */
			proto.intersects = function horde_Rect_proto_intersects (rect) {
				return Rect.intersects(this, rect);
			};

			/**
			 * Reduces the size of this rect by a given amount
			 * @param {number} amount Amount to reduce on each side
			 * @return {void}
			 */
			proto.reduce = function horde_Rect_proto_reduce (amount) {
				this.left += amount;
				this.top += amount;
				this.width -= amount * 2;
				this.height -= amount * 2;
				return this;
			};

			}());


		(function () {

			horde.Keyboard = function () {
				this.history = [];
				this.keyStates = {};
				this.lastKeyStates = {};
				horde.on("keydown", this.handleKeyDown, window, this);
				horde.on("keyup", this.handleKeyUp, window, this);
			};

			var Keyboard = horde.Keyboard;
			var proto = Keyboard.prototype;

			var Keys = {
				ESCAPE: 27,
				ENTER: 13,
				SPACE: 32,
				LEFT: 37,
				UP: 38,
				RIGHT: 39,
				DOWN: 40,
				A: 65,
				B: 66,
				D: 68,
				E: 69,
				F: 70,
				G: 71,
				K: 75,
				L: 76,
				M: 77,
				O: 79,
				P: 80,
				Q: 81,
				R: 82,
				S: 83,
				T: 84,
				U: 85,
				W: 87,
				X: 88,
				Z: 90
			};
			Keyboard.Keys = Keys;

			Keyboard.konamiCode = [
				Keys.UP,
				Keys.UP,
				Keys.DOWN,
				Keys.DOWN,
				Keys.LEFT,
				Keys.RIGHT,
				Keys.LEFT,
				Keys.RIGHT,
				Keys.B,
				Keys.A
			];

			Keyboard.debugCode = [
				Keys.L,
				Keys.D,
				Keys.D,
				Keys.E,
				Keys.B,
				Keys.U,
				Keys.G
			];

			Keyboard.resetCode = [
				Keys.L,
				Keys.D,
				Keys.R,
				Keys.E,
				Keys.S,
				Keys.E,
				Keys.T
			];

			Keyboard.godModeCode = [
				Keys.L,
				Keys.D,
				Keys.D,
				Keys.Q,
				Keys.D
			];

			Keyboard.allWeaponsCode = [
				Keys.L,
				Keys.D,
				Keys.K,
				Keys.F,
				Keys.A
			];

			Keyboard.awesmCode = [
				Keys.A,
				Keys.W,
				Keys.E,
				Keys.S,
				Keys.M
			];

			Keyboard.bombCode = [
				Keys.L,
				Keys.D,
				Keys.B,
				Keys.O,
				Keys.M,
				Keys.B
			];

			Keyboard.cyclopsCode = [
				67, // C
				89, // Y
				67, // C
				Keys.L,
				Keys.O,
				Keys.P,
				Keys.S
			];

			Keyboard.html5Code = [
				72,
				84,
				77,
				76,
				53
			];

			Keyboard.meatboyCode = [
				Keys.M,
				Keys.E,
				Keys.A,
				Keys.T
			];

			proto.supressKeys = function (e) {
				switch (e.keyCode) {
					// Note: intentional fallthroughs.
					case Keys.ENTER:
					case Keys.LEFT:
					case Keys.UP:
					case Keys.RIGHT:
					case Keys.DOWN:
					case Keys.B:
					case Keys.A:
					case Keys.M:
					case Keys.Z:
					case Keys.X:
					case Keys.P:
					case Keys.SPACE:
					case Keys.W:
					case Keys.S:
					case Keys.D:
					case 191: // The "/" key to prevent searching in Firefox (#125)
						horde.stopEvent(e);
						break;
				}
			};

			proto.handleKeyDown = function (e) {
				this.history.push(e.keyCode);
				this.keyStates[e.keyCode] = true;
				this.supressKeys(e);
			};

			proto.handleKeyUp = function (e) {
				this.keyStates[e.keyCode] = false;
				this.supressKeys(e);
			};

			proto.isKeyDown = function (keyCode) {
				return (this.keyStates[keyCode] === true);
			};

			proto.isKeyPressed = function (keyCode) {
				return (this.isKeyDown(keyCode) && this.lastKeyStates[keyCode] !== true);
			};

			proto.isAnyKeyPressed = function (keyCode) {
				for (var keyCode in this.keyStates) {
					if (this.isKeyDown(keyCode) && this.lastKeyStates[keyCode] !== true) {
						return true;
					}
				}
				return false;
			};

			proto.clearKey = function (keyCode) {
				this.keyStates[keyCode] = false;
			};

			proto.clearKeys = function (keyCode) {
				this.keyStates = {};
			};

			proto.clearHistory = function () {
				this.history = [];
			};

			proto.historyMatch = function (keys) {
				var len = keys.length;
				var toCheck = this.history.slice(-len);
				if (toCheck.length !== len) {
					return false;
				}
				for (var x = 0; x < len; x++) {
					if (keys[x] !== toCheck[x]) {
						return false;	
					}
				}
				return true;
			};

			proto.storeKeyStates = function () {
				for (var keyCode in this.keyStates) {
					this.lastKeyStates[keyCode] = this.keyStates[keyCode];
				}
			};
				
			}());


		(function define_horde_Mouse () {

			horde.Mouse = function (canvas) {
				this.buttonStates = {};
				this.mouseX = 0;
				this.mouseY = 0;
				this.canvas = canvas;
				this.lastButtonStates = {};
				horde.on("mousemove", this.handleMouseMove, canvas, this);
				horde.on("mousedown", this.handleMouseDown, canvas, this);
				horde.on("mouseup", this.handleMouseUp, window, this);

				/*
				// iOS
				horde.on("touchmove", this.handleMouseMove, window, this);
				horde.on("touchstart", this.handleMouseDown, window, this);
				horde.on("touchend", this.handleMouseUp, window, this);	
				*/
			};

			var Mouse = horde.Mouse;
			var proto = Mouse.prototype;

			Mouse.Buttons = {
				LEFT: 0,
				RIGHT: 2
			};

            mouseFix = (this.window.innerHeight) - 400

			proto.handleMouseMove = function (e) {
				/*
				// iOS
				var touch = e.touches[0];
				e = {
					clientX: touch.pageX,
					clientY: touch.pageY
				};
				*/

				var offset = horde.getOffset(this.canvas);
				this.mouseX = (((e.clientX - offset.x) * this.canvas.width) / this.canvas.offsetWidth);
				this.mouseY = (((e.clientY - offset.y - (mouseFix*.125)) * this.canvas.height) / this.canvas.offsetHeight);
				this.hasMoved = true;
				// console.log(this.mouseX)
				// console.log(this.mouseY)
			};


			proto.handleMouseDown = function (e) {
				// iOS
				/*
				this.buttonStates[Mouse.Buttons.LEFT] = true;
				or e.button = Mouse.Buttons.LEFT;
				*/
				this.buttonStates[e.button] = true;
				horde.stopEvent(e);
				if (window.focus) window.focus();
			};

			proto.handleMouseUp = function (e) {
				// iOS
				/*
				this.buttonStates[Mouse.Buttons.LEFT] = true;
				or e.button = Mouse.Buttons.LEFT;
				*/
				this.buttonStates[e.button] = false;
			};

			proto.isButtonDown = function (button) {
				return this.buttonStates[button];
			};

			proto.isAnyButtonDown = function () {
				for (var key in this.buttonStates) {
					if (this.buttonStates[key]) {
						return true;
					}
				}

				return false;
			};

			proto.clearButtons = function () {
				this.buttonStates = {};
			};

			proto.wasButtonClicked = function (button) {
				return (this.buttonStates[button] && !this.lastButtonStates[button]);
			};

			proto.storeButtonStates = function () {
				for (var key in this.buttonStates) {
					this.lastButtonStates[key] = this.buttonStates[key];
				}
			};

			}());



		horde.isDemo = function () {
			return false;
		};

		horde.populateWaves = function (engine) {

			// FULL GAME WAVES

			// Wave 1: Level 1
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "bat", 1);
			w.addObjects(1, "bat", 1);
			w.addObjects(2, "bat", 1);
			engine.waves.push(w);

			// Wave 2
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "goblin", 2);
			w.addObjects(1, "goblin", 2);
			w.addObjects(2, "goblin", 2);
			engine.waves.push(w);

			// Wave 3
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "cyclops", 1);
			engine.waves.push(w);

			// Wave 4
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 2);
			w.addObjects(1, "demoblin", 3);
			w.addObjects(2, "demoblin", 2);
			engine.waves.push(w);

			// Wave 5
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 500);
			w.addSpawnPoint(1, 750);
			w.addSpawnPoint(2, 500);
			w.addObjects(0, "bat", 5);
			w.addObjects(0, "goblin", 2);
			w.addObjects(1, "goblin", 2);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "goblin", 3);
			w.addObjects(2, "bat", 5);
			w.addObjects(2, "goblin", 2);
			engine.waves.push(w);
			
			// Wave 6
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 200);
			w.addSpawnPoint(1, 200);
			w.addSpawnPoint(2, 200);
			w.addObjects(0, "bat", 10);
			w.addObjects(1, "bat", 10);
			w.addObjects(2, "bat", 10);
			engine.waves.push(w);
			
			// Wave 7
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 3);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "goblin", 5);
			w.addObjects(2, "demoblin", 3);
			engine.waves.push(w);

			// Wave 8
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 5000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "imp", 5);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "imp", 5);
			engine.waves.push(w);

			// Wave 9
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 750);
			w.addSpawnPoint(1, 750);
			w.addSpawnPoint(2, 750);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(2, "cyclops", 1);
			w.addObjects(0, "bat", 10);
			w.addObjects(1, "bat", 10);
			w.addObjects(2, "bat", 10);
			engine.waves.push(w);

			// Wave 10: Gelatinous Cube
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "cube", 1);
			w.bossWave = true;
			w.bossName = "Gelatinous Cube";
			engine.waves.push(w);

			// Wave 11: Level 2
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 20000);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 20000);
			w.addObjects(0, "sandworm", 2);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(2, "sandworm", 2);
			engine.waves.push(w);

			// Wave 12
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 10000);
			w.addSpawnPoint(1, 10000);
			w.addSpawnPoint(2, 10000);
			w.addObjects(0, "wizard", 2);
			w.addObjects(1, "wizard", 2);
			w.addObjects(2, "wizard", 2);
			engine.waves.push(w);

			// Wave 13
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 7500);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 7500);
			w.addObjects(0, "flaming_skull", 2);
			w.addObjects(1, "flaming_skull", 2);
			w.addObjects(2, "flaming_skull", 2);
			engine.waves.push(w);

			// Wave 14
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(2, "owlbear", 1);
			engine.waves.push(w);

			// Wave 15
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "huge_skull", 1);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "huge_skull", 1);
			engine.waves.push(w);

			// Wave 16
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 500);
			w.addSpawnPoint(1, 4000);
			w.addSpawnPoint(2, 500);
			w.addObjects(0, "dire_bat", 5);
			w.addObjects(0, "hunter_goblin", 2);
			w.addObjects(0, "dire_bat", 5);
			w.addObjects(0, "hunter_goblin", 2);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(2, "dire_bat", 5);
			w.addObjects(2, "hunter_goblin", 2);
			w.addObjects(2, "dire_bat", 5);
			w.addObjects(2, "hunter_goblin", 2);
			engine.waves.push(w);

			// Wave 17
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "flaming_skull", 2);
			w.addObjects(1, "imp", 5);
			w.addObjects(1, "wizard", 3);
			w.addObjects(2, "flaming_skull", 2);
			engine.waves.push(w);

			// Wave 18
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1500);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 1500);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "goblin", 5);
			w.addObjects(1, "demoblin", 3);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "demoblin", 5);
			w.addObjects(2, "goblin", 5);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 19
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3500);
			w.addSpawnPoint(1, 4000);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "wizard", 5);
			w.addObjects(1, "imp", 5);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "sandworm", 3);
			engine.waves.push(w);

			// Wave 20: Minotaur
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "superclops", 1);
			w.bossWave = true;
			w.bossName = "Minotaur"
			engine.waves.push(w);
			
			// Wave 21: Level 3
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 100);
			w.addSpawnPoint(1, 100);
			w.addSpawnPoint(2, 100);
			w.addObjects(0, "bat", 15);
			w.addObjects(1, "dire_bat", 15);
			w.addObjects(2, "bat", 15);
			engine.waves.push(w);

			// Wave 22
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1500);
			w.addSpawnPoint(1, 1500);
			w.addSpawnPoint(2, 1500);
			w.addObjects(0, "goblin", 15);
			w.addObjects(1, "hunter_goblin", 15);
			w.addObjects(2, "goblin", 15);
			engine.waves.push(w);

			// Wave 23
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2000);
			w.addSpawnPoint(1, 2000);
			w.addSpawnPoint(2, 2000);
			w.addObjects(0, "demoblin", 12);
			w.addObjects(1, "demoblin", 12);
			w.addObjects(2, "demoblin", 12);
			engine.waves.push(w);

			// Wave 24
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 25000);
			w.addSpawnPoint(1, 25000);
			w.addSpawnPoint(2, 25000);
			w.addObjects(0, "cyclops", 2);
			w.addObjects(1, "cyclops", 2);
			w.addObjects(2, "cyclops", 2);
			engine.waves.push(w);
			
			// Wave 25
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "imp", 10);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "imp", 10);
			engine.waves.push(w);
			
			// Wave 26
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 25000);
			w.addSpawnPoint(1, 25000);
			w.addSpawnPoint(2, 25000);
			w.addObjects(0, "owlbear", 2);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "owlbear", 2);
			engine.waves.push(w);
			
			// Wave 27
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 12000);
			w.addSpawnPoint(1, 12000);
			w.addSpawnPoint(2, 12000);
			w.addObjects(0, "wizard", 4);
			w.addObjects(1, "wizard", 4);
			w.addObjects(2, "wizard", 4);
			engine.waves.push(w);
			
			// Wave 28
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "flaming_skull", 5);
			w.addObjects(1, "huge_skull", 3);
			w.addObjects(2, "flaming_skull", 5);
			engine.waves.push(w);
			
			// Wave 29
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 15000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "sandworm", 5);
			w.addObjects(1, "sandworm", 5);
			w.addObjects(2, "sandworm", 5);
			engine.waves.push(w);
			
			// Wave 30: Green Dragon
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "dragon", 1);
			w.bossWave = true;
			w.bossName = "Green Dragon"
			engine.waves.push(w);

			// Wave 31: Level 4
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3500);
			w.addSpawnPoint(1, 3500);
			w.addSpawnPoint(2, 3500);
			w.addObjects(0, "goblin", 25);
			w.addObjects(1, "demoblin", 25);
			w.addObjects(2, "hunter_goblin", 25);
			engine.waves.push(w);

			// Wave 32
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 7500);
			w.addSpawnPoint(1, 5000);
			w.addSpawnPoint(2, 7500);
			w.addObjects(0, "sandworm", 2);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "imp", 10);
			w.addObjects(2, "sandworm", 2);
			w.addObjects(2, "wizard", 3);
			engine.waves.push(w);

			// Wave 33
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "owlbear", 3);
			w.addObjects(1, "flaming_skull", 6);
			w.addObjects(2, "owlbear", 3);
			engine.waves.push(w);

			// Wave 34
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2500);
			w.addSpawnPoint(1, 15000);
			w.addSpawnPoint(2, 2500);
			w.addObjects(0, "demoblin", 10);
			w.addObjects(0, "goblin", 10);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "demoblin", 10);
			w.addObjects(2, "goblin", 10);
			engine.waves.push(w);

			// Wave 35
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 12500);
			w.addSpawnPoint(1, 20000);
			w.addSpawnPoint(2, 12500);
			w.addObjects(0, "sandworm", 5);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(1, "cyclops", 1);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 5);
			engine.waves.push(w);

			// Wave 36
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 20000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 20000);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "flaming_skull", 1);
			w.addObjects(1, "wizard", 8);
			w.addObjects(2, "cyclops", 1);
			w.addObjects(2, "flaming_skull", 1);
			engine.waves.push(w);

			// Wave 37
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 4000);
			w.addSpawnPoint(1, 10000);
			w.addSpawnPoint(2, 4000);
			w.addObjects(0, "demoblin", 8);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "demoblin", 8);
			engine.waves.push(w);

			// Wave 38
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 5000);
			w.addSpawnPoint(1, 7500);
			w.addSpawnPoint(2, 5000);
			w.addObjects(0, "sandworm", 1);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "flaming_skull", 4);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 1);
			w.addObjects(2, "wizard", 3);
			engine.waves.push(w);
			
			// Wave 39
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2000);
			w.addSpawnPoint(1, 2500);
			w.addSpawnPoint(2, 2000);
			w.addObjects(0, "goblin", 30);
			w.addObjects(1, "demoblin", 25);
			w.addObjects(2, "hunter_goblin", 30);
			engine.waves.push(w);

			// Wave 40: Beholder
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "beholder", 1);
			w.bossWave = true;
			w.bossName = "Beholder"
			engine.waves.push(w);
			
			// Wave 41: Level 5
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "cyclops", 2);
			w.addObjects(1, "owlbear", 2);
			w.addObjects(2, "cyclops", 2);
			engine.waves.push(w);

			// Wave 42
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "wizard", 3);
			w.addObjects(0, "flaming_skull", 1);
			w.addObjects(1, "wizard", 3);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "wizard", 3);
			w.addObjects(2, "flaming_skull", 1);
			engine.waves.push(w);

			// Wave 43
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "sandworm", 3);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(1, "sandworm", 3);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(2, "sandworm", 3);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 44
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 200);
			w.addSpawnPoint(1, 200);
			w.addSpawnPoint(2, 200);
			w.addObjects(0, "dire_bat", 20);
			w.addObjects(0, "wizard", 2);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(1, "dire_bat", 20);
			w.addObjects(1, "sandworm", 2);
			w.addObjects(1, "owlbear", 1);
			w.addObjects(2, "dire_bat", 20);
			w.addObjects(2, "wizard", 2);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 45
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 3000);
			w.addSpawnPoint(1, 3000);
			w.addSpawnPoint(2, 3000);
			w.addObjects(0, "goblin", 10);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(0, "wizard", 3);
			w.addObjects(1, "demoblin", 10);
			w.addObjects(1, "huge_skull", 1);
			w.addObjects(1, "sandworm", 3);
			w.addObjects(2, "hunter_goblin", 10);
			w.addObjects(2, "owlbear", 1);
			w.addObjects(2, "flaming_skull", 3);
			engine.waves.push(w);

			// Wave 46
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 2500);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 2500);
			w.addObjects(0, "wizard", 4);
			w.addObjects(1, "cube", 1);
			w.addObjects(2, "wizard", 4);
			engine.waves.push(w);

			// Wave 47
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 1000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 1000);
			w.addObjects(0, "demoblin", 5);
			w.addObjects(1, "superclops", 1);
			w.addObjects(1, "demoblin", 4);
			w.addObjects(2, "demoblin", 5);
			engine.waves.push(w);

			// Wave 48
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 30000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 30000);
			w.addObjects(0, "sandworm", 1);
			w.addObjects(0, "owlbear", 1);
			w.addObjects(1, "dragon", 1);
			w.addObjects(2, "sandworm", 1);
			w.addObjects(2, "owlbear", 1);
			engine.waves.push(w);

			// Wave 49
			var w = new horde.SpawnWave();
			w.addSpawnPoint(0, 15000);
			w.addSpawnPoint(1, 1000);
			w.addSpawnPoint(2, 15000);
			w.addObjects(0, "wizard", 1);
			w.addObjects(0, "cyclops", 1);
			w.addObjects(1, "beholder", 1);
			w.addObjects(2, "wizard", 1);
			w.addObjects(2, "cyclops", 1);
			engine.waves.push(w);

			// Wave 50: Doppelganger
			var w = new horde.SpawnWave();
			w.addSpawnPoint(1, 1000);
			w.addObjects(1, "doppelganger", 1);
			w.bossWave = true;
			w.bossName = "Doppelganger"
			engine.waves.push(w);
			
		};


		(function define_horde_Engine () {

			var VERSION = "{{VERSION}}";
			var SCREEN_WIDTH = 640;
			var SCREEN_HEIGHT = 480;
			var URL_STORE = "https://chrome.google.com/extensions/detail/khodnfbkbanejphecblcofbghjdgfaih";

			var DEFAULT_HIGH_SCORE = 1000;
			var HIGH_SCORE_KEY = "high_score";

			var COLOR_BLACK = "rgb(0, 0, 0)";
			var COLOR_WHITE = "rgb(241, 241, 242)";
			var TEXT_HEIGHT = 20; // Ehh, kind of a hack, because stupid ctx.measureText only gives width (why??).
			var WAVE_TEXT_HEIGHT = 40;

			var OVERLAY_ALPHA = 0.7;
			var POINTER_HEIGHT = 24;
			var POINTER_X = 270;

			var TUTORIAL_HEIGHT = 70;
			var TUTORIAL_NUM_TIPS = 4;

			var GLOW_INCREMENT = 0.2;
			var GATE_CUTOFF_Y = 64;
			var NUM_GATES = 3;
			var SCORE_COUNT = 10;

			/**
			 * Creates a new Engine object
			 * @constructor
			 */
			horde.Engine = function horde_Engine () {
				this.lastUpdate = 0;
				this.canvases = {};
				this.map = null;
				this.spawnPoints = [];
				this.objects = {};
				this.objectIdSeed = 0;
				this.playerObjectId = null;
				this.keyboard = new horde.Keyboard();
				this.view = new horde.Size(SCREEN_WIDTH, SCREEN_HEIGHT);
				this.images = null;
				this.debug = false; // Debugging toggle
				this.konamiEntered = false;

				// Clay.io: Load in the API
				this.Clay = Clay = window.Clay = {};
				Clay.gameKey = "onslaughtarena";
				Clay.readyFunctions = [];
				Clay.options = {
					//debug: true
				};
				Clay.ready = function( fn ) {
					Clay.readyFunctions.push( fn );
				};
				( function() {
				var clay = document.createElement("script");
				clay.src = ( "https:" == document.location.protocol ? "https://" : "http://" ) + "clay.io/api/api-src.js";
				var tag = document.getElementsByTagName("script")[0]; tag.parentNode.insertBefore(clay, tag);
				} )();

				this.clayLeaderboard = { show: function() { console.log( "Clay.io leaderboard not ready yet!" ) } };

				var _this = this;
				Clay.ready( function() {
					_this.loggedIn = Clay.Player.loggedIn;
					_this.clayLeaderboard = new Clay.Leaderboard({ id: 385, filters: ['day', 'month', 'all'],
											tabs: [
												{ title: 'Cumulative', id: 385, cumulative: true, limit: 20, filters: ['day', 'month', 'all'] },
												{ title: 'My Best', id: 385, self: true, limit: 10 }
											]  });
				} );

				// Storage for each time putData is called - periodically that info is stored to Clay.io as well
				horde.localData = {};
				// Log which achievements have been granted so we don't keep trying to grant them
				horde.achievementsGranted = {};

				this.running = false;

				this.gateDirection = ""; // Set to "up" or "down"
				this.gateState = "down"; // "up" or "down"
				this.gatesX = 0;
				this.gatesY = 0;

				// Sword pointer
				this.pointerY = 0;
				this.pointerYStart = 0;
				this.maxPointerY = 0;
				this.pointerOptionsStart = 0;

				this.targetReticle = {
					position: new horde.Vector2(),
					angle: 0,
					moving: false
				};

				this.enableFullscreen = false;
				this.enableClouds = false;
				this.cloudTimer = null;
				this.woundsToSpeed = 10;

				this.introTimer = new horde.Timer();
				this.introPhase = 0;
				this.introPhaseInit = false;

				this.wonGame = false;
				this.wonGamePhase = 0;

				this.weaponPickup = {
					type: null,
					state: "off",
					alpha: 1,
					scale: 1,
					position: new horde.Vector2()
				};

				this.coinPickup = {
					amount: 0,
					state: "off",
					alpha: 1,
					position: new horde.Vector2()
				};

				// Flag enabling/disabling touch device mode
				this.touchMove = false;

				this.canMute = true;
				this.canFullscreen = false;
				this.wasdMovesArrowsAttack = true;

			};

			var proto = horde.Engine.prototype;

			proto.cacheBust = function () {
				if (VERSION.indexOf("VERSION") !== -1) {
					return "?cachebust=" + horde.Timer.now();
				} else {
					return "?cachebust=" + VERSION;
				}
			};

			proto.resize = function horde_Engine_proto_resize () {
				var windowWidth = window.innerWidth;
				var windowHeight = window.innerHeight;
				var stage = document.getElementById("stage");
				var stageHeight = (windowHeight - stage.offsetTop);
				stage.style.height = stageHeight + "px";
				if (this.enableFullscreen) {
					height = (stageHeight - 50);
					if (height < 480) {
						height = 480;
					}
					if (height > 768) {
						height = 768;
					}
					var width = Math.round(height * 1.333);
				} else {
					width = 640;
					height = 480;
				}
				var c = this.canvases["display"];
				// iOS
				/*
				Basically width/height on the canvas needs to be the entire resolution of the viewport.
				So like on iPad that's 1024x768. Just remove all chrome (like the nav) from the page and resize the canvas to 100%.
				*/
				c.style.width = width + "px";
				c.style.height = height + "px";
				var gameLeft = Math.max((windowWidth / 2) - (width / 2), 0);
				var gameTop = Math.max((stageHeight / 2) - (height / 2), 30);
				c.style.left = gameLeft + "px";
				c.style.top = gameTop + "px";
				var tip = document.getElementById("tip");
				if (tip) {
					tip.style.top = (gameTop - 30) + "px";
					tip.style.left = gameLeft + "px";
					tip.style.width = width + "px";
				}
			};

			/**
			 * Runs the engine
			 * @return {void}
			 */
			proto.run = function horde_Engine_proto_run () {
				this.init();
				this.lastUpdate = horde.now();
				this.start();
			};

			/**
			 * Starts the engine
			 * @return {void}
			 */
			proto.start = function horde_Engine_proto_start () {
				if (!this.running) {
					this.running = true;
					this.requestFrame();
				}
			};

			/**
			 * Stops the engine
			 * @return {void}
			 */
			proto.stop = function horde_Engine_proto_stop () {
				if (this.running) {
					this.running = false;
				}
			};

			/**
			 * Toggles pausing the engine
			 * Note: isMuted would be used by every instance since it's within its own closure. Ew!
			 * @return {void}
			 */
			proto.togglePause = (function horde_Engine_proto_togglePause () {

				var isMuted = false;

				return function horde_Engine_proto_togglePause () {

					if (this.getPlayerObject().hasState(horde.Object.states.DYING)) {
						return;
					}

					if (this.paused) {
						this.paused = false;
						horde.sound.setMuted(isMuted);
						horde.sound.play("unpause");
						horde.sound.play(this.currentMusic);
					} else {
						this.paused = true;
						this.initOptions();
						isMuted = horde.sound.isMuted();
						horde.sound.play("pause");
						horde.sound.stop(this.currentMusic);
					}

				};

			})();

			/**
			 * Adds an object to the engine's collection
			 * @param {horde.Object} Object to add
			 * @return {number} ID of the newly added object
			 */
			proto.addObject = function horde_Engine_proto_addObject (object) {
				this.objectIdSeed++;
				var id = "o" + this.objectIdSeed;
				object.id = id;
				this.objects[id] = object;
				return id;
			};

			/**
			 * Returns the RGB for either red, orange or green depending on the percentage.
			 * @param {Number} max The max number, eg 100.
			 * @param {Number} current The current number, eg 50 (which would be 50%).
			 * @return {String} The RGB value based on the percentage.
			 */
			proto.getBarColor = function (max, current) {

				var percentage = ((current / max) * 100);

				if (percentage > 50) {
					return "rgb(98, 187, 70)";
				} else if (percentage > 25) {
					return "rgb(246, 139, 31)";
				} else {
					return "rgb(238, 28, 36)";
				}

			};

			/**
			 * Spawns an object from a parent object
			 * @param {horde.Object} parent Parent object
			 * @param {string} type Type of object to spawn
			 * @return {void}
			 */
			proto.spawnObject = function horde_Engine_proto_spawnObject (
				parent,
				type,
				facing,
				takeOwnership
			) {
				var f = facing || parent.facing;
				var o = horde.makeObject(type, true);
				var owner = parent;
				while (owner.ownerId !== null) {
					if (this.objects[owner.ownerId]) {
						owner = this.objects[owner.ownerId];
					} else {
						break;
					}
				}
				if (takeOwnership !== false) {
					o.ownerId = owner.id;
					o.team = parent.team;
				}
				o.centerOn(parent.boundingBox().center());
				o.setDirection(f);
				o.init();
				return this.addObject(o);
			};

			proto.objectExists = function (objectId) {
				return (this.objects[objectId]);
			};

			/**
			 * Returns the currently "active" object
			 * In our case this is the player avatar
			 * @return {horde.Object} Player object
			 */
			proto.getPlayerObject = function horde_Engine_proto_getPlayerObject () {
				return this.objects[this.playerObjectId];
			};

			proto.getObjectCountByType = function horde_Engine_proto_getObjectCountByType (type) {
				var count = 0;
				for (var id in this.objects) {
					var obj = this.objects[id];
					if (obj.type === type) {
						count++;
					}
				}
				return count;
			};

			proto.isAlive = function horde_Engine_proto_isAlive (objectId) {
				if (this.objects[objectId]) {
					var o = this.objects[objectId];
					return (o.alive && o.wounds < o.hitPoints);
				}
				return false;
			};

			proto.preloadComplete = function () {
				this.state = "intro";
				this.logoAlpha = 0;
				this.logoFade = "in";
				this.logoFadeSpeed = 0.5;
			};

			/**
			 * Initializes the engine
			 * @return {void}
			 */
			proto.init = function horde_Engine_proto_init () {

				this.state = "intro";

				this.canvases["display"] = horde.makeCanvas("display", this.view.width, this.view.height);
				this.canvases["buffer"] = horde.makeCanvas("buffer", this.view.width, this.view.height, true);
				this.canvases["waveText"] = horde.makeCanvas("waveText", this.view.width, this.view.height, true);

				this.resize();
				horde.on("resize", this.resize, window, this);

				this.mouse = new horde.Mouse(this.canvases["display"]);

				horde.on("contextmenu", function (e) {
					horde.stopEvent(e);
				}, document.body, this);

				horde.on("blur", function () {
					if (this.state != "running" || this.wonGame) return;
					this.keyboard.keyStates = {};
					if (!this.paused) {
						this.togglePause();
					}
					this.stop();
				}, window, this);

				horde.on("focus", function () {
					this.start();
				}, window, this);

/* 				// Load just the logo
				this.preloader = new horde.ImageLoader();
				this.preloader.load({
					"ui": "img/sheet_ui.png" + this.cacheBust()
				}, this.preloadComplete, this);

				// Load the rest of the image assets
				this.images = new horde.ImageLoader();
				this.images.load({
					"arena": "img/sheet_arena.png" + this.cacheBust(),
					"characters": "img/sheet_characters.png" + this.cacheBust(),
					"objects": "img/sheet_objects.png" + this.cacheBust(),
					"beholder": "img/sheet_beholder.png" + this.cacheBust(),
				}, this.handleImagesLoaded, this);

				console.log(horde) */

				// Load just the logo
				this.preloader = new horde.ImageLoader();
				this.preloader.load({
					"ui": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_ui.png" 

				}, this.preloadComplete, this);

				// Load the rest of the image assets
				this.images = new horde.ImageLoader();
				this.images.load({
					"arena": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_arena.png",
					"characters": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_characters.png",
					"objects": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_objects.png",
					"beholder": "https://raw.githubusercontent.com/CopeBears/AtariFiles/main/imgOnslaught/sheet_beholder.png"
				}, this.handleImagesLoaded, this);



				var highScore = this.getData(HIGH_SCORE_KEY);
				if (highScore === null) {
					this.putData(HIGH_SCORE_KEY, DEFAULT_HIGH_SCORE);
				}

				this.initSound();

			};

			/**
			 * Initializes music and sound effects
			 * @return {void}
			 */
			proto.initSound = function horde_Engine_proto_initSound () {

				horde.sound.init(function () {

					// Create all sound files
					var musicDir = "https://github.com/CopeBears/AtariFiles/blob/main/sound/music/";
					var sfxDir = "https://github.com/CopeBears/AtariFiles/blob/main/sound/effects/";
					var s = horde.sound;

					// Music
					s.create("normal_battle_music", musicDir + "normal_battle", true, 20);
					s.create("final_battle_music", musicDir + "final_battle", true, 20);
					s.create("victory", musicDir + "victory", true, 20);

					// UI
					s.create("move_pointer", sfxDir + "move_pointer", false, 50);
					s.create("select_pointer", sfxDir + "select_pointer", false, 50);
					s.create("pause", sfxDir + "pause");
					s.create("unpause", sfxDir + "unpause");

					// Environment
					s.create("code_entered", sfxDir + "code_entered");
					s.create("gate_opens", sfxDir + "gate_opens");
					s.create("gate_closes", sfxDir + "gate_closes");
					s.create("spike_attack", sfxDir + "spike_attacks");

					// Misc
					s.create("immunity", sfxDir + "immunity", false, 25);
					s.create("coins", sfxDir + "coins", false, 10);
					s.create("eat_food", sfxDir + "eat_food", false, 30);
					s.create("pickup_weapon", sfxDir + "pickup_weapon");
					s.create("weapon_wall", sfxDir + "weapon_wall", false, 25);

					// Hero
					s.create("fire_attack", sfxDir + "char_attacks_fire");
					s.create("hero_attacks", sfxDir + "char_attacks");
					s.create("hero_damage", sfxDir + "char_damage_3");
					s.create("hero_dies", sfxDir + "char_dies");

					// Bat
					// Attack: not needed
					s.create("bat_damage", sfxDir + "bat_damage");
					s.create("bat_dies", sfxDir + "bat_dies");

					// Goblin
					s.create("goblin_attacks", sfxDir + "goblin_attacks");
					s.create("goblin_damage", sfxDir + "goblin_damage");
					s.create("goblin_dies", sfxDir + "goblin_dies");

					// Demoblin
					s.create("demoblin_attacks", sfxDir + "demoblin_attacks", false, 80);
					// Damage: goblin_damage
					// Dies: goblin_dies

					// Imp
					// Attack: not needed
					s.create("imp_damage", sfxDir + "imp_damage", false, 30);
					s.create("imp_dies", sfxDir + "imp_dies", false, 30);

					// Gel
					// Attack: not needed
					s.create("gel_damage", sfxDir + "gel_damage", false, 20);
					s.create("gel_dies", sfxDir + "gel_dies", false, 20);

					// Flaming Skull
					// Attack: not needed
					s.create("skull_damage", sfxDir + "skull_damage", false, 25);
					s.create("skull_dies", sfxDir + "skull_dies", false, 5);

					// Wizard
					s.create("wizard_attacks", sfxDir + "wizard_attacks", false, 25);
					// Damage: goblin_damage
					// Dies: goblin_dies
					s.create("wizard_disappear", sfxDir + "wizard_disappear", false, 50);
					s.create("wizard_reappear", sfxDir + "wizard_reappear", false, 50);

					// Sandworm
					s.create("sandworm_attacks", sfxDir + "sandworm_attacks", false, 75);
					// Damage: goblin_damage
					s.create("sandworm_dies", sfxDir + "sandworm_dies", false, 40);

					// Cyclops
					s.create("cyclops_attacks", sfxDir + "cyclops_attacks");
					s.create("cyclops_damage", sfxDir + "cyclops_damage");
					s.create("cyclops_dies", sfxDir + "cyclops_dies");

					// Owlbear
					s.create("owlbear_alarm", sfxDir + "owlbear_alarm", false, 20);
					s.create("owlbear_attacks", sfxDir + "owlbear_attacks", false, 15);
					s.create("owlbear_damage", sfxDir + "owlbear_damage", false, 40);
					s.create("owlbear_dies", sfxDir + "owlbear_dies", false, 50);

					// Boss 1/5: Gelatinous Cube
					s.create("cube_attacks", sfxDir + "cube_attacks");
					s.create("cube_damage", sfxDir + "cube_damage");
					s.create("cube_dies", sfxDir + "cube_dies");

					// Minotaur
					s.create("minotaur_attacks", sfxDir + "minotaur_attacks");
					s.create("minotaur_damage", sfxDir + "minotaur_damage");
					s.create("minotaur_dies", sfxDir + "minotaur_dies");

					// Boss 3/5: Green Dragon
					s.create("dragon_attacks", sfxDir + "dragon_attacks");
					s.create("dragon_damage", sfxDir + "dragon_damage");
					s.create("dragon_dies", sfxDir + "dragon_dies");

					// Boss 4/5: Beholder
					s.create("beholder_damage", sfxDir + "beholder_damage", false, 50);
					s.create("beholder_dies", sfxDir + "beholder_dies", false, 25);

					// Add: Eyelet
					s.create("eyelet_damage", sfxDir + "eyelet_damage", false, 25);
					s.create("eyelet_dies", sfxDir + "eyelet_dies", false, 25);

					// Boss 5/5: Doppelganger
					s.create("dopp_attacks", sfxDir + "dopp_attacks", false, 50);
					s.create("dopp_damage", sfxDir + "dopp_damage", false, 50);
					s.create("dopp_dies", sfxDir + "dopp_dies");

				});

			};

			proto.initGame = function () {

				this.konamiEntered = false;
				this.enableClouds = false;

				this.closeGates();

				this.objects = {};
				this.state = "title";
				this.initOptions();

				this.initMap();

				this.initSpawnPoints();
				this.initWaves();

				this.initPlayer();

				this.gameOverBg = null;

				this.monstersAlive = 0;

				this.gotNewHighScore = 0;
				this.scoreCount = 0;
				this.statsCount = 0;
				this.statsIncrement = 0;
				this.statsIndex = 0;
				this.statsTimer = null;
				this.highScoreSaved = false;

				this.wonGame = false;
				this.wonGamePhase = 0;

				this.showReticle = false;
				this.hideReticleTimer = null;

				this.showTutorial = false;
				this.tutorialIndex = 0;
				this.tutorialY = -TUTORIAL_HEIGHT;
				this.tutorialDirection = "down";
				this.hideTutorialTimer = null;
				this.nextTutorialTimer = null;

				this.heroFiring = false;
				this.heroFiringDirection = null;
				this.woundsTo = 0;

				this.gameStartTime = horde.now();

			};

			/**
			 * Initializes the map
			 * @return {void}
			 */
			proto.initMap = function horde_Engine_proto_initMap () {
				this.tileSize = new horde.Size(32, 32);
				this.map = [
					[0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0],
					[0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
				];
			};

			/**
			 * Initialize the spawn points
			 * @return {void}
			 */
			proto.initSpawnPoints = function horde_Engine_proto_initSpawnPoints () {

				this.spawnPoints = [];

				// Left gate (index 0)
				this.spawnPoints.push(new horde.SpawnPoint(
					3 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

				// Center gate (index 1)
				this.spawnPoints.push(new horde.SpawnPoint(
					9 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

				// Right gate (index 2)
				this.spawnPoints.push(new horde.SpawnPoint(
					15 * this.tileSize.width, -2 * this.tileSize.height,
					this.tileSize.width * 2, this.tileSize.height * 2
				));

			};

			/**
			 * Queues up a wave of spawns in the spawn points
			 * @param {horde.SpawnWave} Wave to spawn
			 * @return {void}
			 */
			proto.initSpawnWave = function horde_Engine_proto_initSpawnWave (wave) {
				var longestTTS = 0;
				for (var x in wave.points) {
					var p = wave.points[x];
					var sp = this.spawnPoints[p.spawnPointId];
					sp.delay = p.delay;
					sp.lastSpawnElapsed = sp.delay;
					for (var z in p.objects) {
						var o = p.objects[z];
						sp.queueSpawn(o.type, o.count);
					}
					var timeToSpawn = ((sp.queue.length - 1) * sp.delay);
					if (timeToSpawn > longestTTS) {
						longestTTS = timeToSpawn;
					}
				}
				var ttl = longestTTS + wave.nextWaveTime;
				this.waveTimer.start(ttl);
				this.openGates();
			};

			/**
			 * Initializes the waves of bad guys!
			 * @return {void}
			 */
			proto.initWaves = function horde_Engine_proto_initWaves () {

				this.waves = [];
				this.waveTimer = new horde.Timer();
				this.waveTimer.start(1);
				this.currentWaveId = -1;

				this.waveText = {
					string: "",
					size: 20,
					state: "off",
					alpha: 0
				};

				// Wave testing code...
				/*
				var testWave = 50;
				this.waveHack = true;
				this.currentWaveId = (testWave - 2);
				*/

				// Test Wave
				/*
				var w = new horde.SpawnWave();
				w.addSpawnPoint(0, 1000);
				w.addSpawnPoint(1, 1000);
				w.addSpawnPoint(2, 1000);
				w.addObjects(0, "huge_skull", 1);
				w.addObjects(1, "huge_skull", 1);
				w.addObjects(2, "huge_skull", 1);
				w.nextWaveTime = Infinity;
				this.waves.push(w);
				*/

				horde.populateWaves(this);

			};

			/**
			 * Initializes the player
			 * @return {void}
			 */
			proto.initPlayer = function horde_Engine_proto_initPlayer () {
				var player = horde.makeObject("hero");
				// NOTE: below line shouldn't be necessary, but it fixes the weapon retention bug for now.
				player.weapons = [
					{type: "h_sword", count: null}
				];
				player.centerOn(horde.Vector2.fromSize(this.view).scale(0.5));
				this.playerObjectId = this.addObject(player);
				if (this.touchMove) {
					this.targetReticle.position = player.boundingBox().center();
				}
			};

			proto.handleImagesLoaded = function horde_Engine_proto_handleImagesLoaded () {
				this.imagesLoaded = true;
			};

			proto.logoFadeOut = function () {
				this.logoFade = "out";
			};

			proto.updateLogo = function (elapsed) {

				var kb = this.keyboard;
				var keys = horde.Keyboard.Keys;

				if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
					kb.clearKeys();
					this.mouse.clearButtons();
					this.initGame();
				}

				if (this.logoFade === "in") {
					this.logoAlpha += ((this.logoFadeSpeed / 1000) * elapsed);
					if (this.logoAlpha >= 1) {
						this.logoAlpha = 1;
						this.logoFade = "none";
						horde.setTimeout(1000, this.logoFadeOut, this);
					}
				} else if (this.logoFade === "out") {
					this.logoAlpha -= ((this.logoFadeSpeed / 1000) * elapsed);
					if (this.logoAlpha <= 0) {
						this.logoAlpha = 0;
						this.logoFade = "none";
						this.initGame();
					}
				}
			};

			proto.updateIntroCinematic = function horde_Engine_proto_updateIntroCinematic (elapsed) {

				this.introTimer.update(elapsed);

				switch (this.introPhase) {

					// Fade out
					case 0:
						if (!this.introPhaseInit) {
							this.introFadeAlpha = 0;
							this.introPhaseInit = true;
						}
						this.introFadeAlpha += (1 / 1000) * elapsed;
						if (this.introFadeAlpha >= 1) {
							this.introFadeAlpha = 1;
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Fade in
					case 1:
						if (!this.introPhaseInit) {
							this.introFadeAlpha = 1;
							this.introPhaseInit = true;
						}
						this.introFadeAlpha -= (0.5 / 1000) * elapsed;
						if (this.introFadeAlpha <= 0) {
							this.introFadeAlpha = 0;
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Wait for a sec...
					case 2:
						if (!this.introPhaseInit) {
							this.introTimer.start(1000);
							this.introPhaseInit = true;
						}
						if (this.introTimer.expired()) {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Open the gates
					case 3:
						if (!this.introPhaseInit) {
							this.openGates();
							this.introPhaseInit = true;
						}
						if (this.gateState === "up") {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					// Move hero out
					case 4:
						if (!this.introPhaseInit) {
							var h = horde.makeObject("hero");
							h.position.x = 304;
							h.position.y = -64;
							h.collidable = false;
							h.setDirection(new horde.Vector2(0, 1));
							this.introHero = h;
							this.introPhaseInit = true;
						}
						this.introHero.update(elapsed);
						this.moveObject(this.introHero, elapsed);
						if (this.introHero.position.y >= 222) {
							this.introHero.centerOn(horde.Vector2.fromSize(this.view).scale(0.5));
							this.introHero.stopMoving();
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 5:
					case 6:
					case 8:
						if (!this.introPhaseInit) {
							this.introTimer.start(500);
							this.introPhaseInit = true;
						}
						if (this.introTimer.expired()) {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 7:
						if (!this.introPhaseInit) {
							this.closeGates();
							this.introPhaseInit = true;
						}
						if (this.gateState === "down") {
							this.introPhase++;
							this.introPhaseInit = false;
						}
						break;

					case 9:
						if (!this.introPhaseInit) {
							this.introTimer.start(1000);
							this.introPhaseInit = true;
						}
						this.introHero.update(elapsed);
						if (this.introTimer.expired()) {
							this.currentMusic = "normal_battle_music";
							horde.sound.play(this.currentMusic);
							this.state = "running";
						}
						break;

				}

			};

			proto.update = function horde_Engine_proto_update () {

				var now = horde.now();
				var elapsed = (now - this.lastUpdate);
				this.lastUpdate = now;

				this.lastElapsed = elapsed;

				if (this.imagesLoaded !== true) {
					this.requestFrame();
					return;
				}

				switch (this.state) {

					case "intro":
						this.updateLogo(elapsed);
						this.render();
						break;

					case "title":
						this.handleInput();
						this.updateFauxGates(elapsed);
						this.render();
						break;

					case "credits":
						this.handleInput();
						this.render();
						break;

					case "intro_cinematic":
						this.handleInput();
						this.updateIntroCinematic(elapsed);
						this.updateFauxGates(elapsed);
						this.render();
						break;

					// The game!
					case "running":
						if (this.wonGame) {
							this.updateWonGame(elapsed);
						} else {
							this.handleInput();
						}
						if (!this.paused) {
							this.updateWaves(elapsed);
							this.updateSpawnPoints(elapsed);
							this.updateClouds(elapsed);
							this.updateObjects(elapsed);
							this.updateFauxGates(elapsed);
							this.updateWeaponPickup(elapsed);
							this.updateCoinPickup(elapsed);
						}
						if (this.showTutorial) {
							this.updateTutorial(elapsed);
						}
						this.render();
						break;

					case "game_over":
						this.updateGameOver(elapsed);
						this.render();
						break;

					case "buy_now":
						this.handleInput();
						this.render();
						break;

				}

				if (!this.hideReticleTimer) {
					this.hideReticleTimer = new horde.Timer();
				}
				if (this.mouse.hasMoved) {
					this.showReticle = false;
					this.hideReticleTimer.start(5000);
					this.nextTutorial(3);
				}
				this.hideReticleTimer.update(elapsed);
				if (this.hideReticleTimer.expired()) {
					this.showReticle = false;
				}

				this.mouse.hasMoved = false;

				this.requestFrame();
			};

			proto.requestFrame = function () {
				if (!this.running) { return; }
				requestAnimationFrame(bind(this, this.update));
			};

			proto.updateWeaponPickup = function horde_Engine_proto_updateWeaponPickup (elapsed) {
				var w = this.weaponPickup;
				if (w.state === "on") {
					w.scale += ((4.5 / 1000) * elapsed);
					w.alpha -= ((2.5 / 1000) * elapsed);
					if (w.alpha <= 0) {
						w.state = "off";
					}
				}
			};

			proto.updateCoinPickup = function horde_Engine_proto_updateCoinPickup (elapsed) {
				var w = this.coinPickup;
				if (w.state === "on") {
					w.position.y -= ((50 / 1000) * elapsed);
					w.alpha -= ((0.7 / 1000) * elapsed);
					if (w.alpha <= 0) {
						w.state = "off";
					}
				}
			};

			proto.updateWonGame = function horde_Engine_proto_updateWonGame (elapsed) {

				var player = this.getPlayerObject();

				if (this.roseTimer) {
					this.roseTimer.update(elapsed);
				}

				switch (this.wonGamePhase) {

					// Move Xam to the center of the room
					case 0:
						var center = new horde.Vector2(304, 192);
						player.moveToward(center);
						var diff = player.position.clone().subtract(center).abs();
						if (diff.x <= 5 && diff.y <= 5) {
							this.wonGamePhase++;
						}
						break;

					case 1:
						player.setDirection(new horde.Vector2(0, 1));
						player.stopMoving();
						player.addState(horde.Object.states.VICTORIOUS);
						this.roseTimer = new horde.Timer();
						this.roseTimer.start(100);
						this.rosesThrown = 0;
						this.wonGamePhase++;
						break;

					case 2:
						if (this.roseTimer.expired()) {
							++this.rosesThrown;
							var rose = horde.makeObject("rose");
							if (horde.randomRange(1, 2) === 2) {
								rose.position.x = -32;
								rose.position.y = horde.randomRange(100, 300);
								rose.setDirection(new horde.Vector2(1, 0));
							} else {
								rose.position.x = 682;
								rose.position.y = horde.randomRange(100, 300);
								rose.setDirection(new horde.Vector2(-1, 0));
							}
							this.addObject(rose);
							this.roseTimer.reset();
						}
						if (this.rosesThrown > 100) {
							this.endGame();
						}
						break;

				}

			};

			proto.updateClouds = function horde_Engine_proto_updateClouds (elapsed) {

				if (this.enableClouds !== true) {
					return;
				}

				if (this.cloudTimer === null) {
					this.cloudTimer = new horde.Timer();
					this.cloudTimer.start(2000);
				}

				this.cloudTimer.update(elapsed);

				var clouds = 0;

				// Kill off clouds that are past the screen
				for (var id in this.objects) {
					var o = this.objects[id];
					if (o.type === "cloud") {
						clouds++;
						if (o.position.x < -(o.size.width)) {
							o.die();
						}
					}
				}

				// Spawn new clouds
				if (clouds < 10 && this.cloudTimer.expired()) {
					if (horde.randomRange(1, 10) >= 1) {
						var numClouds = horde.randomRange(1, 3);
						for (var x = 0; x < numClouds; x++) {
							var cloud = horde.makeObject("cloud");
							cloud.position.x = SCREEN_WIDTH + horde.randomRange(1, 32);
							cloud.position.y = horde.randomRange(
								-(cloud.size.height / 2),
								SCREEN_HEIGHT + (cloud.size.height / 2)
							);
							cloud.setDirection(new horde.Vector2(-1, 0));
							this.addObject(cloud);
						}
					}
					this.cloudTimer.reset();
				}

			};

			/**
			 * Updates the spawn points
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.updateSpawnPoints = function horde_Engine_proto_updateSpawnPoints (elapsed) {
				if (this.gateState !== "up") {
					return;
				}
				var closeGates = true;
				// Iterate over the spawn points and update them
				for (var x in this.spawnPoints) {
					if (this.spawnPoints[x].queue.length >= 1) {
						closeGates = false;
					}
					// Spawn points can return an object to spawn
					var o = this.spawnPoints[x].update(elapsed, (this.monstersAlive === 0));
					if (o !== false) {
						// We need to spawn an object
						this.addObject(o);
					}
				}
				if (closeGates && !this.monstersAboveGates) {
					this.closeGates();
				}
			};

			proto.spawnWaveExtras = function horde_Engine_proto_spawnWaveExtras (waveNumber) {
				switch (waveNumber) {

					case 1:
						// Spawn a couple weapons scrolls to give the player an early taste of the fun!
						var player = this.getPlayerObject();

						// 1. Knife
						var wep = horde.makeObject("item_weapon_knife");
						wep.position = player.position.clone();
						wep.position.x -= 96;
						wep.position.y += 64;
						this.addObject(wep);

						// 2. Spear
						var wep = horde.makeObject("item_weapon_spear");
						wep.position = player.position.clone();
						wep.position.x -= 32;
						wep.position.y += 64;
						this.addObject(wep);

						// 3. Axe
						var wep = horde.makeObject("item_weapon_axe");
						wep.position = player.position.clone();
						wep.position.x += 32;
						wep.position.y += 64;
						this.addObject(wep);

						// 4. Fire
						var wep = horde.makeObject("item_weapon_fireball");
						wep.position = player.position.clone();
						wep.position.x += 96;
						wep.position.y += 64;
						this.addObject(wep);

						break;

					case 11:
						// Two spikes in the middle to the left and right
						var locs = [
							{x: 192, y: 224},
							{x: 416, y: 224}
						];
						var len = locs.length;
						for (var x = 0; x < len; ++x) {
							var pos = locs[x];
							var s = horde.makeObject("spikes");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 21:
						// Spike sentries in each corner
						var spikeLocs = [
							{x: 32, y: 64},
							{x: 32, y: 352},
							{x: 576, y: 64},
							{x: 576, y: 352}
						];
						var len = spikeLocs.length;
						for (var x = 0; x < len; x++) {
							var pos = spikeLocs[x];
							var s = horde.makeObject("spike_sentry");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 31:
						// Two spikes in the middle above and below
						var locs = [
							{x: 304, y: 114},
							{x: 304, y: 304}
						];
						var len = locs.length;
						for (var x = 0; x < len; ++x) {
							var pos = locs[x];
							var s = horde.makeObject("spikes");
							s.position = new horde.Vector2(pos.x, pos.y);
							this.addObject(s);
						}
						break;

					case 41:
						this.enableClouds = true;
						break;

					case 50:
						// Despawn all traps; Doppelganger is hard enough!!
						for (var id in this.objects) {
							var obj = this.objects[id];
							if (obj.role === "trap") {
								obj.die();
							}
						}
						break;

				}
			};

			/**
			 * Updates the waves
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.updateWaves = function horde_Engine_proto_updateWaves (elapsed) {
				if (this.wonGame) {
					return;
				}
				this.waveTimer.update(elapsed);
				var spawnsEmpty = true;
				for (var x in this.spawnPoints) {
					if (this.spawnPoints[x].queue.length > 0) {
						spawnsEmpty = false;
					}
				}
				// If the spawns are empty AND there are no monsters alive
				if (spawnsEmpty === true && this.monstersAlive === 0) {
					if (this.currentWaveId === (this.waves.length - 1)) {
						// Player won the game!!
						this.wonGame = true;
						horde.sound.stop("normal_battle_music");
						horde.sound.stop("final_battle_music");
						horde.sound.play("victory");
						return;
					}

					// Clay.io: Achievements
					var achievementId = false;
					switch( this.currentWaveId + 1 ) {
						case 1:
							achievementId = "wave1";
							break;
						case 5:
							achievementId = "wave5";
							break;
					}

			/* 		if(achievementId && !horde.achievementsGranted[achievementId]) {
						horde.achievementsGranted[achievementId] = true; // so we don't keep sending to Clay.io
						(new Clay.Achievement({ id: achievementId })).award();
					} */

					this.currentWaveId++;
					var actualWave = (this.currentWaveId + 1);
					if (this.continuing || this.waveHack) {
						var start = (this.waveHack) ? 1 : 2;
						// Start with 2 as we don't want the bonus weapons spawning at continue
						for (var wn = start; wn <= actualWave; ++wn) {
							this.spawnWaveExtras(wn);
						}
						this.waveHack = false;
					} else {
						this.spawnWaveExtras(actualWave);
					}
					var waveTextString = "Wave " + actualWave;
					var waveMusic = "normal_battle_music";
					if (actualWave > 1) {
						this.putData("checkpoint_wave", this.currentWaveId);
						this.putData("checkpoint_hero", JSON.stringify(this.getPlayerObject()));
					}
					if (this.waves[this.currentWaveId].bossWave) {
						waveTextString = ("Boss: " + this.waves[this.currentWaveId].bossName) + "!";
						waveMusic = "final_battle_music";
					}

					if (this.currentMusic !== waveMusic) {
						horde.sound.stop(this.currentMusic);
						this.currentMusic = waveMusic;
						horde.sound.play(this.currentMusic);
					}

					this.initSpawnWave(this.waves[this.currentWaveId]);
					this.waveText.string = waveTextString;
					this.waveText.alpha = 0;
					this.waveText.size = 1;
					this.waveText.state = "init";

					// Initialize the waveText buffer
					var b = this.canvases.waveText.getContext("2d");
					var text = this.waveText.string;

					b.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

					b.save();
					b.font = ("Bold " + WAVE_TEXT_HEIGHT + "px MedievalSharp");
					b.lineWidth = 3;
					b.textBaseline = "top";
					b.strokeStyle = COLOR_BLACK;
					b.fillStyle = "rgb(230, 103, 8)";

					b.strokeText(text, 0, 0);
					b.fillText(text, 0, 0);

					var metrics = b.measureText(text);
					this.waveText.width = metrics.width;
					b.restore();

					this.continuing = false;
				}
				switch (this.waveText.state) {
					case "init":
						this.waveText.alpha += ((2 / 1000) * elapsed);
						if (this.waveText.alpha >= 1) {
							this.waveText.alpha = 1;
							this.waveText.timer = new horde.Timer();
							this.waveText.timer.start(250);
							this.waveText.state = "display";
						}
						break;
					case "display":
						this.waveText.timer.update(elapsed);
						if (this.waveText.timer.expired()) {
							this.waveText.state = "hide";
						}
						break;
					case "hide":
						// hide the text
						this.waveText.alpha -= ((1.5 / 1000) * elapsed);
						this.waveText.size += ((20 / 1000) * elapsed);
						if (this.waveText.alpha <= 0) {
							this.waveText.alpha = 0;
							this.waveText.state = "off";
						}
						break;
				}
			};

			proto.updateGameOver = function horde_Engine_proto_updateGameOver (elapsed) {

				if (!this.gameOverAlpha) {
					this.gameOverReady = false;
					this.gameOverAlpha = 0;
				}

				var alphaChange = ((0.2 / 1000) * elapsed);
				this.gameOverAlpha += Number(alphaChange) || 0;

				if (this.gameOverAlpha >= 0.75) {
					this.gameOverReady = true;
					this.gameOverAlpha = 0.75;
				}

				if (this.gameOverReady) {
					if (!this.statsTimer) {
						this.statsTimer = new horde.Timer();
						this.statsCount = 0;
						this.statsIndex = 0;
						// Settings for Wave reached:
						this.statsTimer.start(50);
						this.statsIncrement = 1;
					}
					this.statsTimer.update(elapsed);
					if (this.statsTimer.expired()) {
						this.statsTimer.reset();
						this.statsCount += this.statsIncrement;
					}
				}

				if ((this.statsIndex >= 4) && !this.highScoreSaved) {
					this.highScoreSaved = true;

					var highScore = Number(this.getData(HIGH_SCORE_KEY));
					var totalScore = this.getTotalScore();

					// Clay.io: Post score to clay.io
					var _this = this;
			/* 		this.clayLeaderboard.post({ score: totalScore }, function() {
						// Show the leaderboard
						_this.showLeaderboard(true);
					}); */

					if (totalScore > highScore) {
						this.putData(HIGH_SCORE_KEY, totalScore);
						horde.sound.play("victory");
						this.gotNewHighScore = true;
					}
				}

			};

			/**
			* Takes a screenshot and posts it to the specified site through Clay.io
			* @param {String} site facebook or twitter
			*/
			proto.postSocial = function horde_Engine_proto_postSocial (site) {
				var screenshot = new Clay.Screenshot({ prompt: false, id: 'display' });
				var _this = this;
				screenshot.save(function( response ) {
					if(site == 'facebook')
						(new Clay.Facebook()).post({ message: "I just scored " + _this.getTotalScore() + " in Onslaught! Arena - (screenshot: " + response.url + ")", link: "http://onslaughtarena.clay.io" });
					else if(site == 'twitter')
						(new Clay.Twitter()).post({ message: "I just scored " + _this.getTotalScore() + " in Onslaught! Arena - (sreenshot: " + response.url + ")! Play me: http://onslaughtarena.clay.io" });
				} );

			}

			proto.openGates = function horde_Engine_proto_openGates () {
				if (this.gateState !== "up") {
					this.gateDirection = "up";
					horde.sound.play("gate_opens");
				}
			};

			proto.closeGates = function horde_Engine_proto_closeGates () {
				if (this.gateState !== "down") {
					this.gateDirection = "down";
					horde.sound.play("gate_closes");
				}
			};

			proto.updateFauxGates = function horde_Engine_proto_updateFauxGates (elapsed) {

				if (this.gateDirection === "down") {
					this.gatesX = 0;
					this.gatesY += ((200 / 1000) * elapsed);
					if (this.gatesY >= 0) {
						this.gatesX = 0;
						this.gatesY = 0;
						this.gateDirection = "";
						this.gateState = "down";
					}
				}

				if (this.gateDirection === "up") {
					this.gatesX = horde.randomRange(-1, 1);
					this.gatesY -= ((50 / 1000) * elapsed);
					if (this.gatesY <= -54) {
						this.gatesX = 0;
						this.gatesY = -54;
						this.gateDirection = "";
						this.gateState = "up";
					}
				}

			};

			proto.updateTutorial = function horde_Engine_proto_updateTutorial (elapsed) {

				var speed = 0.1;

				if (this.tutorialDirection === "down") {
					this.tutorialY += (speed * elapsed);
					if (this.tutorialY >= 0) {
						this.tutorialY = 0;
						this.tutorialDirection = null;

						if (this.tutorialIndex >= TUTORIAL_NUM_TIPS) {
							this.hideTutorialTimer.start(5000);
						}
					}
				}

				if (this.tutorialDirection === "up") {
					this.tutorialY -= (speed * elapsed);
					if (this.tutorialY < -TUTORIAL_HEIGHT) {
						this.tutorialY = -TUTORIAL_HEIGHT;
						this.tutorialDirection = "down";
						this.tutorialIndex += 1;
						if (this.tutorialIndex > TUTORIAL_NUM_TIPS) {
							this.showTutorial = false;
						}
					}
				}

				if (!this.hideTutorialTimer) {
					this.hideTutorialTimer = new horde.Timer();
				}

				if (!this.nextTutorialTimer) {
					this.nextTutorialTimer = new horde.Timer();
					this.nextTutorialTimer.start(10000);
				}

				this.hideTutorialTimer.update(elapsed);
				this.nextTutorialTimer.update(elapsed);

				if (this.hideTutorialTimer.expired()) {
					this.tutorialDirection = "up";
				}

				if (this.nextTutorialTimer.expired()) {
					this.nextTutorial(this.tutorialIndex + 1);
					this.nextTutorialTimer.reset();
				}

			};

			proto.nextTutorial = function horde_Engine_proto_nextTutorial (index) {

				if (!this.showTutorial || (this.tutorialDirection !== null)) {
					return;
				}

				// Move the tutorial up if we want to see the next one
				if (this.tutorialIndex === (index - 1)) {
					this.tutorialDirection = "up";
				}

			};

			/**
			* Returns an array of tiles which intersect a given rectangle
			* @param {horde.Rect} rect Rectangle
			* @return {array} Array of tiles
			*/
			proto.getTilesByRect = function horde_Engine_proto_getTilesByRect (rect) {

				var tiles = [];

				var origin = new horde.Vector2(rect.left, rect.top);
				var size = new horde.Vector2(rect.width, rect.height);

				var begin = origin.clone().scale(1 / this.tileSize.width).floor();
				var end = origin.clone().add(size).scale(1 / this.tileSize.width).floor();

				for (var tx = begin.x; tx <= end.x; tx++) {
					for (var ty = begin.y; ty <= end.y; ty++) {
						tiles.push({
							x: tx,
							y: ty
						});
					}
				}

				return tiles;

			};

			/**
			* Checks if a given object is colliding with any tiles
			* @param {horde.Object} object Object to check
			* @return {boolean} True if object is colliding with tiles, otherwise false
			*/
			proto.checkTileCollision = function horde_Engine_proto_checkTileCollision (object) {

				var tilesToCheck = this.getTilesByRect(object.boundingBox());

				for (var i = 0, len = tilesToCheck.length; i < len; i++) {
					var t = tilesToCheck[i];
					if (this.map[t.y] && this.map[t.y][t.x] === 0) {
						// COLLISION!
						return t;
					}
				}

				// No tile collision
				return false;

			};

			proto.moveObject = function horde_Engine_proto_moveObject (object, elapsed) {

				if (!object.badass && object.hasState(horde.Object.states.HURTING)) {
					return false;
				}

				var speed = object.speed;
				if (object.hasState(horde.Object.states.SLOWED)) {
					speed *= 0.20;
				}

				var px = ((speed / 1000) * elapsed);

				var axis = [];
				var collisionX = false;
				var collisionY = false;

				// Check tile collision for X axis
				if (object.direction.x !== 0) {
					// the object is moving along the "x" axis
					object.position.x += (object.direction.x * px);
					if (object.collidable) {
						if (object.position.x < 16) {
							object.position.x = 16;
						}
						if ((object.position.x + object.size.width) > 624) {
							object.position.x = (624 - object.size.width);
						}
						var tile = this.checkTileCollision(object);
						if (tile !== false) {
							axis.push("x");
							collisionX = true;
							var objCenterX = (object.position.x + (object.size.width / 2));
							var tileCenterX = ((tile.x * this.tileSize.width) + (this.tileSize.width / 2));
							if (objCenterX < tileCenterX) {
								object.position.x = tile.x * this.tileSize.width - object.size.width;
							} else {
								object.position.x = tile.x * this.tileSize.width + this.tileSize.width;
							}
						}
					}
				}

				// Check tile collision for Y axis
				if (object.direction.y !== 0) {
					// the object is moving along the "y" axis
					object.position.y += (object.direction.y * px);
					if (object.collidable) {
						if ((object.position.y + object.size.height) > 400) {
							object.position.y = (400 - object.size.height);
						}
						var tile = this.checkTileCollision(object);
						if (tile !== false) {
							axis.push("y");
							collisionY = true;
							var objCenterY = (object.position.y + (object.size.height / 2));
							var tileCenterY = ((tile.y * this.tileSize.height) + (this.tileSize.height / 2));
							if (objCenterY < tileCenterY) {
								object.position.y = tile.y * this.tileSize.height - object.size.height;
							} else {
								object.position.y = tile.y * this.tileSize.height + this.tileSize.height;
							}
						}
					}
				}

				if (object.collidable) {

					var yStop = 0;
					if (
						this.gateState === "down"
						|| object.role === "monster"
						|| object.role === "hero"
					) {
						yStop = GATE_CUTOFF_Y;
					}

					if (object.direction.y < 0 && object.position.y < yStop) {
						object.position.y = yStop;
						axis.push("y");
					}

					if (axis.length > 0) {
						object.wallCollide(axis);
					}

				}

			};

			proto.dropObject = function horde_Engine_proto_dropObject (object, type) {
				var drop = horde.makeObject(type);
				drop.position = object.position.clone();
				drop.position.y -= 1;
				if (this.isSpecialLoot(type)) {
					drop.position = new horde.Vector2(304, 226);
				}
				this.addObject(drop);
				if (this.isSpecialLoot(type)) {
					// Also spawn the pointer
					var ptr = horde.makeObject("pickup_arrow");
					ptr.position = drop.position.clone();
					ptr.position.x = (320 - (ptr.size.width / 2));
					ptr.position.y -= (ptr.size.height + 10);
					this.addObject(ptr);
				}
			};

			proto.isSpecialLoot = function horde_Engine_proto_isSpecialLoot (type) {
				return (
					(type === "item_weapon_fire_sword")
					|| (type === "item_gold_chest")
				);
			};

			proto.spawnLoot = function horde_Engine_proto_spawnLoot (object) {

				// Don't spawn stuff out of reach
				if (object.position.y < 44) return;

				var table = object.lootTable;
				var len = table.length;

				var weightedTable = [];
				for (var x = 0; x < len; x++) {
					var entry = table[x];
					for (var j = 0; j < entry.weight; j++) {
						weightedTable.push(entry.type);
					}
				}

				var rand = horde.randomRange(0, weightedTable.length - 1);
				var type = weightedTable[rand];

				if (type !== null) {
					var player = this.getPlayerObject();
					if (type === "item_food" && player.wounds === 0) {
						type = "item_chest";
					}
					if (type === "WEAPON_DROP") {
						switch (horde.randomRange(1, 4)) {
							case 1: type = "item_weapon_knife"; break;
							case 2: type = "item_weapon_spear"; break;
							case 3: type = "item_weapon_fireball"; break;
							case 4: type = "item_weapon_axe"; break;
						}
					}
					if (
						type.indexOf("item_weapon") >= 0
						&& player.hasWeapon("h_fire_sword")
					) {
						type = "item_chest";
					}
					this.dropObject(object, type);
				}

			};

			proto.updateObjects = function (elapsed) {

				var numMonsters = 0;
				var numMonstersAboveGate = 0;

				for (var id in this.objects) {

					var o = this.objects[id];

					if (o.isDead()) {
						if (o.role === "hero") {
							this.endGame();
							return;
						}
						o.execute("onDelete", [this]);
						delete(this.objects[o.id]);
						continue;
					}

					if (o.role === "monster" || o.type === "pickup_arrow") {
						numMonsters++;
						if (o.position.y <= GATE_CUTOFF_Y) {
							numMonstersAboveGate++;
						}
					}

					var action = o.update(elapsed, this);
					switch (action) {
						case "shoot":
							this.objectAttack(o);
							break;
					}

					if (o.isMoving() && !o.hasState(horde.Object.states.STUNNED)) {
						this.moveObject(o, elapsed);
					}

					if (
						o.role === "fluff"
						|| o.role === "powerup_food"
						|| o.hasState(horde.Object.states.DYING)
						|| o.hasState(horde.Object.states.INVISIBLE)
					) {
						continue;
					}

					for (var x in this.objects) {
						var o2 = this.objects[x];
						if (
							o2.isDead()
							|| o2.team === o.team
							|| o2.role === "fluff"
							|| o2.hasState(horde.Object.states.DYING)
							|| o2.hasState(horde.Object.states.INVISIBLE)
						) {
							continue;
						}
						// Reduce the size of the bounding boxes a tad when evaluating object => object collision
						if (o.boundingBox().reduce(5).intersects(o2.boundingBox().reduce(5))) {
							if (o.role == "hero") {
								if (o2.role == "powerup_food") {
									o2.die();
									o.wounds -= o2.healAmount;
									if (o.wounds < 0) o.wounds = 0;
									o.meatEaten++;
									horde.sound.play("eat_food");
									for (var j = 0; j < 5; ++j) {
										var heart = horde.makeObject("mini_heart");
										heart.position.x = (o.position.x + (j * (o.size.width / 5)));
										heart.position.y = (o.position.y + o.size.height - horde.randomRange(0, o.size.height));
										this.addObject(heart);
									}
								} else if (o2.role == "powerup_coin") {
									o2.die();
									o.gold += o2.coinAmount;
									horde.sound.play("coins");

									var c = this.coinPickup;
									c.amount = o2.coinAmount;
									c.y = 0;
									c.alpha = 1;
									c.position = o2.position.clone();
									c.state = "on";

									if (this.isSpecialLoot(o2.type)) {
										for (var j in this.objects) {
											if (this.objects[j].type === "pickup_arrow") {
												this.objects[j].die();
											}
										}
									}
								} else if (o2.role == "powerup_weapon") {
									o2.die();
									o.addWeapon(o2.wepType, o2.wepCount);
									horde.sound.play("pickup_weapon");

									var w = this.weaponPickup;
									w.type = o2.type;
									w.scale = 1;
									w.alpha = 0.9;
									w.position = o2.position.clone();
									w.state = "on";

									if (this.isSpecialLoot(o2.type)) {
										for (var j in this.objects) {
											if (this.objects[j].type === "pickup_arrow") {
												this.objects[j].die();
											}
										}
									}
								}
							}
							if (
								o.team !== null
								&& o2.team !== null
								&& o.team !== o2.team
							) {
								this.dealDamage(o2, o);
								this.dealDamage(o, o2);
							}
						}

					}

					// Update glowing weapons
					if (this.isBadassWeapon(o)) {
						if (o.glow === undefined) {
							o.glow = {
								alpha: 0,
								increment: GLOW_INCREMENT,
								timer: new horde.Timer()
							};
							o.glow.timer.start(50);
						}

						o.glow.timer.update(elapsed);

						if (o.glow.timer.expired()) {
							o.glow.timer.reset();
							o.glow.alpha += o.glow.increment;

							var max = (1 - GLOW_INCREMENT);
							if (o.glow.alpha >= max) {
								o.glow.alpha = max;
								o.glow.increment = -GLOW_INCREMENT;
							}

							var min = GLOW_INCREMENT;
							if (o.glow.alpha <= min) {
								o.glow.alpha = min;
								o.glow.increment = GLOW_INCREMENT;
							}
						}
					}

				}

				this.monstersAlive = numMonsters;
				this.monstersAboveGates = (numMonstersAboveGate > 0);

				var player = this.getPlayerObject();
				if (this.woundsTo < player.wounds) {
					this.woundsTo += ((this.woundsToSpeed / 1000) * elapsed);
				} else if (this.woundsTo > player.wounds) {
					this.woundsTo -= ((this.woundsToSpeed / 1000) * elapsed);
				} else {
					this.woundsTo = player.wounds;
				}

				var totalScore = this.getTotalScore();
				var diff = Math.abs(this.scoreCount - totalScore);
				var speed = horde.clamp(diff, 1000, 10000);
				var amount = Math.floor((speed / 1000) * elapsed);
				if (this.scoreCount < totalScore) {
					this.scoreCount += amount;
					if (this.scoreCount > totalScore) this.scoreCount = totalScore;
				} else if (this.scoreCount > totalScore) {
					this.scoreCount -= amount;
					if (this.scoreCount < totalScore) this.scoreCount = totalScore;
				}

				// Snap to grid to prevent vibrating bars
				if (Math.abs(player.wounds - this.woundsTo) <= 1) {
					this.woundsTo = player.wounds
				}

			};

			// Deals damage from object "attacker" to "defender"
			proto.dealDamage = function (attacker, defender) {

				// Monsters don't damage projectiles
				if (attacker.role === "monster" && defender.role === "projectile") {
					return false;
				}

				// Allow the objects to handle the collision
				attacker.execute("onObjectCollide", [defender, this]);

				// Traps & Projectiles shouldn't damage each other
				if (
					(attacker.role == "projectile" && defender.role == "trap")
					|| (attacker.role == "trap" && defender.role == "projectile")
				) {
					return false;
				}

				// Allow the defender to declare themselves immune to attacks from the attacker
				// For example: Cube is immune to non-fire attacks
				var nullify = defender.execute("onThreat", [attacker, this]);

				// Check for defender immunity
				if (
					defender.hasState(horde.Object.states.INVINCIBLE)
					|| defender.hitPoints === Infinity
					|| nullify === true
				) {
					// Defender is immune/invincible
					if (
						attacker.role === "projectile"
						&& attacker.hitPoints !== Infinity
					) {
						if (
							(
								defender.damageType === "magic"
								|| defender.damageType === "physical"
							)
							&& attacker.damageType === "physical"
						) {
							// deflect if both parties are physical
							attacker.reverseDirection();
							attacker.deflect();
							horde.sound.play("immunity");
						} else {
							// otherwise just kill the attacker
							attacker.die();
						}
					}
					return false;
				}

				// Special case for non-immune projectiles hitting each other
				if (
					attacker.hitPoints !== Infinity
					&& attacker.role === "projectile"
					&& defender.role === "projectile"
					&& attacker.damageType === "physical"
					&& defender.damageType === "physical"
				) {
					if (attacker.piercing === false) {
						attacker.reverseDirection();
						attacker.deflect();
					}
					if (defender.piercing === false) {
						defender.reverseDirection();
						defender.deflect();
					}
					return false;
				}

				// Allow attackers to do stuff when they've hurt something
				attacker.execute("onDamage", [defender, this]);

				// Track combat stats
				var scorer = attacker;
				if (scorer.ownerId !== null) {
					var owner = this.objects[scorer.ownerId];
					if (owner) {
						scorer = owner;
					}
				}
				if (attacker.role === "projectile") {
					scorer.shotsLanded++;
				}

				// Deal damage and check for death
				if (defender.wound(attacker.damage)) {
					// defender has died

					// Assign gold/kills etc
					scorer.gold += defender.worth;
					scorer.kills++;
					defender.execute("onKilled", [attacker, this]);
					if (defender.lootTable.length > 0) {
						this.spawnLoot(defender);
					}

					// Handler piercing weapons
					if (
						attacker.role === "projectile"
						&& attacker.piercing === false
						&& attacker.hitPoints !== Infinity
					) {
						attacker.die();
					}

				} else {
					// defender did NOT die

					// Make the player invincible after some damage
					if (attacker.damage > 0 && defender.role === "hero") {
						defender.addState(horde.Object.states.INVINCIBLE, 2500);
					}

					// Projectile failed to kill it's target; automatic death for projectile
					if (attacker.role === "projectile" && attacker.hitPoints !== Infinity) {
						attacker.die();
					}

				}

			};

			/**
			* Updates the targeting reticle position based on mouse input
			* @return {void}
			*/
			proto.updateTargetReticle = function horde_Engine_proto_updateTargetReticle () {

				this.targetReticle.moving = false;

				// Grab the current mouse position as a vector
				var mouseV = new horde.Vector2(this.mouse.mouseX, this.mouse.mouseY);

				// Keep the targeting reticle inside of the play area
				// NOTE: This will need to be updated if the non-blocked map area changes
				var mouseBounds = new horde.Rect(
					32, 64, SCREEN_WIDTH - 64, SCREEN_HEIGHT - 160
				);

				var trp = this.targetReticle.position;

				if (trp.x !== mouseV.x && trp.y !== mouseV.y) {
					this.targetReticle.moving = true;
					var diff = trp.clone().subtract(mouseV.clone()).abs();
					var speed = horde.clamp((diff.x + diff.y) * 2, 1, 100);
					this.targetReticle.angle += ((speed / 1000) * this.lastElapsed);
					if (this.targetReticle.angle > (Math.PI * 2)) {
						this.targetReticle.angle = 0;
					}
				}

				// Adjust the X position
				if (mouseV.x < mouseBounds.left) {
					trp.x = mouseBounds.left;
				} else if (mouseV.x > mouseBounds.left + mouseBounds.width) {
					trp.x = mouseBounds.left + mouseBounds.width;
				} else {
					trp.x = mouseV.x;
				}

				// Adjust the Y position
				if (mouseV.y < mouseBounds.top) {
					trp.y = mouseBounds.top;
				} else if (mouseV.y > mouseBounds.top + mouseBounds.height) {
					trp.y = mouseBounds.top + mouseBounds.height;
				} else {
					trp.y = mouseV.y;
				}

			};

			/**
			* Grabs the data for where to continue the game
			*/
			proto.grabContinueInfo = function horde_Engine_proto_grabContinueInfo () {
				var _this = this;
				this.getData("checkpoint_wave", function(response) {
					var checkpointWave = response.data;
					if (checkpointWave !== null && typeof checkpointWave !== 'undefined') {
						// Checkpoint data exists
						_this.currentWaveId = (checkpointWave - 1);
						_this.getData("checkpoint_hero", function(response) {
							var checkpointHero = response.data;
							if (checkpointHero !== null) {
								var player = _this.getPlayerObject();
								player.load(checkpointHero);
								// Start the player at full life but ding him for the amount of wounds he had
								player.totalDamageTaken += player.wounds;
								player.wounds = 0;
							}
							_this.continuing = true;
							_this.showTutorial = false;
							_this.state = "intro_cinematic";
						});
					}
				}, true);
			}

			/**
			* Handles game input
			* @return {void}
			*/
			proto.handleInput = function horde_Engine_proto_handleInput () {

				var kb = this.keyboard;
				var keys = horde.Keyboard.Keys;
				var buttons = horde.Mouse.Buttons;
				var mouseV = new horde.Vector2(this.mouse.mouseX, this.mouse.mouseY);
				var newPointerY;
				var usingPointerOptions = false;

				this.leaderboardHover = this.achievementsHover = this.loginHover = false;

				if (this.state == "running") {

					// ESC to skip tutorial.
					if (this.keyboard.isKeyPressed(keys.ESCAPE)) {
						if (this.showTutorial) {
							this.tutorialIndex = TUTORIAL_NUM_TIPS;
							this.nextTutorial(TUTORIAL_NUM_TIPS + 1);
							return;
						}
					}

					// Press "p" to pause.
					if (this.keyboard.isKeyPressed(keys.P) || this.keyboard.isKeyPressed(keys.ESCAPE)) {
						this.togglePause();
						this.keyboard.clearKeys();
						return;
					}

					if (this.paused) {
						usingPointerOptions = true;
					}

					// Toggle sound with "M" for "mute".
					if (this.canMute && this.keyboard.isKeyPressed(77)) {
						horde.sound.toggleMuted();
					}

					// Toggle fullscreen with "F".
					if (this.canFullscreen && this.keyboard.isKeyPressed(70)) {
						this.toggleFullscreen();
					}

					// Toggle keyboard controls with "K".
					if (this.keyboard.isKeyPressed(75)) {
						this.wasdMovesArrowsAttack = !this.wasdMovesArrowsAttack;
					}

					// Code: html5 = HTML5 shield
					/*
					if (this.keyboard.historyMatch(horde.Keyboard.html5Code)) {
						var p = this.getPlayerObject();
						p.spriteY = 992;
					}
					*/

					if (!horde.isDemo()) {

						// Code: meat = Super Meat Boy mode
						if (this.keyboard.historyMatch(horde.Keyboard.meatboyCode)) {
							var p = this.getPlayerObject();
							p.isMeatboy = true;
							p.initMeatBoy();
						}

						// Code: lddqd = god mode
						if (this.keyboard.historyMatch(horde.Keyboard.godModeCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							if (p.hasState(horde.Object.states.INVINCIBLE)) {
								p.removeState(horde.Object.states.INVINCIBLE);
							} else {
								p.addState(horde.Object.states.INVINCIBLE);
							}
							horde.sound.play("code_entered");
						}

						// Code: ldkfa = Infinite fire swords
						if (this.keyboard.historyMatch(horde.Keyboard.allWeaponsCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_fire_sword",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: awesm = Infinite fire knives
						if (this.keyboard.historyMatch(horde.Keyboard.awesmCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_fire_knife",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: ldbomb = Infinite firebombs
						if (this.keyboard.historyMatch(horde.Keyboard.bombCode)) {
							this.keyboard.clearHistory();
							var p = this.getPlayerObject();
							p.cheater = true;
							p.weapons = [{
								type: "h_firebomb",
								count: null
							}];
							horde.sound.play("code_entered");
						}

						// Code: lddebug = toggle debug
						if (this.keyboard.historyMatch(horde.Keyboard.debugCode)) {
							this.keyboard.clearHistory();
							this.debug = !this.debug;
							horde.sound.play("code_entered");
						}

						// Code: ldreset = reset save data
						if (this.keyboard.historyMatch(horde.Keyboard.resetCode)) {
							this.keyboard.clearHistory();
							this.clearData("checkpoint_wave");
							this.clearData("checkpoint_hero");
							this.putData(HIGH_SCORE_KEY, DEFAULT_HIGH_SCORE);
							horde.sound.play("code_entered");
						}

						// Code: cyclops = play as the cyclops
						if (this.keyboard.historyMatch(horde.Keyboard.cyclopsCode)) {
							var p = this.getPlayerObject();

							if (!p.cheater) {
								horde.sound.play("code_entered");
								this.keyboard.clearHistory();

								p.cheater = true;
								p.hitPoints *= 2;
								p.size = new horde.Size(64, 64);
								p.spriteY = 224;
								p.weapons = [
									{type: "e_boulder", count: null}
								];
								p.wounds *= 2;
							}
						}

					} // end isDemo

					if (this.paused) {

						var startY = (this.pointerYStart - 22);

						if (this.verifyQuit) {
							// Nevermind
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 192))
								&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}

							// Quit, seriously
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 192))
								&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}
						} else {
							// Resume
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
								&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}

							// Quit
							if (
								(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
								&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
							) {
								if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
								if (this.mouse.isButtonDown(buttons.LEFT)) {
									this.keyboard.keyStates[keys.SPACE] = true;
								}
							}
						}

						if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

							kb.clearKey(keys.ENTER);
							kb.clearKey(keys.SPACE);
							this.mouse.clearButtons();

							switch (this.pointerY) {
								case 0: // Resume
									this.togglePause();
									break;
								case 1: // Quit
									horde.sound.play("select_pointer");
									if (this.verifyQuit) {
										this.verifyQuit = false;
										this.togglePause();
										var p = this.getPlayerObject();
										p.wound(100);
									} else {
										this.pointerY = 0;
										this.verifyQuit = true;
									}
									break;
							}

						}
					}

				}

				if (this.state === "title") {

					usingPointerOptions = true;

					// Konami code! Hit Points *= 3
					if (!this.konamiEntered && this.keyboard.historyMatch(horde.Keyboard.konamiCode)) {
						horde.sound.play("code_entered");
						this.konamiEntered = true;
						var p = this.getPlayerObject();
						p.cheater = true;
						p.hitPoints *= 3;
					}

					// Accept hover/click with mouse on title screen options [#102]
					var startX = (POINTER_X - 40);
					var stopX = (POINTER_X + 130);
					var startY = (this.pointerYStart - 22);

					// Buy Now! or Continue
					if (horde.isDemo() || this.canContinue()) {
						if (
							(mouseV.x >= startX && mouseV.x <= stopX)
							&& (mouseV.y >= startY && mouseV.y < (startY + 20))
						) {
							if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
							if (this.mouse.isButtonDown(buttons.LEFT)) {
								this.keyboard.keyStates[keys.SPACE] = true;
							}
						}
					}

					// New game
					startY += POINTER_HEIGHT;
					if (
						(mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Credits
					startY += POINTER_HEIGHT;
					if (
						(mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 2) newPointerY = 2;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Clay.io: High Scores
					startY = 444; // 444px from top
					if (
						(mouseV.x >= POINTER_X - 50 && mouseV.x <= POINTER_X + 50)
						&& (mouseV.y >= startY && mouseV.y < (startY + 18)) // 18 = height of button
					) {
						this.leaderboardHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.leaderboardShowFlag) {
								this.leaderboardShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								this.showLeaderboard();
								var _this = this;
								setTimeout(function() {
									_this.leaderboardShowFlag = false;
								}, 1000);
							}
						}
					}
					/* // Clay.io: Achievements List
					if (
						(mouseV.x >= POINTER_X + 50 && mouseV.x <= POINTER_X + 150)
						&& (mouseV.y >= startY && mouseV.y < (startY + 20)) // 20 = height of button
					) {
						this.achievementsHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.achievementsShowFlag) {
								this.achievementsShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								Clay.Achievement.showAll();
								var _this = this;
								setTimeout(function() {
									_this.achievementsShowFlag = false;
								}, 1000);
							}
						}
					}
					// Clay.io: Login
					startY += 20;
					if (
						!this.loggedIn
						&& (mouseV.x >= startX && mouseV.x <= stopX)
						&& (mouseV.y >= startY && mouseV.y < (startY + 18)) // 18 = height of button
					) {
						this.loginHover = true;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							if(!this.loginShowFlag) {
								this.loginShowFlag = true; // So the LB only shows once (with a 1 second 'cooldown')
								Clay.Player.login();
								var _this = this;
								setTimeout(function() {
									_this.loginShowFlag = false;
								}, 1000);
							}
						}
					}
			*/
					if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

						horde.sound.play("select_pointer");
						kb.clearKey(keys.ENTER);
						kb.clearKey(keys.SPACE);
						this.mouse.clearButtons();

						switch (this.pointerY) {
							case 0:
								if (horde.isDemo()) {
									// Buy Now!
									location.href = URL_STORE;
								} else {
									// Continue
									this.grabContinueInfo();
								}
								break;
							case 1: // New game
								this.continuing = false;
								this.showTutorial = !this.touchMove;
								this.state = "intro_cinematic";
								break;
							case 2: // Credits
								this.state = "intro_cinematic";
								break;
						}

					}

				}

				if (this.state == "buy_now") {

					usingPointerOptions = true;

					var startY = (this.pointerYStart - 22);

					// Buy Now!!
					if (
						(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
						&& (mouseV.y > startY && mouseV.y < (startY + (POINTER_HEIGHT - 1)))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 0) newPointerY = 0;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					// Maybe later
					if (
						(mouseV.x >= POINTER_X && mouseV.x <= (POINTER_X + 106))
						&& (mouseV.y > (startY + POINTER_HEIGHT) && mouseV.y < ((startY + POINTER_HEIGHT) + 36))
					) {
						if (this.mouse.hasMoved && this.pointerY !== 1) newPointerY = 1;
						if (this.mouse.isButtonDown(buttons.LEFT)) {
							this.keyboard.keyStates[keys.SPACE] = true;
						}
					}

					if (kb.isKeyPressed(keys.ENTER) || kb.isKeyPressed(keys.SPACE)) {

						kb.clearKey(keys.ENTER);
						kb.clearKey(keys.SPACE);
						this.mouse.clearButtons();

						horde.sound.play("select_pointer");

						switch (this.pointerY) {
							case 0: // Buy Now!!
								location.href = URL_STORE;
								break;
							case 1: // Maybe later
								horde.sound.stop("victory");
								this.initGame();
								break;
						}

					}

				}

				if (
					(this.state === "credits")
				) {
					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						kb.clearKeys();
						this.mouse.clearButtons();
						this.state = "title";
					}
				}

				if (this.state === "intro_cinematic") {
					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						kb.clearKeys();
						this.mouse.clearButtons();
						this.state = "running";
						var player = this.getPlayerObject();
						this.woundsTo = player.wounds;
						this.currentMusic = "normal_battle_music";
						horde.sound.play(this.currentMusic);
					}
				}

				if (usingPointerOptions) {

					if (
						this.keyboard.isKeyPressed(keys.W)
						|| this.keyboard.isKeyPressed(keys.UP)
					) {
						this.keyboard.keyStates[keys.W] = false;
						this.keyboard.keyStates[keys.UP] = false;
						this.pointerY--;
						if (this.pointerY < this.pointerOptionsStart) this.pointerY = this.maxPointerY;
						horde.sound.play("move_pointer");
					}
					if (
						this.keyboard.isKeyPressed(keys.S)
						|| this.keyboard.isKeyPressed(keys.DOWN)
					) {
						this.keyboard.keyStates[keys.S] = false;
						this.keyboard.keyStates[keys.DOWN] = false;
						this.pointerY++;
						if (this.pointerY > this.maxPointerY) this.pointerY = this.pointerOptionsStart;
						horde.sound.play("move_pointer");
					}

					this.keyboard.storeKeyStates();

					if (newPointerY !== undefined) {
						horde.sound.play("move_pointer");
						this.pointerY = newPointerY;
					}

				}

				if (this.state === "running") {
					var player = this.getPlayerObject();

					if (this.paused || player.hasState(horde.Object.states.DYING)) {
						this.keyboard.storeKeyStates();
						return;
					}

					if (!this.touchMove) {
						this.updateTargetReticle();
					} else {
						this.targetReticle.angle += (((Math.PI * 2) / 5000) * this.lastElapsed);
						if (this.targetReticle.angle > (Math.PI * 2)) {
							this.targetReticle.angle = 0;
						}
						if (
							this.mouse.wasButtonClicked(buttons.LEFT)
							|| this.mouse.isButtonDown(buttons.LEFT)
						) {
							var mouseBounds = new horde.Rect(
								48, 80, SCREEN_WIDTH - 96, SCREEN_HEIGHT - 192
							);
							var trp = this.targetReticle.position;
							// Adjust the X position
							if (mouseV.x < mouseBounds.left) {
								trp.x = mouseBounds.left;
							} else if (mouseV.x > mouseBounds.left + mouseBounds.width) {
								trp.x = mouseBounds.left + mouseBounds.width;
							} else {
								trp.x = mouseV.x;
							}
							// Adjust the Y position
							if (mouseV.y < mouseBounds.top) {
								trp.y = mouseBounds.top;
							} else if (mouseV.y > mouseBounds.top + mouseBounds.height) {
								trp.y = mouseBounds.top + mouseBounds.height;
							} else {
								trp.y = mouseV.y;
							}
						}
					}

					var move = new horde.Vector2();
					var shoot = new horde.Vector2();

					if (this.touchMove) {

						// Auto Target
						var hostile = this.getNearestHostile(player);
						if (hostile !== null) {
							shoot = hostile.boundingBox().center().subtract(
								player.boundingBox().center()
							).normalize();
						}

						// Move towards reticle
						move = this.targetReticle.position.clone().subtract(
							player.boundingBox().center()
						).normalize();
						var distance = this.targetReticle.position.clone().subtract(
							player.boundingBox().center()
						).magnitude();
						if (distance < 3) {
							move.zero();
						}

					} else {

						if (this.wasdMovesArrowsAttack) {
							var controls = {
								moveUp: keys.W,
								moveLeft: keys.A,
								moveDown: keys.S,
								moveRight: keys.D,
								attackUp: keys.UP,
								attackDown: keys.DOWN,
								attackLeft: keys.LEFT,
								attackRight: keys.RIGHT
							};
						} else {
							var controls = {
								moveUp: keys.UP,
								moveDown: keys.DOWN,
								moveLeft: keys.LEFT,
								moveRight: keys.RIGHT,
								attackUp: keys.W,
								attackLeft: keys.A,
								attackDown: keys.S,
								attackRight: keys.D
							};
						}

						// Moving
						if (kb.isKeyDown(controls.moveUp)) {
							move.y = -1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveLeft)) {
							move.x = -1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveDown)) {
							move.y = 1;
							this.nextTutorial(1);
						}
						if (kb.isKeyDown(controls.moveRight)) {
							move.x = 1;
							this.nextTutorial(1);
						}

						// Shooting
						if (kb.isKeyDown(controls.attackUp)) {
							shoot.y = -1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackDown)) {
							shoot.y = 1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackLeft)) {
							shoot.x = -1;
							this.nextTutorial(2);
						}
						if (kb.isKeyDown(controls.attackRight)) {
							shoot.x = 1;
							this.nextTutorial(2);
						}

					}

					// Move the player
					player.stopMoving();
					if ((move.x !== 0) || (move.y !== 0)) {
						player.setDirection(move);
					}

					if (this.mouse.wasButtonClicked(buttons.LEFT)) {
						if (
							this.showTutorial
							&& (mouseV.y <= (TUTORIAL_HEIGHT + this.tutorialY))
						) {
							// Dismiss tutorial
							this.tutorialIndex = TUTORIAL_NUM_TIPS;
							this.nextTutorial(TUTORIAL_NUM_TIPS + 1);
							this.mouse.clearButtons();
						} else if (
							mouseV.x >= 604
							&& mouseV.x <= 636
							&& mouseV.y >= 442
							&& mouseV.y <= 475
						) {
							if (this.canFullscreen) {
								this.toggleFullscreen();
								this.mouse.clearButtons();
							} else {
								this.togglePause();
							}
						} else if (
							this.canMute
							&& ((mouseV.x >= 570) && (mouseV.x <= 602))
							&& ((mouseV.y >= 442) && (mouseV.y <= 484))
						) {
							// Toggle mute
							horde.sound.toggleMuted();
							this.mouse.clearButtons();
						}
					}

					if (this.mouse.isButtonDown(buttons.LEFT) && !this.touchMove) {
						var v = this.targetReticle.position.clone().subtract(player.boundingBox().center()).normalize();
						this.objectAttack(player, v);
						this.heroFiring = true;
						this.heroFiringDirection = v;
						this.nextTutorial(4);
						this.showReticle = false;
					} else if (shoot.x !== 0 || shoot.y !== 0) {
						this.objectAttack(player, shoot);
						this.heroFiring = true;
						this.heroFiringDirection = shoot;
					} else {
						this.heroFiring = false;
						this.heroFiringDirection = null;
					}

					this.keyboard.storeKeyStates();
					this.mouse.storeButtonStates();
				}

			};

			proto.getNearestHostile = function (object) {
				var nearest = {
					obj: null,
					distance: Infinity
				};
				for (var id in this.objects) {
					var o = this.objects[id];
					if (
						o.team != object.team
						&& (o.role == "monster" || o.role == "projectile")
						&& o.hitPoints !== Infinity
						&& this.isAlive(o.id)
						&& !(o.hasState(horde.Object.states.INVINCIBLE) || o.hasState(horde.Object.states.INVISIBLE))
					) {
						var distance = object.boundingBox().center().subtract(
							o.boundingBox().center()
						).magnitude();
						if (distance < nearest.distance) {
							nearest.obj = o;
							nearest.distance = distance;
						}
					}
				}
				if (nearest.obj === null) {
					return null;
				} else {
					return nearest.obj;
				}
			};

			proto.objectAttack = function (object, v) {

				if (!v) {
					v = object.facing;
				}

				var weaponType = object.fireWeapon();
				if (weaponType === false) {
					return;
				}

				var weaponDef = horde.objectTypes[weaponType];

				switch (weaponType) {

					case "e_minotaur_trident":
						var h = v.heading();
						for (var x = -0.5; x <= 0.5; x += 0.5) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h + x)
							);
						}
						object.shotsFired += 3;
						break;

					// Shoot 2 knives in a spread pattern
					case "h_knife":
					case "h_fire_knife":
						var h = v.heading();
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.1
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.1
						));
						object.shotsFired += 2;
						break;

					// Spread fire shotgun style
					case "e_fireball_green":
						for (var x = -0.25; x <= 0.25; x += 0.25) {
							var h = v.heading();
							h += (x + (horde.randomRange(-1, 1) / 10));
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						object.shotsFired += 3;
						break;

					case "h_fireball":
						var h = v.heading();
						var vh = horde.Vector2.fromHeading(h);

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(horde.Vector2.fromHeading(h - (Math.PI / 2)).scale(16));
						o.position.add(vh.clone().scale(16));

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(vh.clone().scale(32));

						var id = this.spawnObject(object, weaponType, vh.clone());
						var o = this.objects[id];
						o.position.add(horde.Vector2.fromHeading(h + (Math.PI / 2)).scale(16));
						o.position.add(vh.clone().scale(16));
						object.shotsFired += 3;
						break;

					case "h_firebomb":
						var rv = this.targetReticle.position.clone();
						var len = (Math.PI * 2);
						var step = (len / 20);

						for (var h = 0; h < len; h += step) {
							var o = horde.makeObject("h_fireball");
							o.position.x = rv.x - 16;
							o.position.y = rv.y - 16;
							o.setDirection(horde.Vector2.fromHeading(h));
							o.ownerId = object.id;
							o.team = object.team;
							this.addObject(o);
							object.shotsFired += 1;
						}
						break;

					// Shoot 5 firebursts out in a spread pattern
					/*
					case "h_fireburst":
						var h = v.heading();
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.4
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h - 0.2
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.2
						));
						this.spawnObject(object, weaponType, horde.Vector2.fromHeading(
							h + 0.4
						));
						object.shotsFired += 5;
						break;
						*/

					case "e_ring_fire":
						var len = (Math.PI * 2);
						var step = (len / 10);
						var seed = (step / 2);
						for (var h = seed; h < len + seed; h += step) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						break;

						case "e_ring_fire_dopp":
							var len = (Math.PI * 2);
							var step = (len / 10);
							for (var h = 0; h < len; h += step) {
								this.spawnObject(
									object,
									weaponType,
									horde.Vector2.fromHeading(h)
								);
							}
							break;

					// Spawn in a circle around the object
					case "e_bouncing_boulder":
						var len = (Math.PI * 2);
						var step = (len / 8);
						for (var h = 0; h < len; h += step) {
							this.spawnObject(
								object,
								weaponType,
								horde.Vector2.fromHeading(h)
							);
						}
						break;

					// Shoot one instance of the weapon
					default:
						this.spawnObject(object, weaponType, v);
						object.shotsFired++;
						break;

				}

				// Increment shots per weapon counter
				if (!object.shotsPerWeapon[weaponType]) {
					object.shotsPerWeapon[weaponType] = 0;
				}
				object.shotsPerWeapon[weaponType]++;

				// Determine what sound (if any) to play
				// Attacking sound on weapon type > attacking sound on object performing attack
				var sound = null;
				if (weaponDef.soundAttacks) {
					sound = weaponDef.soundAttacks;
				} else if (object.soundAttacks) {
					sound = object.soundAttacks;
				}
				if (sound !== null) {
					horde.sound.play(sound);
				}

			};

			proto.render = function horde_Engine_proto_render () {

				var ctx = this.canvases["display"].getContext("2d");

				switch (this.state) {

					// Company Logo
					case "intro":
						this.drawLogo(ctx);
						break;

					// Title Screen
					case "title":
						this.drawTitle(ctx);
						this.drawPointer(ctx);
						this.drawTitlePointerOptions(ctx);
						break;

					// Credits
					case "credits":
						this.drawTitle(ctx);
						this.drawCredits(ctx);
						break;

					case "intro_cinematic":
						this.drawIntroCinematic(ctx);
						break;

					// The game!
					case "running":
						this.drawFloor(ctx);
						if (!this.wonGame) {
							this.drawTargetReticle(ctx);
						}
						this.drawObjects(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						this.drawWeaponPickup(ctx);
						this.drawCoinPickup(ctx);
						this.drawWaveText(ctx);
						this.drawUI(ctx);
						if (this.paused) {
							this.drawPaused(ctx);
							this.drawPointer(ctx);
							this.drawPausedPointerOptions(ctx);
						}
						if (this.showTutorial) {
							this.drawTutorial(ctx);
						}
						break;

					case "game_over":
						this.drawGameOver(ctx);
						break;

					case "buy_now":
						this.drawBuyNow(ctx);
						this.drawPointer(ctx);
						break;

				}

				if (this.debug === true) {
					this.drawDebugInfo(ctx);
				}

			};

			proto.drawWeaponPickup = function horde_Engine_proto_drawWeaponPickup (ctx) {
				var w = this.weaponPickup;
				if (w.state === "on") {
					var type = horde.makeObject(w.type);
					ctx.save();
					ctx.translate(
						w.position.x + (type.size.width / 2),
						w.position.y + (type.size.height / 2)
					);
					ctx.globalAlpha = w.alpha;
					// Draw scroll
					ctx.drawImage(
						this.images.getImage("objects"),
						128, 192, 48, 48,
						-22 * w.scale, -20 * w.scale, 48 * w.scale, 48 * w.scale
					);
					// Draw weapon
					ctx.drawImage(
						this.images.getImage(type.spriteSheet),
						type.spriteX, type.spriteY + 1, type.size.width - 1, type.size.height - 1,
						-((type.size.width / 2) * w.scale), -((type.size.height / 2) * w.scale),
						type.size.width * w.scale, type.size.height * w.scale
					);
					ctx.restore();
				}
			};

			proto.drawCoinPickup = function horde_Engine_proto_drawCoinPickup (ctx) {
				var w = this.coinPickup;
				if (w.state === "on") {
					var meta = this.getCoinFontData(w.amount);
					var text = ("+" + w.amount);

					ctx.save();
					ctx.fillStyle = meta.fillStyle;
					ctx.font = ("Bold " + meta.size + "px MedievalSharp");
					ctx.lineWidth = 2;
					ctx.strokeStyle = COLOR_BLACK;
					ctx.textAlign = "center";
					ctx.textBaseline = "top";
					ctx.translate(
						w.position.x,
						w.position.y
					);
					ctx.globalAlpha = w.alpha;
					ctx.strokeText(text, 0, 0);
					ctx.fillText(text, 0, 0);
					ctx.restore();
				}
			};

			proto.getCoinFontData = function horde_Engine_proto_getCoinFontData (amount) {
				if (amount == 100) {
					return {
						fillStyle: "rgb(255, 203, 5)",
						size: 24
					};
				} else if (amount == 500) {
					return {
						fillStyle: "rgb(255, 244, 96)",
						size: 36
					};
				} else {
					return {
						fillStyle: "rgb(255, 248, 160)",
						size: 50
					};
				}
			};

			proto.drawWaveText = function horde_Engine_proto_drawWaveText (ctx) {
				// Back out immediately if we shoudn't draw
				if (this.waveText.state == "off") {
					return;
				}

				var size = parseInt(this.waveText.size);
				var width = (this.waveText.width * size);
				var height = WAVE_TEXT_HEIGHT * size;
				var x = (SCREEN_WIDTH/2) - (width/2);
				var y = (SCREEN_HEIGHT/2) - (height/2);

				ctx.save();
				ctx.globalAlpha = this.waveText.alpha;
				ctx.drawImage(
					this.canvases.waveText,
					0, 0, this.waveText.width, WAVE_TEXT_HEIGHT,
					x, y, width, height
				);
				ctx.restore();
			};

			/**
			* Draws the game over screen.
			* @param {object} Canvas 2d context to draw on.
			*/
			proto.drawGameOver = function horde_Engine_proto_drawGameOver (ctx) {

				if (this.goAlphaStep) {
					this.goAlpha += this.goAlphaStep;
					if (this.goAlpha <= 0) {
						this.goAlpha = 0;
						this.goAlphaStep = 0.025;
					}
					if (this.goAlpha >= 1) {
						this.goAlpha = 1;
						this.goAlphaStep = -0.025;
					}
				} else {
					this.goAlphaStep = -0.025;
					this.goAlpha = 1;
				}

				if (!this.gameOverBg) {
/* 					this.drawUI(ctx);
					this.gameOverBg = ctx.getImageData(0, 0, this.view.width, this.view.height); */
				}

				// ctx.putImageData(this.gameOverBg, 0, 0);

				ctx.save();
				ctx.globalAlpha = this.gameOverAlpha;
				if (this.wonGame) {
					ctx.fillStyle = COLOR_BLACK;
				} else {
					ctx.fillStyle = "rgb(215, 25, 32)"; // red
				}
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.restore();

				if (this.gameOverReady === true) {

					if (this.keyboard.isAnyKeyPressed() || this.mouse.isAnyButtonDown()) {
						this.keyboard.clearKeys();
						this.mouse.clearButtons();
						this.statsIndex += 1;
						if (this.statsIndex >= 5) {
							if (horde.isDemo()) {
								this.state = "buy_now";
								this.initOptions();
							} else {
								horde.sound.stop("victory");
								this.initGame();
							}
							return;
						}
					}

					var headerY = 70;

					// Modal
					ctx.drawImage(
						this.preloader.getImage("ui"),
						0, 2322, 564, 404,
						38, 38, 564, 404
					);

					// Game Over
					if (this.wonGame) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2444, 256, 50,
							192, headerY, 256, 50
						);
					} else if (this.gotNewHighScore) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2374, 404, 50,
							119, headerY, 404, 50
						);
					} else {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2324, 218, 50,
							211, headerY, 218, 50
						);
					}

					this.drawObjectStats(this.getPlayerObject(), ctx);

					// Press anything to continue ...
					if (this.statsIndex >= 4) {
						ctx.drawImage(
							this.preloader.getImage("ui"),
							564, 2424, 334, 20,
							153, 404, 334, 20
						);
					}

				}

			};

			proto.drawBuyNow = function horde_Engine_proto_drawBuyNow (ctx) {

				ctx.save();

				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);

				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					370, 0, 564, 404,
					38, 38, 564, 404
				);
				ctx.restore();

				var startY = (this.pointerYStart - 22);
				var spriteX;

				// Buy Now!!
				spriteX = ((this.pointerY == 0) ? 260 : 0);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					spriteX, 2122, 200, 40,
					POINTER_X, startY, 200, 40
				);

				// Maybe later
				spriteX = ((this.pointerY == 1) ? 260 : 0);
				startY += POINTER_HEIGHT;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					spriteX, 2182, 200, 40,
					POINTER_X, startY, 200, 40
				);

			};

			proto.drawObjectStats = function horde_Engine_proto_drawObjectStats (object, ctx) {

				var textX = 350;
				var textHeight = 55;

				ctx.save();
				ctx.font = "Bold 40px MedievalSharp";

				var increment;
				var max = 0;
				var nextTimer = 0;

				var wavesComplete = this.currentWaveId;

				if (this.wonGame) {
					wavesComplete += 1;
				}

				// Waves
				var displayWave = 0;
				if (this.statsIndex === 0) {
					displayWave = this.statsCount;
					max = wavesComplete;
					// Settings for Gold earned:
					increment = 199;
					nextTimer = 10;
				} else {
					displayWave = wavesComplete;
				}
				ctx.fillStyle = "rgb(199, 234, 251)";
				ctx.fillText(displayWave + " x 1000", textX, 182);

				// Gold earned
				var displayGold = 0;
				if (this.statsIndex === 1) {
					displayGold = this.statsCount;
					max = object.gold;
					// Settings for Damage taken:
					increment = 10;
					nextTimer = 10;
				} else if (this.statsIndex > 1) {
					displayGold = object.gold;
				}
				ctx.fillStyle = "rgb(255, 245, 121)";
				ctx.fillText(displayGold, textX, (180 + textHeight));

				// Damage taken
				var displayDamage = 0;
				if (this.statsIndex === 2) {
					displayDamage = this.statsCount;
					max = object.totalDamageTaken;
					// Settings for Total score:
					increment = 299;
					nextTimer = 5;
				} else if (this.statsIndex > 2) {
					displayDamage = object.totalDamageTaken;
				}
				ctx.fillStyle = "rgb(237, 28, 36)";
				ctx.fillText("-" + displayDamage + " x 10", textX, 180 + (textHeight * 2));

				// Total score
				var displayScore = "";
				var totalScore = this.getTotalScore();
				if (this.statsIndex === 3) {
					displayScore = this.statsCount;
					max = totalScore;
				} else if (this.statsIndex > 3) {
					displayScore = totalScore;
				}
				ctx.fillStyle = "rgb(250, 166, 26)";
				ctx.fillText(displayScore, textX, (184 + (textHeight * 3)));

				if (this.statsCount >= max) {
					this.statsCount = 0;
					this.statsIncrement = increment;
					this.statsIndex += 1;
					this.statsTimer.start(nextTimer);
				}

				ctx.restore();

			};

			/**
			* Calculates the player's total score
			*/
			proto.getTotalScore = function () {

				var player = this.getPlayerObject();
				var wavesComplete = this.currentWaveId;

				if (this.wonGame) {
					wavesComplete += 1;
				}

				var score = (wavesComplete * 1000);
				score += player.gold;
				score -= (player.totalDamageTaken * 10);

				if (player.cheater === true) {
					score /= 2;
				}

				if (score < 0) {
					score = 0;
				}

				return score;
			};

			proto.drawLogo = function horde_Engine_proto_drawLogo (ctx) {

				// Clear the screen
				ctx.save();
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.restore();

				// Draw the logo
				if (this.logoAlpha > 0) {
					ctx.save();
					ctx.globalAlpha = this.logoAlpha;
					ctx.drawImage(
						this.preloader.getImage("ui"),
						0, 0, 370, 430,
						160, 0, 370, 430
					);
					ctx.restore();
				}

			};

			proto.drawFloor = function horde_Engine_proto_drawFloor (ctx) {
				var offset = this.getArenaOffset();
				ctx.drawImage(
					this.images.getImage("arena"),
					(offset + 32), 480, 576, 386,
					32, 0, 576, 386
				);
			};

			proto.drawWalls = function horde_Engine_proto_drawWalls (ctx) {
				var offset = this.getArenaOffset();
				ctx.drawImage(
					this.images.getImage("arena"),
					offset, 0, SCREEN_WIDTH, SCREEN_HEIGHT,
					0, 0, this.view.width, this.view.height
				);
			};

			proto.getArenaOffset = function horde_Engine_proto_getArenaOffset () {
			var waveId = ((this.currentWaveId >= 0) ? this.currentWaveId : 0);
				return (SCREEN_WIDTH * Math.floor(waveId / 10));
			};

			proto.drawPaused = function horde_Engine_proto_drawPaused (ctx) {

				ctx.save();

				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);

				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 1718, 564, 404,
					38, 38, 564, 404
				);

				var player = this.getPlayerObject();

				ctx.font = "Bold 36px MedievalSharp";
				ctx.textAlign = "left";

				ctx.fillStyle = "rgb(237, 28, 36)";
				ctx.fillText(player.kills, 390, 164);

				ctx.fillStyle = "rgb(145, 102, 0)";
				ctx.fillText(player.meatEaten, 390, 216);

				ctx.fillStyle = "rgb(199, 234, 251)";
				ctx.fillText(player.shotsFired, 390, 270);

				ctx.fillStyle = "rgb(250, 166, 26)";
				ctx.fillText(this.getAccuracy(player) + "%", 390, 324);

				ctx.restore();

			};

			proto.getAccuracy = function horde_Engine_proto_getAccuracy (player) {
				if (player.shotsFired === 0) return 0;

				return Math.round((player.shotsLanded / player.shotsFired) * 100);
			};

			proto.drawTutorial = function horde_Engine_proto_drawTutorial (ctx) {

				if (this.paused) return;

				ctx.save();
				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, this.tutorialY, this.view.width, TUTORIAL_HEIGHT);

				ctx.globalAlpha = 1;
				ctx.font = "Bold 22px MedievalSharp";
				ctx.textAlign = "center";

				var tips = [
					"MOVE with the WASD keys.",
					"ATTACK with the ARROW keys.",
					"Or use the MOUSE to AIM with the target reticle.",
					"ATTACK by HOLDING DOWN the LEFT MOUSE BUTTON.",
					"KILL MONSTERS and COLLECT GOLD to raise your score!"
				];

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(tips[this.tutorialIndex], 322, (this.tutorialY + 36));

				ctx.fillStyle = "rgb(230, 230, 230)";
				ctx.fillText(tips[this.tutorialIndex], 320, (this.tutorialY + 34));

				ctx.font = "20px MedievalSharp";

				var pressHere = "Press here or ESC to skip";
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(pressHere, 322, (this.tutorialY + 62));

				ctx.fillStyle = "rgb(118, 151, 183)";
				ctx.fillText(pressHere, 320, (this.tutorialY + 60));
				ctx.restore();

			};

			/**
			* Returns the draw order of objects based on their Y position + height
			* @return {array} Array of object IDs in the order that they should be drawn
			*/
			proto.getObjectDrawOrder = function horde_Engine_proto_getObjectDrawOrder () {
				var drawOrder = [];
				for (var id in this.objects) {
					var obj = this.objects[id];
					drawOrder.push({
						id: obj.id,
						drawIndex: obj.drawIndex,
						y: obj.position.y + obj.size.height
					});
				}
				drawOrder.sort(function (a, b) {
					if (a.drawIndex === b.drawIndex) {
						return (a.y - b.y);
					} else {
						return (a.drawIndex - b.drawIndex);
					}
				});
				return drawOrder;
			};

			proto.drawObject = function horde_Engine_proto_drawObject (ctx, o) {

				if (o.role === "hero" && this.heroFiring) {
					var s = o.getSpriteXY(this.heroFiringDirection);
				} else {
					var s = o.getSpriteXY();
				}

				/*
				// Invisible testing hack
				if (o.hasState(horde.Object.states.INVISIBLE)) {
					ctx.save();
					ctx.fillStyle = "rgb(0, 0, 255)";
					ctx.fillRect(
						o.position.x,
						o.position.y,
						o.size.width,
						o.size.height
					);
					ctx.restore();
					return;
				}
				*/

				if (o.alpha <= 0 || o.hasState(horde.Object.states.INVISIBLE)) {
					return;
				}

				ctx.save();

				ctx.translate(
					o.position.x + o.size.width / 2,
					o.position.y + o.size.height / 2
				);

				if (o.angle !== 0) {
					ctx.rotate(o.angle * Math.PI / 180);
				}

				if (o.alpha !== 1) {
					ctx.globalAlpha = o.alpha;
				}

				if (o.role === "powerup_weapon") {
					// Draw a scroll behind the weapon
					ctx.drawImage(
						this.images.getImage("objects"),
						128, 192, 48, 48, -22, -20, 48, 48
					);
				}

				ctx.drawImage(
					this.images.getImage(o.spriteSheet),
					s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
					-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height
				);

				if (o.spriteYOverlay) {
					ctx.save();
					var alpha = (1 - (o.wounds / o.hitPoints)) + 0.3;
					ctx.globalAlpha = alpha;
					ctx.drawImage(
						this.images.getImage(o.spriteSheet),
						s.x, o.spriteYOverlay + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height
					);
					ctx.restore();
				}

				// Boss pain!
				if (
					(o.role === "monster")
					&& o.badass
					&& o.hasState(horde.Object.states.HURTING)
				) {
					this.drawImageOverlay(
						ctx, this.images.getImage(o.spriteSheet),
						s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height,
						"rgba(186, 51, 35, 0.6)"
					);
				}

				// Message indestructible enemy projectiles
				if (this.isBadassWeapon(o) && o.glow) {
					this.drawImageOverlay(
						ctx, this.images.getImage(o.spriteSheet),
						s.x, s.y + 1, o.size.width - 1, o.size.height - 1,
						-(o.size.width / 2), -(o.size.height / 2), o.size.width, o.size.height,
						"rgba(255, 247, 143, " + o.glow.alpha + ")"
					);
				}

				// HP bar
				if (
					(this.debug && (o.role === "monster"))
					|| (o.badass && !o.hasState(horde.Object.states.DYING))
				) {
					var hpWidth = (o.size.width - 2);
					var hpHeight = 8;
					var width = (hpWidth - Math.round((hpWidth * o.wounds) / o.hitPoints));

					ctx.fillStyle = COLOR_WHITE;
					ctx.fillRect(-(o.size.width / 2), (o.size.height / 2), o.size.width, hpHeight);
					ctx.fillStyle = COLOR_BLACK;
					ctx.fillRect(-(o.size.width / 2) + 1, ((o.size.height / 2) + 1), (o.size.width - 2), (hpHeight - 2));
					ctx.fillStyle = this.getBarColor(o.hitPoints, (o.hitPoints - o.wounds));
					ctx.fillRect(-(o.size.width / 2) + 1, ((o.size.height / 2) + 1), width, (hpHeight - 2));
				}

				ctx.restore();

			};

			proto.isBadassWeapon = function horde_Engine_proto_isBadassWeapon (o) {
				return (
					(o.role === "projectile")
					&& (o.hitPoints === Infinity)
					&& (o.team === 1)
					&& (o.type != "e_fireball")
					&& (o.type != "e_static_blue_fire")
					&& (o.type != "e_static_green_fire")
				);
			}

			proto.drawObjects = function (ctx) {
				var drawOrder = this.getObjectDrawOrder();
				for (var x in drawOrder) {
					var o = this.objects[drawOrder[x].id];
					this.drawObject(ctx, o);
				}
			};

			/**
			* Draws the targeting reticle to the screen
			* @param {object} Canvas 2d context to draw on
			* @return {void}
			*/
			proto.drawTargetReticle = function horde_Engine_proto_drawTargetReticle (ctx) {

				if (!this.showReticle) return;

				ctx.save();
				ctx.globalAlpha = 0.75;
				ctx.translate(this.targetReticle.position.x, this.targetReticle.position.y);
				ctx.rotate(this.targetReticle.angle);
				ctx.drawImage(
					this.images.getImage("objects"),
					256, 192, 64, 64,
					-32, -32, 64, 64
				);
				ctx.restore();
			};

			/**
			* Draws an overlay over an image in its exact shape (exact pixels)
			* @param too many, shut up :(
			* @return {void}
			*/
			proto.drawImageOverlay = function horde_Engine_proto_drawImageOverlay (
				ctx, image,
				spriteX, spriteY,
				spriteWidth, spriteHeight,
				destX, destY,
				destWidth, destHeight,
				fillStyle
			) {

				var buffer = this.canvases.buffer.getContext("2d");
				buffer.save();
				buffer.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

				buffer.drawImage(
					image,
					spriteX, spriteY, spriteWidth, spriteHeight,
					0, 0,
					destWidth, destHeight
				);
				buffer.globalCompositeOperation = "source-in";
				buffer.fillStyle = fillStyle;
				buffer.fillRect(0, 0, destWidth, destHeight);
				buffer.restore();

				ctx.drawImage(
					this.canvases.buffer,
					0, 0,
					destWidth, destHeight,
					destX, destY,
					destWidth, destHeight
				);

			};

			/**
			* Draws the game UI
			* @param {object} Canvas 2d context to draw on
			* @return {void}
			*/
			proto.drawUI = function horde_Engine_proto_drawUI (ctx) {

				var o = this.getPlayerObject();
				var weaponInfo = o.getWeaponInfo();
				var w = horde.objectTypes[weaponInfo.type];
				var wCount = (weaponInfo.count ? weaponInfo.count : "");

				// Weapon Icon
				ctx.drawImage(
					this.images.getImage("objects"),
					w.spriteX, w.spriteY, 32, 32,
					4, 412, 32, 32
				);

				// Score icon
				ctx.drawImage(
					this.images.getImage("objects"),
					32, 32, 32, 32,
					4, 442, 32, 32
				);

				// Draw gold amount and weapon count
				ctx.save();
				ctx.textAlign = "left";
				ctx.font = "Bold 32px MedievalSharp";

				ctx.globalAlpha = 0.75;
				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(wCount, 48, 444);
				ctx.fillText(this.scoreCount, 48, 474);

				ctx.globalAlpha = 1;
				ctx.fillStyle = COLOR_WHITE;
				ctx.fillText(wCount, 46, 440);
				ctx.fillText(this.scoreCount, 46, 472);
				ctx.restore();

				if (o.hitPoints > 1) {

					// Health bar
					var bar = {
						width: 280,
						height: 24,
						x: 212,
						y: 432
					};

					var width1 = (bar.width - Math.round((bar.width * o.wounds) / o.hitPoints));
					var width2 = (bar.width - Math.round((bar.width * this.woundsTo) / o.hitPoints));

					if (this.woundsTo < o.wounds) {
						var width = width1;
						var toWidth = width2;
					} else {
						var width = width2;
						var toWidth = width1;
					}

					// Outside border
					ctx.save();
					ctx.fillStyle = COLOR_WHITE;
					ctx.fillRect(bar.x - 2, bar.y - 2, bar.width + 2, bar.height + 4);
					ctx.fillRect(bar.x + bar.width, bar.y, 2, bar.height);
					ctx.fillStyle = COLOR_BLACK;
					ctx.fillRect(bar.x, bar.y, bar.width, bar.height);

					// The bar itself
					ctx.fillStyle = this.getBarColor(o.hitPoints, (o.hitPoints - o.wounds));
					ctx.globalAlpha = 0.4;

					ctx.fillRect(bar.x, bar.y, toWidth, bar.height);

					ctx.fillRect(bar.x, bar.y, width, bar.height);
					ctx.fillRect(bar.x, bar.y + 5, width, bar.height - 10);
					ctx.fillRect(bar.x, bar.y + 10, width, bar.height - 20);
					ctx.restore();

					// Heart icon
					var percentage = (((o.hitPoints - o.wounds) / o.hitPoints) * 100);
					var spriteX = 352;
					if (percentage > 50) {
						spriteX = 224;
					} else if (percentage > 25) {
						spriteX = 288;
					}
					ctx.drawImage(
						this.images.getImage("objects"),
						spriteX, 64, 42, 42,
						(bar.x - 32), 424, 42, 42
					);

				}

				// Mute button
				if (this.canMute) {
					ctx.drawImage(
						this.preloader.getImage("ui"),
						(horde.sound.isMuted() ? 692 : 660), 910, 32, 32,
						570, 442, 32, 32
					);
				}

				// Fullscreen toggle icon
				if (this.canFullscreen) {
					var spriteX = (this.enableFullscreen ? 596 : 564);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						spriteX, 910, 32, 32,
						604, 442, 32, 32
					);
				} else {
					ctx.drawImage(
						this.preloader.getImage("ui"),
						596+32, 910, 32, 32,
						604, 442, 32, 32
					);
				}

			};

			/**
			* Draws the title screen.
			* @param {object} Canvas 2d context to draw on.
			* @return {void}
			*/
			proto.drawTitle = function horde_Engine_proto_drawTitle (ctx) {

				var grey = "rgb(230, 230, 230)";

				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 430, 640, 480,
					0, 0, 640, 480
				);

				var highScore = ("High Score: " + this.getData(HIGH_SCORE_KEY));

				ctx.save();
				ctx.font = "Bold 24px MedievalSharp";
				ctx.textAlign = "center";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(highScore, 322, 444);

				ctx.fillStyle = grey;
				ctx.fillText(highScore, 320, 442);
				ctx.restore();



				// Version
				var version = ("v" + VERSION);
				if (horde.isDemo()) version += " demo";
				ctx.save();
				ctx.font = "Bold 14px Monospace";
				ctx.textAlign = "right";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(version, 638, 480);

				ctx.fillStyle = grey;
				ctx.fillText(version, 636, 478);
				ctx.restore();

				// Copyright text
				var copyright = "Lost Decade Games";
				ctx.save();
				ctx.font = "Bold 14px Monospace";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(copyright, 6, 462);

				ctx.fillStyle = grey;
				ctx.fillText(copyright, 4, 460);
				ctx.restore();

				var copyrightDate = "\u00A9 2010";
				ctx.save();
				ctx.font = "Bold 14px Monospace";

				ctx.fillStyle = COLOR_BLACK;
				ctx.fillText(copyrightDate, 6, 478);

				ctx.fillStyle = grey;
				ctx.fillText(copyrightDate, 4, 476);
				ctx.restore();

			};

			proto.drawPointer = function horde_Engine_proto_drawPointer (ctx) {

				var textY = (this.pointerYStart - 18);
				var x = (POINTER_X - 42);
				var y = (this.pointerYStart + (this.pointerY * POINTER_HEIGHT) - POINTER_HEIGHT);

				ctx.save();
				ctx.drawImage(
					this.images.getImage("objects"),
					320, 192, 36, 26,
					x, y,
					36, 26
				);
				ctx.restore();

			};

			/**
			* @param {Boolean} checkAgain If true, will grab info from Clay again (set when logging in)
			* @return {Boolean} true if the checkpoint is stored
			*/
			proto.canContinue = function (checkAgain) {

				if( this.canContinueVar ) { // already grabbed from Clay.io
					var checkpointWave = this.canContinueVar;
					return checkpointWave;
				}

				if(!this.grabbingContinueVar) {
					this.grabbingContinueVar = true;
					var _this = this;
					Clay.ready(function() {
						var checkpointWave = _this.getData("checkpoint_wave", function(response) {
							_this.canContinueVar = Boolean(response.data);
						});
						Clay.Player.onUserReady( function() {
							_this.canContinue(true); // refresh w/ new data
						} );
					});
				}
				var checkpointWave = this.getData("checkpoint_wave"); // fallback to local data (while the clay data loads);
				return Boolean(checkpointWave);
			};

			proto.drawTitlePointerOptions = function horde_Engine_proto_drawTitlePointerOptions (ctx) {

				var startY = (this.pointerYStart - 22);
				var spriteY;

				if (horde.isDemo()) {
					// Buy now!!
					spriteY = ((this.pointerY == 0) ? 638 : 430);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						800, spriteY, 128, 26,
						POINTER_X, startY, 128, 26
					);
				} else {
					// Continue
					if (this.canContinue()) {
						spriteY = ((this.pointerY == 0) ? 638 : 430);
					} else {
						spriteY = 534;
					}
					ctx.drawImage(
						this.preloader.getImage("ui"),
						640, spriteY, 116, 20,
						POINTER_X, startY, 116, 20
					);
				}

				// New game
				spriteY = ((this.pointerY == 1) ? 664 : 456);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					640, spriteY, 132, 26,
					POINTER_X, (startY + POINTER_HEIGHT), 132, 26
				);

				// Credits
				spriteY = ((this.pointerY == 2) ? 690 : 482);
				ctx.drawImage(
					this.preloader.getImage("ui"),
					640, spriteY, 90, 22,
					POINTER_X, (startY + (POINTER_HEIGHT * 2)), 90, 22
				);

			};

			proto.drawPausedPointerOptions = function horde_Engine_proto_drawPausedPointerOptions (ctx) {

				var startY = (this.pointerYStart - 22);
				var spriteY;

				if (this.verifyQuit) {
					// Nevermind
					spriteY = ((this.pointerY == 0) ? 1932 : 1860);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 158, 26,
						POINTER_X, startY, 158, 26
					);
				} else {
					// Resume
					spriteY = ((this.pointerY == 0) ? 1788 : 1718);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 106, 26,
						POINTER_X, startY, 106, 26
					);
				}

				if (this.verifyQuit) {
					// Quit, seriously
					spriteY = ((this.pointerY == 1) ? 1966 : 1894);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 192, 32,
						POINTER_X, (startY + POINTER_HEIGHT), 196, 32
					);
				} else {
					// Quit
					spriteY = ((this.pointerY == 1) ? 1822 : 1752);
					ctx.drawImage(
						this.preloader.getImage("ui"),
						564, spriteY, 70, 36,
						POINTER_X, (startY + POINTER_HEIGHT), 70, 36
					);
				}

			};

			proto.initOptions = function () {

				switch (this.state) {
					case "title":
						this.pointerYStart = 314;

						if (horde.isDemo() || this.canContinue()) {
							this.pointerY = 0;
							this.pointerOptionsStart = 0;
						} else {
							this.pointerY = 1;
							this.pointerOptionsStart = 1;
						}
						this.maxPointerY = 2;
						break;
					case "running":
						this.pointerYStart = 378;
						this.pointerY = 0;
						this.maxPointerY = 1;
						this.pointerOptionsStart = 0;
						this.verifyQuit = false;
						break;
					case "buy_now":
						this.pointerYStart = 378;
						this.pointerY = 0;
						this.maxPointerY = 1;
						this.pointerOptionsStart = 0;
						break;
				}

			};

			proto.drawCredits = function horde_Engine_proto_drawCredits (ctx) {
				ctx.save();
				ctx.globalAlpha = OVERLAY_ALPHA;
				ctx.fillRect(0, 0, this.view.width, this.view.height);
				ctx.globalAlpha = 1;
				ctx.drawImage(
					this.preloader.getImage("ui"),
					0, 1314, 564, 404,
					38, 38, 564, 404
				);
				ctx.restore();
			};

			proto.drawIntroCinematic = function horde_Engine_proto_drawIntroCinematic (ctx) {

				switch (this.introPhase) {

					case 0:
						if (!this.introFadeOutBg) {
							// this.introFadeOutBg = ctx.getImageData(0, 0, this.view.width, this.view.height);
							this.introFadeAlpha = 0;
						}
						ctx.fillStyle = COLOR_BLACK;
						ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
						ctx.save();
							// ctx.putImageData(this.introFadeOutBg, 0, 0);
						ctx.restore();
						if (this.introFadeAlpha > 0) {
							ctx.save();
							ctx.globalAlpha = this.introFadeAlpha;
							ctx.fillStyle = COLOR_BLACK;
							ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
							ctx.restore();
						}
						break;

					case 1:
						this.drawFloor(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						if (this.introFadeAlpha > 0) {
							ctx.save();
							ctx.globalAlpha = this.introFadeAlpha;
							ctx.fillStyle = COLOR_BLACK;
							ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
							ctx.restore();
						}
						break;

					case 2:
					case 3:
						this.drawFloor(ctx);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;

					case 4:
					case 5:
					case 9:
						this.drawFloor(ctx);
						if (this.introHero) {
							this.drawObject(ctx, this.introHero);
						}
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;

					case 6:
					case 7:
					case 8:
						this.drawFloor(ctx);
						ctx.drawImage(this.images.getImage("characters"),
							20 * 32, 0, 32, 32,
							304, 224, 32, 32
						);
						this.drawFauxGates(ctx);
						this.drawWalls(ctx);
						break;
				}


			};

			/**
			* Draws fake gates for the title screen
			* @param {object} Canvas 2d context
			* @return {void}
			*/
			proto.drawFauxGates = function horde_Engine_proto_drawFauxGates (ctx) {
				for (var g = 0; g < NUM_GATES; g++) {
					var spriteX = 0;
					var spriteY = 192;

					if (g > 0) {
						spriteX = 320;
						spriteY = ((g == 1) ? 288 : 352);
					}

					ctx.drawImage(
						this.images.getImage("objects"),
						spriteX, spriteY, 64, 64,
						(this.gatesX + 96 + (g * 192)), this.gatesY, 64, 64
					);
				}
			};

			/**
			* Draws debugging information to the screen
			* @param {object} Canvas 2d context
			* @return {void}
			*/
			proto.drawDebugInfo = function horde_Engine_proto_drawDebugInfo (ctx) {

				// Semi-transparent bar so we can see the text
				ctx.save();
				ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
				ctx.fillRect(0, 0, this.view.width, 30);
				ctx.restore();

				// Debugging info
				ctx.save();
				ctx.fillStyle = COLOR_WHITE;
				ctx.font = "Bold 20px Monospace";
				ctx.fillText("Elapsed: " + this.lastElapsed, 10, 20);
				ctx.textAlign = "right";
				ctx.fillText(Math.round(1000 / this.lastElapsed) + " FPS", 630, 20);
				ctx.restore();

			};

			/**
			* Fetches some persistent data. Grabs first from Clay.io, falls back to localStorage, and local variable
			* @param {String} key The key of the data to fetch
			* @param {Function} callback Callback function if useClay is set to true (since data isn't immeditely available).
			* 							  The first parameter of this function is an object { success: boolean, data: String }
			* @param {Boolean} forceClay Forces fetch from Clay.io (instead of using local)
			* @return {String} The data (or undefined on failure)
			*/
			proto.getData = function horde_Engine_proto_getData (key, callback, forceClay) {
				// Load in the Clay data if it exists, otherwise fallback to localStorage
				if(callback) {
/* 					if(Clay.isReady && Clay.Player.loggedIn && (forceClay || !horde.localData[key])) {
						var handler = function(response) {
							horde.localData[key] = { value: response.data, times: 0, timeout: null }; // save locally for future reference
							callback(response);
						}
						Clay.Player.fetchUserData(key, handler);
					}
					else if(horde.localData[key]) { // we're already storing the data locally, no need to fetch from Clay
						callback({ data: horde.localData[key].value, usingVar: true });
					}
					else { // Data not stored locally, and can't fetch from Clay
						callback({ data: window.localStorage.getItem(key), usingLocalStorage: true });
						horde.localData[key] = window.localStorage.getItem(key); // save locally for future reference
					}
					return undefined; */
				}
/* 				if (window.localStorage && window.localStorage.getItem) {
					return window.localStorage.getItem(key);
				} */
				return undefined;
			};

			/**
			* Saves some data persistently. Saves to localStorage, a variable, and Clay.io (after 3 seconds)
			* @param {String} key The key of the data to store
			* @param {String} value The data to store
			*/
			proto.putData = function horde_Engine_proto_putData (key, value) {
/* 				if (window.localStorage && window.localStorage.setItem) {
					window.localStorage.setItem(key, value);
				} */
				// Clay.io: Store to Clay.io as well (as primary source of storage, localStorage as backup)
				// We store to Clay.io if new data isn't passed in 3s
				// This is in place so we're not flooding Clay.io with data stores (there is a limit...)
				if(!Clay.isReady)
					return false;

				if(horde.localData[key] && horde.localData[key].timeout) {
					clearTimeout(horde.localData[key].timeout);
					var times = horde.localData[times] + 1; // log how many times the timeout is set, so every 10th, we'll store anyways
				}
				else {
					var times = 0; // first time setting the timeout
				}

				// Store the data locally, and store to Clay after 3 seconds on non-changing data
				( function() {
					var localKey = key;
					var localValue = value;
					var localTimes = times;
					horde.localData[key] = { value: localValue, times: localTimes, timeout: setTimeout(function() {
						Clay.Player.saveUserData(localKey, localValue);
						horde.localData[localKey].timeout = null;
					}, 3000) };
				} )();
			};

			/**
			* Clears some persistent data by key
			* @param {String} key The key of the data to clear
			*/
			proto.clearData = function horde_Engine_proto_clearData (key) {
/* 				if (window.localStorage && window.localStorage.removeItem) {
					window.localStorage.removeItem(key);
				} */
			};

			proto.endGame = function () {
				this.gameOverReady = false;
				this.gameOverAlpha = 0;
				this.updateGameOver();
				this.state = "game_over";
				this.timePlayed = (horde.now() - this.gameStartTime);
			};

			proto.toggleFullscreen = function () {
				horde.sound.play("select_pointer");
				this.enableFullscreen = !this.enableFullscreen;
				var fullscreenPref = (this.enableFullscreen ? 1 : 0);
				this.putData("fullscreen", fullscreenPref);
				this.resize();
			};

			}());


		(function define_horde_Object () {

			/**
			 * Horde Game Object
			 * @constructor
			 */
			horde.Object = function () {
				this.id = ""; // Object ID
				this.ownerId = null; // Owner object ID
				this.position = new horde.Vector2(); // Object's position on the map
				this.size = new horde.Size(32, 32); // Size of the object
				this.direction = new horde.Vector2(); // Direction the object is moving
				this.facing = new horde.Vector2(0, 1); // Direction the object is facing
				this.speed = 100; // The speed at which the object moves
				this.team = null; // Which "team" the object is on (null = neutral)
				this.hitPoints = 1; // Hit points
				this.damage = 1; // Amount of damage object deals when colliding with enemies
				this.spriteSheet = ""; // Sprite sheet where this object's graphics are found
				this.spriteX = 0; // X location of spirte
				this.spriteY = 0; // Y location of sprite
				this.spriteAlign = false; // Align sprite with facing
				this.animated = false; // Animated or not
				this.animFrameIndex = 0; // Current animation frame to display
				this.animNumFrames = 2;
				this.animDelay = 200; // Delay (in milliseconds) between animation frames
				this.animElapsed = 0; // Elapsed time (in milliseconds) since last animation frame increment
				this.spawnFrameIndex = 0;
				this.spawnFrameCount = 2;
				this.spawnFramesX = 0;
				this.spawnFramesY = 0;
				this.angle = 0; // Angle to draw this object
				this.rotateSpeed = 400; // Speed at which to rotate the object
				this.rotate = false; // Enable/disable rotation of object
				this.worth = 0; // Amount of gold this object is worth when killed
				this.ttl = 0; // How long (in milliseconds) this object *should* exist (0 = no TTL)
				this.ttlElapsed = 0; // How long (in milliseconds) this object *has* existed
				this.alpha = 1; // Alpha value for drawing this object
				this.alphaMod = 1; // Alpha modifier (fadin [1] vs fadeout [-1])
				this.gibletSize = "small"; // Size of giblets to spawn when this objects "dies"
				this.cooldown = false; // Whether or not the object's attack is on cooldown
				this.cooldownElapsed = 0; // How long the object's attack has been on cooldown
				this.autoFire = false; // Enable/disable auto fire
				this.soundAttacks = null; // Sound to play when object attacks
				this.soundDamage = null; // Sound to play when object takes damage
				this.soundDies = null; // Sound to play when object dies
				this.alive = true;
				this.states = [];
				this.addState(horde.Object.states.IDLE);
				this.currentWeaponIndex = 0;
				this.collidable = true;
				this.bounce = true;
				this.piercing = false;

				// Clay.io
				this.achievementId = null; // Related Clay.io Achievement ID
				this.deathsForAchievement = Infinity; // # of kills necessary necessary to earn achievement
				this.ignoreLogDeath = false; // If set to true, the # of deaths isn't logged (in Clay.io data-storage)

				// Default sounds
				this.soundDamage = null;
				this.soundDies = null;

				this.damageType = "physical";

				this.drawIndex = 1; // Controls what order objects are drawn, lower is first

				// AI stuff
				this.moveChangeElapsed = 0;
				this.moveChangeDelay = 500;

				this.wounds = 0; // Amount of damage object has sustained
				this.weapons = [];
				this.gold = 0; // Amount of gold this object has earned

				// Stats!
				this.kills = 0;
				this.timesWounded = 0;
				this.totalDamageTaken = 0;
				this.shotsFired = 0;
				this.shotsLanded = 0;
				this.shotsPerWeapon = {};
				this.meatEaten = 0;
				this.cheater = false;

				// Behavior phase stuff
				this.phase = 0;
				this.phaseInit = false;

				// Loot tables for enemies
				this.lootTable = [];

				this.killSwitch = false;
			};

			horde.Object.states = {
				IDLE: 0,
				MOVING: 1,
				ATTACKING: 2,
				HURTING: 3,
				DYING: 4,
				INVINCIBLE: 5,
				INVISIBLE: 6,
				SPAWNING: 7,
				DESPAWNING: 8,
				STUNNED: 9,
				VICTORIOUS: 10
			};

			var proto = horde.Object.prototype;

			/**
			 * Populates this object's key stats from a JSON dump
			 * @param {string} json JSON dump of an object
			 * @return {void}
			 */
			proto.load = function horde_Object_load (json) {
				var data = JSON.parse(json);
				this.wounds = data.wounds;
				this.weapons = data.weapons;
				this.currentWeaponIndex = data.currentWeaponIndex;
				this.gold = data.gold;
				this.kills = data.kills;
				this.timesWounded = data.timesWounded;
				this.totalDamageTaken = data.totalDamageTaken;
				this.shotsFired = data.shotsFired;
				this.shotsLanded = data.shotsLanded;
				this.shotsPerWeapon = data.shotsPerWeapon;
				this.meatEaten = data.meatEaten;
				this.cheater = data.cheater;
			};

			proto.setPhase = function (phase) {
				this.phase = phase;
				this.phaseInit = false;
			}

			proto.nextPhase = function () {
				this.setPhase(this.phase + 1);
			};

			proto.updateStates = function (elapsed) {
				for (var x in this.states) {
					var s = this.states[x];
					s.timer.update(elapsed);
					if (s.timer.expired()) {
						this.removeStateById(x);
						continue;
					}
				}
			};

			proto.hasState = function (state) {
				for (var x in this.states) {
					if (this.states[x].type === state) {
						return true;
					}
				}
				return false;
			};

			proto.addState = function (state, ttl) {
				if (this.hasState(state)) {
					return false;
				}
				var t = new horde.Timer();
				t.start(ttl);
				this.states.push({
					type: state,
					timer: t
				});
				switch (state) {
					case horde.Object.states.SLOWED:
						this.oldAnimDelay = this.animDelay;
						this.animDelay *= 2;
						break;
				}
			};

			proto.removeStateById = function (id) {
				var s = this.states[id];
				switch (s.type) {
					case horde.Object.states.INVINCIBLE:
						this.alpha = 1;
						this.alphaMod = -1;
						break;
					case horde.Object.states.SLOWED:
						this.animDelay = this.oldAnimDelay;
						break;
				}
				delete(this.states[id]);
			};

			proto.removeState = function (state) {
				for (var x in this.states) {
					if (this.states[x].type === state) {
						this.removeStateById(x);
					}
				}
			};

			/**
			 * Runs any initialization
			 * @return {void}
			 */
			proto.init = function horde_Object_proto_init () {
				this.execute("onInit");
				if (this.rotate) {
					this.angle = horde.randomRange(0, 359);
				}
				if (this.animated) {
					this.animElapsed = horde.randomRange(0, this.animDelay);
				}
			};

			/**
			 * Causes this object to die. Do not pass go, do not collect $200.
			 * @return {void}
			 */
			proto.die = function horde_Object_proto_die () {
				this.alive = false;

				// Clay.io: Log the death for things like achievements
				if((this.role == "monster" || this.role == "projectile") && !this.ignoreLogDeath) // Certain projectiles are ignored (ex. fire_sword_trail)
					this.logDeath();
			};

			/**
			 * Logs when a monster or projectile "dies". This is later used for Clay.io achievements (ex. kill 1000 bats)
			 * @return {void}
			 */
			proto.logDeath = function horde_Object_proto_logDeath () {
				// Clay.io: Update number of enemies killed
				var deaths = 0;
				var key = this.type + "_killed";
				var _this = this;

				if (this.achievementId !== null) {
					horde.Engine.prototype.getData(key, function(response) {
						deaths = (response.data ? response.data : 0) + 1;
						horde.Engine.prototype.putData(key, deaths);

			/* 			// Clay.io: check if there's an achievement for killing this specific thing x times
						if(_this.achievementId && deaths >= _this.deathsForAchievement && !horde.achievementsGranted[_this.achievementId])
						{
							horde.achievementsGranted[_this.achievementId] = true; // so we don't keep sending to Clay.io
							(new Clay.Achievement({ id: _this.achievementId })).award();
						} */
					});
				}

				if(this.role == "monster") {
					// Update overall kills
					var key = "overall_killed";
					horde.Engine.prototype.getData(key, function(response) {
						deaths = (response.data ? response.data : 0) + 1;
						horde.Engine.prototype.putData(key, deaths);

						// See if they're at achievement for overall kills
						achievementId = "killenemies";
						// 10,000 kills for the achievement
			/* 			if(deaths >= 10000 && !horde.achievementsGranted[achievementId]) {
							horde.achievementsGranted[achievementId] = true; // so we don't keep sending to Clay.io
							(new Clay.Achievement({ id: achievementId })).award();
						} */
					});
				}
			}

			/**
			 * Returns whether or not this object is "dead" (this.alive === false)
			 * @return {boolean} True if the object is dead; otherwise false
			 */
			proto.isDead = function horde_Object_proto_isDead () {
				return !this.alive;
			}

			/**
			 * Update this object
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {void}
			 */
			proto.update = function horde_Object_proto_update (elapsed, engine) {

				// If the owner has died, kill off this object
				if (
					this.killSwitch === false
					&& this.ownerId !== null
					&& !engine.isAlive(this.ownerId)
				) {
					switch (this.role) {
						case "projectile":
						case "trap":
							this.ttl = 1000;
							this.ttlElapsed = 0;
							break;
						case "monster":
							this.wound(this.hitPoints);
							break;
					}
					this.killSwitch = true;
				}

				this.updateStates(elapsed);

				if (this.deathTimer) {
					this.deathTimer.update(elapsed);
				}

				if (this.hasState(horde.Object.states.DYING)) {
					if (this.deathTimer.expired()) {
						this.deathFrameIndex++;
						this.deathTimer.reset();
						if (this.deathFrameIndex > 2) {
							this.deathFrameIndex = 2;
							this.ttl = 750;
						}
					}
				}

				if (this.hasState(horde.Object.states.INVINCIBLE)) {
					this.alpha += ((10 / 1000) * elapsed) * this.alphaMod;
					if (this.alpha >= 1) {
						this.alpha = 1;
						this.alphaMod = -1;
					}
					if (this.alpha <= 0) {
						this.alpha = 0;
						this.alphaMod = 1;
					}
				}

				if (this.hasState(horde.Object.states.STUNNED)) {
					return;
				}

				if (this.animated) {
					this.animElapsed += elapsed;
					if (this.animElapsed >= this.animDelay) {
						this.animElapsed = 0;
						this.animFrameIndex++;
						if (this.animFrameIndex > (this.animNumFrames - 1)) {
							this.animFrameIndex = 0;
						}
						if (this.hasState(horde.Object.states.SPAWNING)) {
							this.spawnFrameIndex++;
							if (this.spawnFrameIndex > this.spawnFrameCount) {
								this.removeState(horde.Object.states.SPAWNING);
							}
						}
						if (this.hasState(horde.Object.states.DESPAWNING)) {
							this.spawnFrameIndex--;
							if (this.spawnFrameIndex < 0) {
								this.removeState(horde.Object.states.DESPAWNING);
							}
						}
					}
				}

				if (this.spriteAlign) {
					this.angle = this.facing.angle();
				}

				if (this.rotate) {
					this.angle += ((this.rotateSpeed / 1000) * elapsed);
				}
				if (this.ttl > 0) {
					this.ttlElapsed += elapsed;
					if (this.ttl - this.ttlElapsed <= 1000) {
						this.alpha -= ((1 / 1000) * elapsed);
					}
					if (this.ttlElapsed >= this.ttl) {
						this.die();
					}
				}
				if (this.cooldown === true) {
					this.cooldownElapsed += elapsed;
					var wepInfo = this.getWeaponInfo();
					var wep = horde.objectTypes[wepInfo.type];
					if (this.cooldownElapsed >= wep.cooldown) {
						this.cooldown = false;
						this.cooldownElapsed = 0;
					}
				}

				if (this.phaseTimer) {
					this.phaseTimer.update(elapsed);
				}

				if (this.hasState(horde.Object.states.DYING)) {
					// Don't proceed with calling any AI behavior if this thing is dying...
					return;
				}

				return this.execute("onUpdate", arguments);
			};

			/**
			 * Returns the XY coordinates of this objects sprite
			 * @return {horde.Vector2} XY coordinates of sprite to draw
			 */
			proto.getSpriteXY = function horde_Object_proto_getSpriteXY (facingOverride) {
				if (this.animated) {
					switch (this.role) {

						case "hero":
						case "monster":
							if (this.hasState(horde.Object.states.DYING)) {
								return new horde.Vector2(
									(17 + this.deathFrameIndex) * this.size.width, this.spriteY
								);
							}
							if (
								this.hasState(horde.Object.states.SPAWNING)
								|| this.hasState(horde.Object.states.DESPAWNING)
							) {
								return new horde.Vector2(
									this.spawnFramesX + (this.spawnFrameIndex * this.size.width),
									this.spawnFramesY
								);
							}
							if (this.hasState(horde.Object.states.HURTING) && this.size.width <= 32) {
								return new horde.Vector2(
									16 * this.size.width, this.spriteY
								);
							}
							if (this.hasState(horde.Object.states.VICTORIOUS)) {
								return new horde.Vector2(
									20 * this.size.width, this.spriteY
								);
							}
							if (facingOverride) {
								var f = facingOverride;
							} else {
								var f = this.facing.clone();
							}
							var offset = horde.directions.fromVector(f);
							return new horde.Vector2(
								((offset * 2) + this.animFrameIndex) * this.size.width,
								this.spriteY
							);
							break;

						default:
							if (
								this.hasState(horde.Object.states.SPAWNING)
								|| this.hasState(horde.Object.states.DESPAWNING)
							) {
								return new horde.Vector2(
									this.spawnFramesX + (this.spawnFrameIndex * this.size.width),
									this.spawnFramesY
								);
							}
							return new horde.Vector2(
								this.spriteX + (this.animFrameIndex * this.size.width),
								this.spriteY
							);
							break;

					}

				} else {
					return new horde.Vector2(this.spriteX, this.spriteY);
				}
			};

			/**
			 * Returns the bounding box for this object
			 * @return {horde.Rect} Rectangle representing the bounding box
			 */
			proto.boundingBox = function horde_Object_proto_boundingBox () {
				var rect = new horde.Rect(
					this.position.x, this.position.y,
					this.size.width - 1, this.size.height - 1
				);
				if (this.role === "projectile") {
					rect.reduce(1);
				}
				if (this.type === "e_spit_pool") {
					// Kind of a hack...
					rect.y += (this.size.height / 4);
					rect.x += 5;
					rect.height -= (this.size.height / 2);
					rect.width -= 10;
				}
				if (this.type === "gas_cloud") {
					rect.y += 32;
					rect.x += 32;
					rect.height -= 32;
					rect.width -= 32;
				}
				return rect;
			};

			/**
			 * Centers this object on a point
			 * @param {horde.Vector2} v Vector to center on
			 * @return {void}
			 */
			proto.centerOn = function horde_Object_proto_centerOn (v) {
				this.position = v.subtract(horde.Vector2.fromSize(this.size).scale(0.5));
			};

			/**
			 * Deal some damage (or wound) this object
			 * @param {number} damage The amount of damage to deal
			 * @return {boolean} True if the object has died; otherwise false
			 */
			proto.wound = function horde_Object_proto_wound (damage) {
				if (
					(damage < 1)
					|| this.hasState(horde.Object.states.DYING)
					|| this.isDead()
				) {
					return false;
				}
				this.removeState(horde.Object.states.STUNNED);
				this.wounds += damage;
				this.totalDamageTaken += damage;
				this.timesWounded++;
				if (this.role === "monster" || this.role === "hero") {
					this.addState(horde.Object.states.HURTING, 300);
				}
				if (this.wounds >= this.hitPoints) {
					this.wounds = this.hitPoints;
					if (this.role === "monster" || this.role === "hero") {
						this.addState(horde.Object.states.DYING);
						this.deathFrameIndex = 0;
						this.deathTimer = new horde.Timer();
						this.deathTimer.start(200);
					} else {
						this.die();
					}
					if (this.role === "hero") {
						horde.sound.stopAll();
					}
					if (this.soundDies) {
						horde.sound.play(this.soundDies);
					}
					return true;
				}
				if (this.soundDamage) {
					horde.sound.play(this.soundDamage);
				}
				return false;
			};

			/**
			 * Handles when this object collides with a wall
			 * @param {array} axis Array of axes where collision occurred (x, y)
			 * @return {void}
			 */
			proto.wallCollide = function horde_Object_proto_wallCollide (axis) {
				if (this.role === "hero") {
					return;
				}
				if (this.bounce) {
					// reverse direction(s)
					var d = this.direction.clone();
					for (var i in axis) {
						d[axis[i]] *= -1;
					}
					this.setDirection(d);
					if (this.role === "projectile") {
						horde.sound.play("weapon_wall");
					}
				} else {
					if (this.damageType === "physical") {
						this.deflect();
					} else {
						this.die();
					}
				}
				this.execute("onWallCollide", [axis]);
			};

			proto.deflect = function horde_Object_proto_deflect () {
				this.role = "fluff";
				this.rotateSpeed = this.speed * 5;
				this.speed *= 0.50;
				this.spriteAlign = false;
				this.rotate = true;
				this.ttl = 100;
				this.alpha = 0.5;
				this.bounce = true;
			};

			/**
			 * Sets the direction (and facing) for this object
			 * @param {horde.Vector2} v Vector representing the direction
			 * @return {void}
			 */
			proto.setDirection = function horde_Object_proto_setDirection (v) {
				if (v.x === 0 && v.y === 0) {
					this.stopMoving();
				} else {
					this.direction = v;
					this.facing = this.direction.clone();
				}
			};

			proto.reverseDirection = function () {
				var d = this.direction.clone();
				d.scale(-1);
				this.setDirection(d);
			};

			/**
			 * "Chases" another object by setting this objects direction toward another
			 * @return {void}
			 */
			proto.chase = function horde_Object_proto_chase (object) {
				this.moveToward(object.position.clone());
			};

			proto.moveToward = function horde_Object_proto_moveToward (vector) {
				var direction = vector.clone().subtract(this.position).normalize();
				this.setDirection(direction);
			};

			/**
			 * Returns if this object is moving or not
			 * @return {boolean} True if the object is moving, otherwise false
			 */
			proto.isMoving = function horde_Object_proto_isMoving () {
				if (this.hasState(horde.Object.states.DYING)) {
					return false;
				}
				return (this.direction.x !== 0 || this.direction.y !== 0);
			};

			/**
			 * Stops this object from moving (resets direction vector to zero)
			 * @return {void}
			 */
			proto.stopMoving = function horde_Object_proto_stopMoving () {
				this.direction.zero();
			};

			/**
			 * Executes a method that may or may not exist
			 * @param {string} method Method to call
			 * @param {array} args Array of arguments
			 * @return {void}
			 */
			proto.execute = function horde_Object_proto_execute (method, args) {
				if (this[method]) {
					return this[method].apply(this, args);
				}
			};

			/**
			 * Returns the weapon info for this object's current weapon
			 * @return {object} Weapon info (type & count)
			 */
			proto.getWeaponInfo = function horde_Object_proto_getWeaponInfo () {
				var len = this.weapons.length;
				if (len >= 1) {
					// Object has at least one weapon
					if (this.currentWeaponIndex < 0) {
						this.currentWeaponIndex = 0;
					}
					if (this.currentWeaponIndex > len - 1) {
						this.currentWeaponIndex = len - 1;
					}
					return this.weapons[this.currentWeaponIndex];
				}
				return false;
			};

			proto.addWeapon = function horde_Object_proto_addWeapon (type, count) {

				var remIndices = [];

				// Adjust count if player already has some of this weapon type
				// Also, store non-infite weapons for later removal
				for (var x in this.weapons) {
					var w = this.weapons[x]; // Haha, Weapon X
					if (typeof(w) !== "undefined" && w.type === type) {
						if (w.count !== null) {
							count += w.count;
						} else {
							count = null;
						}
					}
					if (w.count !== null) {
						remIndices.push(x);
					}
				}

				// Remove specified weapons
				for (var index in remIndices) {
					this.weapons = this.weapons.splice(index, 1);
				}

				var len = this.weapons.push({
					type: type,
					count: count
				});

				this.currentWeaponIndex = (len - 1);

			};

			proto.cycleWeapon = function horde_Object_proto_cycleWeapon (reverse) {
				var len = this.weapons.length;
				if (reverse === true) {
					this.currentWeaponIndex--;
					if (this.currentWeaponIndex < 0) {
						this.currentWeaponIndex = len - 1;
					}
				} else {
					this.currentWeaponIndex++;
					if (this.currentWeaponIndex > len - 1) {
						this.currentWeaponIndex = 0;
					}
				}
			};

			/**
			 * "Fires" the current weapon by reducing the weapon count and returning the type
			 * @return {string} Weapon type to spawn
			 */
			proto.fireWeapon = function horde_Object_proto_fireWeapon () {
				var len = this.weapons.length;
				if (this.cooldown === true || len < 1) {
					return false;
				}
				var currentWeapon = this.getWeaponInfo();
				if (currentWeapon.count !== null) {
					currentWeapon.count -= 1;
					if (currentWeapon.count < 1) {
						this.weapons.splice(this.currentWeaponIndex, 1);
					}
				}
				this.cooldown = true;
				return currentWeapon.type;
			};

			/**
			 * Returns whether or not this object has a given weapon type
			 * @param {string} type Weapon type
			 * @return {boolean}
			 */
			proto.hasWeapon = function horde_Object_proto_hasWeapon (type) {
				var len = this.weapons.length;
				for (var x = 0; x < len; ++x) {
					var weapon = this.weapons[x];
					if (weapon.type === type) {
						return true;
					}
				}
				return false;
			};

			}());

		(function defne_horde_objectTypes () {

		horde.objectTypes = {};

		var o = horde.objectTypes;

		o.hero = {
			role: "hero",
			team: 0,
			speed: 150,
			hitPoints: 100,
			damage: 0,
			damageType: null,
			spriteSheet: "characters",
			spriteY: 992,
			animated: true,
			soundAttacks: "hero_attacks",
			soundDamage: "hero_damage",
			soundDies: "hero_dies",
			weapons: [
				{type: "h_sword", count: null}
			],
			isMeatboy: false,
			bloodTimer: null,

			onInit: function () {
				if (this.isMeatboy) {
					this.initMeatBoy();
				}
			},

			initMeatBoy: function () {
				this.hitPoints = 1;
				this.spriteY = 1024;
				this.bloodTimer = new horde.Timer();
				this.bloodTimer.start(100);
			},

			onUpdate: function (elapsed, engine) {
				if (this.isMeatboy) {
					this.bloodTimer.update(elapsed);
					if (this.bloodTimer.expired() && this.isMoving()) {
						var id = engine.spawnObject(this, "blood_pool");
						var o = engine.objects[id];
						o.position.x += horde.randomRange(-8, 8);
						o.position.y += horde.randomRange(-8, 8);
						o.angle = horde.randomRange(0, Math.PI * 1.5);
						this.bloodTimer.start(horde.randomRange(75, 150));
					}
				}
			},

			onKilled: function (attacker, engine) {
				var num = 10;
				for (var i = 0; i < num; ++i) {
					var skull = horde.makeObject("mini_skull");
					skull.position.x = (this.position.x + (i * (this.size.width / num)));
					skull.position.y = (this.position.y + this.size.height - horde.randomRange(0, this.size.height));
					engine.addObject(skull);
				}
			}

		};

		o.blood_pool = {
			role: "fluff",
			size: new horde.Size(32, 32),
			speed: 0,
			ttl: 1250,
			collidable: false,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 32,
			drawIndex: 0
		};

		// HERO WEAPONS

		o.h_sword = {
			role: "projectile",
			cooldown: 300,
			speed: 250,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 0,
			spriteAlign: true,
			priority: 0,
			bounce: false,
			
			// Clay.io
			achievementId: "masterswords",
			deathsForAchievement: 1000
		};

		o.h_knife = {
			role: "projectile",
			size: new horde.Size(32, 30),
			cooldown: 200,
			speed: 350,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 0,
			spriteAlign: true,
			priority: 1,
			bounce: false
		};

		o.h_spear = {
			role: "projectile",
			cooldown: 350,
			speed: 500,
			hitPoints: 1,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 0,
			spriteAlign: true,
			priority: 2,
			bounce: false,
			piercing: true
		};

		o.h_fireball = {
			role: "projectile",
			cooldown: 300,
			speed: 400,
			rotateSpeed: 500,
			hitPoints: 1,
			damage: 3,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 450,
			soundAttacks: "fire_attack",
			priority: 3,
			bounce: false,
			damageType: "magic",

			onInit: function () {
				this.trailTimer = new horde.Timer();
				this.trailTimer.start(75);
			},

			onUpdate: function (elapsed, engine) {
				this.trailTimer.update(elapsed);
				if (this.trailTimer.expired()) {
					engine.spawnObject(this, "h_fireball_trail");
					this.trailTimer.reset();
				}
			},
			
			// Clay.io
			achievementId: "masterfire",
			deathsForAchievement: 1000

		};

		o.h_fireball_trail = {
			role: "projectile",
			speed: 0,
			rotateSpeed: 150,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 500,
			alpha: 0.5,
			priority: 3,
			bounce: false,
			damageType: "magic",
			drawIndex: 0,
			// Clay.io
			ignoreLogDeath: true
		};

		/*
		o.h_bomb = {
			role: "projectile",
			cooldown: 750,
			speed: 200,
			hitPoints: 1,
			damage: 0,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			rotate: true,
			rotateSpeed: 150,
			priority: 4,
			bounce: true,
			
			onDelete: function (engine) {
				engine.spawnObject(this, "bomb_smoke");
			}
			
		};

		o.bomb_smoke = {
			role: "trap",
			size: new horde.Size(64, 64),
			cooldown: 0,
			speed: 0,
			hitPoints: 9999,
			damage: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 544,
			bounce: false,
			ttl: 3000,
			
			onDamage: function (defender, engine) {
				if (defender.team !== this.team && defender.role === "monster") {
					defender.addState(horde.Object.states.STUNNED, 5000);
				}
			}
			
		};
		*/

		o.h_axe = {
			role: "projectile",
			cooldown: 500,
			speed: 225,
			hitPoints: 1,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 700,
			priority: 5,
			ttl: 4000,
			piercing: true,
			
			// Clay.io
			achievementId: "masteraxes",
			deathsForAchievement: 1000
		};

		o.h_fire_sword = {
			role: "projectile",
			cooldown: 450,
			speed: 350,
			hitPoints: 1,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			priority: 6,
			bounce: false,
			spriteAlign: true,
			piercing: true,
			soundAttacks: "fire_attack",
			damageType: "magic",
			
			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "fire_sword_trail");
					this.spawnTimer.reset();
				}
			},
			
			// Clay.io
			achievementId: "masterfireswords",
			deathsForAchievement: 1000
			
		};

		o.fire_sword_trail = {
			role: "projectile",
			speed: 0,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			soundAttacks: "fire_attack",
			ttl: 500,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.h_fire_knife = {
			role: "projectile",
			size: new horde.Size(32, 30),
			cooldown: 200,
			speed: 350,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			priority: 6,
			bounce: false,
			spriteAlign: true,
			piercing: true,
			soundAttacks: "fire_attack",
			damageType: "magic",
			
			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "fire_sword_trail");
					this.spawnTimer.reset();
				}
			}
			
		};

		o.h_firebomb = {
			role: "projectile",
			cooldown: 500,
			speed: 150,
			rotateSpeed: 300,
			hitPoints: 1,
			damage: 2,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			rotate: true,
			ttl: 550,
			soundAttacks: "fire_attack",
			priority: 3,
			bounce: false,
			damageType: "magic"
		};

		/*
		o.h_fireburst = {
			role: "projectile",
			size: new horde.Size(32, 32),
			cooldown: 350,
			speed: 250,
			hitPoints: 1,
			damage: 3,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 64,
			ttl: 350,
			soundAttacks: "fire_attack",
			spriteAlign: true,
			damageType: "magic",
			priority: 1,
			bounce: false
		};
		*/

		// ENEMIES

		var movementTypes = {
			chase: function (elapsed, engine) {

				if (this.moveChangeDelay > 0) {
					this.moveChangeElapsed += elapsed;
					if (this.moveChangeElapsed < this.moveChangeDelay) {
						return;
					}
					this.moveChangeElapsed = 0;
				}

				var p = engine.getPlayerObject();
				this.chase(p);
				
				return "shoot";

			},
			getNear: function (elapsed, engine) {

				this.speed = this.defaultSpeed;

				var p = engine.getPlayerObject();

				// Get the distance from the player
				var distance = p.position.clone().subtract(this.position).magnitude();
				
				if (distance < 100) {
					// too close! run away
					this.chase(p);
					this.setDirection(this.direction.invert());
				} else if (distance > 150) {
					// too far, chase him down!
					this.chase(p);
				} else if (!this.cooldown) {
					// shoot the fucker in the FACE
					this.chase(p);
					this.speed = 0;
					return "shoot";
				} else {
					movementTypes.wander.apply(this, arguments);
				}

			},
			wander: function (elapsed, engine) {
				this.moveChangeElapsed += elapsed;
				if (this.moveChangeElapsed >= this.moveChangeDelay) {
					this.moveChangeElapsed = 0;
					var d = horde.randomDirection();
					if (d.x === 0 && d.y === 0) { return; }
					this.setDirection(d);
				}
			},
			wanderShoot: function (elapsed, engine) {
				
				var p = engine.getPlayerObject();
				
				var diff = p.position.clone().subtract(this.position).abs();
				
				if (!this.cooldown && (diff.x < (p.size.width / 2) || diff.y < (p.size.height / 2))) {
					this.chase(p);
					return "shoot";
				} else {
					movementTypes.wander.apply(this, arguments);
				}
				
			},
			wanderThenChase: function (elapsed, engine) {

				var p = engine.getPlayerObject();
				var hero = {
					x : p.position.x,
					y : p.position.y
				};
				var x = this.position.x;
				var y = this.position.y;

				if (this.seenHero) {
					movementTypes.chase.apply(this, arguments);
				} else {

					movementTypes.wander.apply(this, arguments);

					var nearX = Math.abs(x - hero.x);
					var nearY = Math.abs(y - hero.y);

					if ((nearX < 64) && (nearY < 64)) {
						horde.sound.play(this.soundAttacks);
						this.seenHero = true;
						return "shoot";
					}

				}

			}
		};

		o.bat = {
			role: "monster",
			team: 1,
			speed: 100,
			hitPoints: 5,
			damage: 2,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 96,
			animated: true,
			animDelay: 150,
			moveChangeElapsed: 0,
			moveChangeDelay: 500,
			soundDamage: "bat_damage",
			soundDies: "bat_dies",
			
			// Clay.io
			achievementId: "killbats",
			deathsForAchievement: 1000,
			
			lootTable: [
				{type: null, weight: 9},
				{type: "item_coin", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wander;
			}
		};

		o.dire_bat = {
			role: "monster",
			team: 1,
			speed: 150,
			hitPoints: 10,
			damage: 5,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 128,
			animated: true,
			animDelay: 150,
			moveChangeElapsed: 0,
			moveChangeDelay: 500,
			soundDamage: "bat_damage",
			soundDies: "bat_dies",
			
			lootTable: [
				{type: null, weight: 7},
				{type: "item_coin", weight: 3}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wander;
			}
		};

		o.goblin = {
			role: "monster",
			team: 1,
			speed: 75,
			hitPoints: 10,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 160,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_arrow", count: null}
			],
			soundAttacks: "goblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			
			lootTable: [
				{type: null, weight: 6},
				{type: "item_coin", weight: 1},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.wanderShoot;
			}
		};

		o.hunter_goblin = {
			role: "monster",
			team: 1,
			speed: 75,
			hitPoints: 10,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 160,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_arrow", count: null}
			],
			soundAttacks: "goblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			
			lootTable: [
				{type: null, weight: 2},
				{type: "item_coin", weight: 4},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 2}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},
			onUpdate: function (elapsed, engine) {
				if (this.position.y >= 50) {
					if (!this.cooldown) {
						this.chase(engine.getPlayerObject());
						return "shoot";
					}
					movementTypes.wander.apply(this, arguments);
				}
			}
		};

		o.demoblin = {
			role: "monster",
			team: 1,
			speed: 75,
			defaultSpeed: 75,
			hitPoints: 30,
			damage: 15,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 192,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,
			weapons: [
				{type: "e_trident", count: null}
			],
			
			lootTable: [
				{type: null, weight: 6},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_chest", weight: 1},
				{type: "item_food", weight: 1}
			],
			
			soundAttacks: "demoblin_attacks",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.cooldown = true;
				this.cooldownElapsed = horde.randomRange(0, 5000);
			},
			onUpdate: function () {
				if (this.position.y >= 50) this.onUpdate = movementTypes.getNear;
			}
		};

		o.flaming_skull = {
			
			role: "monster",
			team: 1,
			
			speed: 200,
			hitPoints: 50,
			damage: 10,
			worth: 0,
			
			spriteSheet: "characters",
			spriteY: 32,
			animated: true,
			
			setDir: false,

			soundDamage: "skull_damage",
			soundDies: "skull_dies",
			
			weapons: [
				{type: "e_static_blue_fire", count: null}
			],
			
			lootTable: [
				{type: null, weight: 6},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_chest", weight: 2}
			],
			
			onInit: function () {
				switch (horde.randomRange(1, 2)) {
					case 1:
						this.speed *= 0.5;
						this.animDelay *= 0.5;
						break;
					case 2:
						this.speed *= 0.75;
						this.animDelay *= 0.75;
						break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				if (!this.setDir && this.position.y >= 50) {
					var d = this.direction.clone();
					d.x = Math.random();
					if (Math.random() >= 0.5) {
						d.x *= -1;
					}
					this.setDirection(d);
					this.setDir = true;
				}
				return "shoot";
			}
			
		};

		o.huge_skull = {
			
			role: "monster",
			team: 1,
			badass: true,
			
			speed: 150,
			hitPoints: 200,
			damage: 20,
			worth: 0,
			
			spriteSheet: "characters",
			spriteY: 864,
			animated: true,
			size: new horde.Size(64, 64),
			
			setDir: false,

			soundDamage: "skull_damage",
			soundDies: "skull_dies",
			
			// Clay.io
			achievementId: "killskulls",
			deathsForAchievement: 100,
			
			weapons: [
				{type: "e_static_green_fire", count: null}
			],
			
			lootTable: [
				{type: null, weight: 4},
				{type: "WEAPON_DROP", weight: 3},
				{type: "item_chest", weight: 3}
			],
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				switch (horde.randomRange(1, 2)) {
					case 1:
						this.speed *= 0.5;
						this.animDelay *= 0.5;
						break;
					case 2:
						this.speed *= 0.75;
						this.animDelay *= 0.75;
						break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
					
					// Come out of the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= 50) {
							this.nextPhase();
						}
						break;
					
					// Choose a random direction
					case 1:
						if (!this.phaseInit) {
							var d = this.direction.clone();
							d.x = Math.random();
							if (Math.random() >= 0.5) {
								d.x *= -1;
							}
							this.setDirection(d);
							this.phaseTimer.start(horde.randomRange(2000, 4000));
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Charge the player just for a half second
					case 2:
						if (!this.phaseInit) {
							this.speed *= 2;
							this.animDelay *= 2;
							this.phaseTimer.start(horde.randomRange(250, 500));
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.speed /= 2;
							this.animDelay /= 2;
							this.setPhase(1);
						}
						this.chase(engine.getPlayerObject());
						break;
					
				}
				
				return "shoot";

			}
			
		};

		o.spike_wall = {
			
			role: "trap",
			team: 1,
			
			speed: 150,
			hitPoints: Infinity,
			damage: 20,

			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 256,
			drawIndex: 0,
			
			animated: true,
			animNumFrames: 1,
			
			spawnFramesX: 96,
			spawnFramesY: 576,
			spawnFrameCount: 2,
			
			rotate: true,
			rotateSpeed: 0,
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.spinUpTime = 7500;
				this.wallDirection = new horde.Vector2(0, 1);
				this.addState(horde.Object.states.SPAWNING);
			},
			
			onDamage: function (defender, engine) {
				this.spriteX = 128;
			},
			
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					case 0:
						if (!this.phaseInit) {
							this.phaseTimer.start(this.spinUpTime);
							this.phaseInit = true;
						}
						var step = (this.spinUpTime / 200);
						this.rotateSpeed += ((step / 1000) * elapsed);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							horde.sound.play("spike_attack");
							this.setDirection(this.wallDirection);
							this.phaseInit = true;
						}
						break;
					
				}
				
			},
			
			onWallCollide: function () {
				this.stopMoving();
				this.ttl = 1500;
			}
			
		};

		o.spike_sentry = {
			
			role: "trap",
			team: 1,
			
			speed: 100,
			hitPoints: Infinity,
			damage: 10,
			worth: 0,
			
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 256,
			
			animated: true,
			animNumFrames: 1,
			
			spawnFramesX: 0,
			spawnFramesY: 576,
			spawnFrameCount: 2,
			
			rotate: true,
			rotateSpeed: 100,

			phase: 0,
			phaseInit: false,
			
			onInit: function () {
				this.addState(horde.Object.states.SPAWNING);
			},
			
			onDamage: function (defender, engine) {

				if (defender.role === "hero") {
					this.spriteX = 160;
				}
				
			},
			
			onUpdate: function (elapsed, engine) {
				
				if (this.hasState(horde.Object.states.SPAWNING)) {
					return;
				}
				
				switch (this.phase) {
					
					// Wait for player to get near X or Y axis
					case 0:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseInit = true;
						}
						var p = engine.getPlayerObject();
						var diff = p.position.clone().subtract(this.position);
						if (Math.abs(diff.y) < 32) {
							// charge the player along the left/right axis
							this.originalPos = this.position.clone();
							var d = new horde.Vector2();
							d.x = (diff.x < 0) ? -1: 1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
							horde.sound.play("spike_attack");
						} else if (Math.abs(diff.x) < 32) {
							this.originalPos = this.position.clone();
							var d = new horde.Vector2();
							d.y = (diff.y < 0) ? -1: 1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
							horde.sound.play("spike_attack");
						}
						break;
						
					// Charging the player
					case 1:
						if (!this.phaseInit) {
							this.speed = 300;
							this.rotateSpeed = 300;
							this.phaseInit = true;
						}
						var diff = this.position.clone().subtract(this.originalPos).abs();
						if (diff.x > 320 - 64) {
							var d = this.direction.clone();
							d.x *= -1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
						} else if (diff.y > 240 - (4 *32) + 16) {
							var d = this.direction.clone();
							d.y *= -1;
							this.setDirection(d);
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					// Reseting
					case 2:
						if (!this.phaseInit) {
							this.speed = 50;
							this.rotateSpeed = 100;
							this.phaseInit = true;
						}
						var diff = this.position.clone().subtract(this.originalPos).abs();
						if (diff.x < 5 && diff.y < 5) {
							this.stopMoving();
							this.position = this.originalPos.clone();
							this.phase = 0;
							this.phaseInit = false;
						}
						break;

				}

			}

		};

		o.spikes = {

			role: "trap",
			team: 1,

			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			worth: 0,

			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 256,

			animated: true,
			animNumFrames: 1,

			spawnFramesX: 224,
			spawnFramesY: 256,
			spawnFrameCount: 3,

			collidable: false,

			onInit: function () {
				this.addState(horde.Object.states.SPAWNING);
			},

			onDamage: function (defender, engine) {
				if (defender.role === "hero") {
					this.spriteX = 96;
				}
			}

		};

		o.owlbear = {
			role: "monster",
			team: 1,
			badass: true,
			
			animated: true,
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 800,
			
			damage: 15,
			hitPoints: 250,
			speed: 75,

			soundAlarm: "owlbear_alarm",
			soundAttacks: "owlbear_attacks",
			soundDamage: "owlbear_damage",
			soundDies: "owlbear_dies",
			
			// Clay.io
			achievementId: "killowlbears",
			deathsForAchievement: 100,
			
			lootTable: [
				{type: "item_food", weight: 1}
			],
			
			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.phaseTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
				
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 150;
							this.animDelay = 150;
							this.phaseInit = true;
						}
						if (this.position.y >= 60) {
							this.nextPhase();
						}
						break;
					
					// Wander around, slowly
					case 1:
						if (!this.phaseInit) {
							this.speed = 75;
							this.animDelay = 300;
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						var player = engine.getPlayerObject();
						var diff = player.position.clone().subtract(this.position).abs();
						if (diff.x < (this.size.width / 2) || diff.y < (this.size.height / 2)) {
							this.chase(player);
							this.nextPhase();
						}
						break;
					
					// Spotted the player, prepare to charge	
					case 2:
						if (!this.phaseInit) {
							horde.sound.play(this.soundAlarm);
							this.speed = 0;
							this.animDelay = 150;
							this.phaseTimer.start(500);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
						
					// Charge!
					case 3:
						if (!this.phaseInit) {
							horde.sound.play(this.soundAttacks);
							this.speed = 350;
							this.animDelay = 75;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Stunned for bit
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 400;
							this.phaseTimer.start(1250);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
						}
						break;
					
				}
			}
			
		};

		o.cyclops = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 224,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 20,
			hitPoints: 200,
			speed: 100,
			animDelay: 100,
			worth: 0,

			soundAttacks: "cyclops_attacks",
			soundDamage: "cyclops_damage",
			soundDies: "cyclops_dies",

			weapons: [{type: "e_boulder", count: null}],

			lootTable: [
				{type: "item_food", weight: 7},
				{type: "WEAPON_DROP", weight: 3}
			],

			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
			},
			onUpdate: function (elapsed, engine) {
				if (this.position.y >= 50) {
					this.speed = 25;
					this.animDelay = 200;
					this.onUpdate = movementTypes.chase;
				}
			}
		};

		// Beholder eyelets
		o.eyelet = {
			role: "monster",
			team: 1,
			
			animated: true,
			spriteSheet: "characters",
			spriteY: 512,
			
			damage: 10,
			hitPoints: 40,
			speed: 100,

			soundDamage: "eyelet_damage",
			soundDies: "eyelet_dies",
			
			collidable: false,

			lootTable: [
				{type: null, weight: 9},
				{type: "item_food", weight: 1},
				{type: "WEAPON_DROP", weight: 8},
				{type: "item_weapon_fireball", weight: 2}
			],
			
			makeBadass: function () {
				this.spriteY = 960;
				this.hitPoints = 50;
				this.speed = 150;
				this.damage = 20;
			},
			
			onInit: function () {
				if (horde.randomRange(1, 10) > 5) {
					this.spriteY += 32;
				}
				this.ownerAngle = 0;
				this.phaseTimer = new horde.Timer();
				this.addState(horde.Object.states.INVINCIBLE, 1000);
			},
			
			onUpdate: function (elapsed, engine) {

				if (!engine.objects[this.ownerId]) {
					this.wound(this.hitPoints);
					return;
				}

				switch (this.phase) {
					
					// Snap to the north of the owner
					case 0:
						if (!this.phaseInit) {
							this.phaseTimer.start(10000);
							this.phaseInit = true;
						}
						var owner = engine.objects[this.ownerId];
						var ownerCenter = owner.position.clone().add(
							horde.Vector2.fromSize(owner.size).scale(0.5)
						).subtract(new horde.Vector2(10, 10));
						var d = horde.Vector2.fromHeading(this.ownerAngle);
						this.position = ownerCenter.add(d.scale(owner.eyeletOffset));
						this.ownerAngle += ((1.05 / 1000) * elapsed);
						if (this.ownerAngle > (Math.PI * 2)) {
							this.ownerAngle = 0;
						}
						if (
							this.phaseTimer.expired() 
							&& engine.checkTileCollision(this) === false
						) {
							this.nextPhase();
						}
						break;
						
					case 1:
						if (!this.phaseInit) {
							this.collidable = true;
							this.speed = 175;
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						break;
					
				}
			}
			
		};

		o.cube = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			animDelay: 400,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 576,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 35,
			hitPoints: 750,
			speed: 15,
			worth: 0,
			
			soundAttacks: "cube_attacks",
			soundDamage: "cube_damage",
			soundDies: "cube_dies",
			
			// Clay.io
			achievementId: "defeatgel",
			deathsForAchievement: 1,

		/*
			lootTable: [
				{type: "item_chest", weight: 1},
				{type: "WEAPON_DROP", weight: 6},
				{type: "item_food", weight: 3}
			],
			*/
			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			onInit: function () {
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
				this.phaseTimer = new horde.Timer();
				this.gelTimer = new horde.Timer();
			},
			
			onThreat: function (attacker, engine) {
				if (attacker.damageType !== "magic") {
					return true;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				
				this.gelTimer.update(elapsed);
				
				switch (this.phase) {
					
					// "Charge" out of gate
					case 0:
						if (!this.phaseInit) {
							this.speed = 100;
							this.animDelay = 200;
							this.phaseInit = true;
						}
						if (this.position.y >= 150) {
							this.nextPhase();
						}
						break;
					
					// Spawn a bunch of gels!
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.speed = 15;
							this.animDelay = 400;
							this.phaseTimer.start(6000);
							this.gelTimer.start(300);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
							break;
						}
						movementTypes.wander.apply(this, arguments);
						//this.chase(engine.getPlayerObject());
						this.position.x += horde.randomRange(-1, 1);
						if (this.gelTimer.expired()) {
							engine.spawnObject(this, "gel");
							horde.sound.play(this.soundAttacks);
							this.gelTimer.reset();
						}
						break;
					
					case 2:
						if (!this.phaseInit) {
							this.speed = 30;
							this.animDelay = 150;
							this.phaseTimer.start(7500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
							break;
						}
						movementTypes.chase.apply(this, arguments);
						break;
					
				}
				
			}
		};

		o.gel = {
			role: "monster",
			team: 1,

			animated: true,
			animDelay: 400,
			
			spriteSheet: "characters",
			spriteY: 640,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 5,
			hitPoints: 10,
			speed: 150,
			worth: 0,

			soundDamage: "gel_damage",
			soundDies: "gel_dies",

			onInit: function () {
				this.setDirection(horde.randomDirection());
				this.moveChangeDelay = horde.randomRange(500, 1000);
				// Randomize sprite
				switch (horde.randomRange(1, 4)) {
					case 1: this.spriteY = 640; break;
					case 2: this.spriteY = 672; break;
					case 3: this.spriteY = 704; break;
					case 4: this.spriteY = 736; break;
				}
			},
			
			onUpdate: function (elapsed, engine) {
				movementTypes.wander.apply(this, arguments);
			},
			
			onKilled: function (attacker, engine) {
				var player = engine.getPlayerObject();
				// Spawn a fireball scroll if the player is out
				// AND there aren't any on the screen
				if (
					!player.hasWeapon("h_fireball")
					&& !player.hasWeapon("h_fire_sword")
					&& engine.getObjectCountByType("item_weapon_fireball") === 0
				) {
					engine.dropObject(this, "item_weapon_fireball");
				}
			}
			
		};

		o.superclops = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 288,

			moveChangeElapsed: 0,
			moveChangeDelay: 1000,

			damage: 20,
			hitPoints: 750,
			speed: 25,
			worth: 0,

			soundAttacks: "minotaur_attacks",
			soundDamage: "minotaur_damage",
			soundDies: "minotaur_dies",
			
			// Clay.io
			achievementId: "defeatminotaur",
			deathsForAchievement: 1,

			weapons: [{type: "e_minotaur_trident", count: null}],

			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
			},
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 100;
							this.phaseInit = true;
						}
						if (this.position.y >= 80) {
							this.nextPhase();
						}
						break;
					
					// Shoot two boulders
					case 1:
						if (!this.phaseInit) {
							this.animDelay = 250;
							var p = engine.getPlayerObject();
							this.chase(p);
							this.stopMoving();
							var h = this.facing.heading();
							engine.spawnObject(this, "e_bouncing_boulder", horde.Vector2.fromHeading(
								h - 0.3
							));
							engine.spawnObject(this, "e_bouncing_boulder", horde.Vector2.fromHeading(
								h + 0.3
							));
							this.phaseTimer.start(1500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
						
					// Charge down the middle
					case 2:
						if (!this.phaseInit) {
							this.speed = 300;
							this.animDelay = 100;
							this.setDirection(this.facing);
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Wander a bit as if stunned by the charge
					case 3:
						if (!this.phaseInit) {
							this.speed = 15;
							this.animDelay = 400;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							if (this.wounds > (this.hitPoints / 2)) {
								this.nextPhase();
							} else {
								this.setPhase(1);
							}
						}
						break;
					
					// Wiggle!
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 300;
							this.phaseTimer.start(1500);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
							break;
						}
						this.position.x += horde.randomRange(-1, 1);
						break;
					
					// Shoot bouncing boulders
					case 5:
						if (!this.phaseInit) {
							this.cooldown = false;
							this.weapons = [{type: "e_bouncing_boulder", count: null}];
							this.phaseInit = true;
						}
						engine.objectAttack(this);
						this.position.x += horde.randomRange(-1, 1);
						this.nextPhase();
						break;
					
					// Chase and shoot tridents
					case 6:
						if (!this.phaseInit) {
							this.speed = 50;
							this.weapons = [{type: "e_minotaur_trident", count: null}];
							this.cooldown = true;
							this.phaseTimer.start(6000)
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(4);
						}
						engine.objectAttack(this);
						movementTypes.chase.apply(this, arguments);
						break;

				}
				
			},
			
			onWallCollide: function () {
				if (this.phase === 2) {
					this.nextPhase();
				}
			}

		};

		o.imp = {

			role: "monster",
			team: 1,

			speed: 100,

			hitPoints: 20,
			damage: 15,

			worth: 0,

			spriteSheet: "characters",
			spriteY: 64,
			animated: true,

			gibletSize: "medium",

			moveChangeElapsed: 0,
			moveChangeDelay: 3000,

			soundDamage: "imp_damage",
			soundDies: "imp_dies",

			phase: 0,
			phaseInit: false,

			lootTable: [
				{type: null, weight: 7},
				{type: "item_food", weight: 1},
				{type: "WEAPON_DROP", weight: 2}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
			},

			onKilled: function (attacker, engine) {
				if (attacker.role === "projectile") {
					attacker.die();
				}
				for (var x = 0; x < 2; ++x) {
					engine.spawnObject(
						this,
						"dire_bat",
						horde.randomDirection(),
						false
					);
				}
			},

			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Move past the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= 50) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Wander slowly
					case 1:
						if (!this.phaseInit) {
							this.speed = 50;
							this.animDelay = 400;
							this.phaseTimer.start(2500, 7500);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Wander fast!
					case 2:
						if (!this.phaseInit) {
							this.speed = 150;
							this.animDelay = 150;
							this.phaseTimer.start(2500, 7500);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this. arguments);
						if (this.phaseTimer.expired()) {
							this.phase = 1;
							this.phaseInit = false;
						}
						break;

				}

			}
		};

		o.wizard = {
			role: "monster",
			team: 1,
			speed: 100,
			hitPoints: 20,
			damage: 10,
			worth: 0,
			spriteSheet: "characters",
			spriteY: 416,
			animated: true,
			gibletSize: "medium",
			moveChangeElapsed: 0,
			moveChangeDelay: 3000,

			weapons: [
				{type: "e_shock_wave", count: null}
			],

			soundAttacks: "wizard_attacks",
			soundDisappear: "wizard_disappear",
			soundReappear: "wizard_reappear",
			soundDamage: "goblin_damage",
			soundDies: "goblin_dies",

			lootTable: [
				{type: null, weight: 6},
				{type: "item_chest", weight: 2},
				{type: "WEAPON_DROP", weight: 2}
			],

			phase: 0,
			phaseInit: false,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.moveToY = horde.randomRange(50, 75);
			},
			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Move out of the gates
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
						}
						if (this.position.y >= this.moveToY) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Phase out
					case 1:
						if (!this.phaseInit) {
							this.animated = false;
							this.stopMoving();
							this.addState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(1000);
							this.phaseInit = true;
							horde.sound.play(this.soundDisappear);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Turn invisible and move around!
					case 2:
						if (!this.phaseInit) {
							this.speed = 500;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(horde.randomRange(1000, 2000));
							this.phaseInit = true;
						}
						// Don't trigger phase in if wizard is too close to the player
						var myCenter = this.boundingBox().center();
						var playerCenter = engine.getPlayerObject().boundingBox().center();
						var diff = playerCenter.clone().subtract(myCenter).abs();
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired() && diff.magnitude() > 90) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Phase in
					case 3:
						if (!this.phaseInit) {
							this.stopMoving();
							this.removeState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(1000);
							this.phaseInit = true;
							horde.sound.play(this.soundReappear);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;

					// Shoot the player!
					case 4:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animated = true;
							this.removeState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(horde.randomRange(2000, 3000));
							this.phaseInit = true;
							this.shotOnce = false;
						}
						var p = engine.getPlayerObject();
						this.chase(p);
						if (this.phaseTimer.expired()) {
							this.phase = 1;
							this.phaseInit = false;
						}
						if (!this.shotOnce) {
							this.shotOnce = true;
							return "shoot";
						}
						break;

				}

			}
		};

		o.sandworm = {

			role: "monster",
			team: 1,

			animated: true,
			animDelay: 200,
			spriteSheet: "characters",
			spriteY: 480,
			
			spawnFramesX: 544,
			spawnFramesY: 448,
			spawnFrameCount: 2,
			
			damage: 25,
			hitPoints: 50,
			speed: 50,
			worth: 0,
			
			phase: 0,
			phaseInit: false,
			
			moveChangeElapsed: 0,
			moveChangeDelay: 2000,

			soundAttacks: "sandworm_attacks",
			soundDamage: "goblin_damage",
			soundDies: "sandworm_dies",

			lootTable: [
				{type: null, weight: 4},
				{type: "item_chest", weight: 2},
				{type: "WEAPON_DROP", weight: 2},
				{type: "item_food", weight: 2}
			],
			
			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.dirtTimer = new horde.Timer();
				this.attackTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				switch (this.phase) {
									
					case 0:
						if (!this.phaseInit) {
							this.speed = 50;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseTimer.start(horde.randomRange(5000, 10000));
							this.dirtTimer.start(150);
							this.phaseInit = true;
						}
						this.dirtTimer.update(elapsed);
						if (this.position.y <= 50) {
							this.setDirection(horde.directions.toVector(horde.directions.DOWN));
						} else {
							movementTypes.wander.apply(this, arguments);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						if (this.dirtTimer.expired()) {
							engine.spawnObject(this, "e_dirt_pile");
							this.dirtTimer.reset();
						}
						break;
						
					case 1:
						// spawn!
						if (!this.phaseInit) {
							this.stopMoving();
							this.speed = 0;
							this.removeState(horde.Object.states.INVISIBLE);
							this.addState(horde.Object.states.SPAWNING);
							this.spawnFrameIndex = 0;
							this.phaseInit = true;
						}
						if (!this.hasState(horde.Object.states.SPAWNING)) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
						
					case 2:
						// fire globs of shit
						if (!this.phaseInit) {
							this.phaseAttacks = 0;
							this.phaseInit = true;
							this.attackTimer.start(200);
						}
						this.attackTimer.update(elapsed);
						if (this.phaseAttacks < 1 && this.attackTimer.expired()) {
							this.phaseAttacks++;
							//this.chase(engine.getPlayerObject());
							this.setDirection(horde.randomDirection());
							engine.spawnObject(this, "e_worm_spit");
							horde.sound.play(this.soundAttacks);
							this.attackTimer.reset();
							if (this.phaseAttacks === 1) {
								this.phaseTimer.start(2000);
							}
						}
						if (this.phaseAttacks >= 1 && this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
						
					case 3:
						// burrow!
						if (!this.phaseInit) {
							this.addState(horde.Object.states.DESPAWNING);
							this.spawnFrameIndex = 2;
							this.phaseInit = true;
						}
						if (!this.hasState(horde.Object.states.DESPAWNING)) {
							this.addState(horde.Object.states.INVISIBLE);
							this.phase = 0;
							this.phaseInit = false;
						}
						break;

				}
			}
			
		};

		o.doppelganger = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			spriteSheet: "characters",
			spriteY: 0,
			spriteY: 768,
			spriteYOverlay: 928,

			damage: 20,
			hitPoints: 5000,
			speed: 200,

			soundAttacks: "dopp_attacks",
			soundDamage: "dopp_damage",
			soundDies: "dopp_dies",
			
			// Clay.io
			achievementId: "defeatdoppelganger",
			deathsForAchievement: 1,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
			},

			onKilled: function (attacker, engine) {
				for (var id in engine.objects) {
					var obj = engine.objects[id];
					if (obj.role === "monster" && obj.id !== this.id) {
						obj.wound(obj.hitPoints);
					} else if (obj.role === "trap") {
						obj.ttl = 1500;
					}
				}
			},

			onUpdate: function (elapsed, engine) {

				switch (this.phase) {

					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 300;
							this.animDelay = 100;
							this.phaseInit = true;
						}
						if (this.position.y > 100) {
							this.nextPhase();
						}
						break;

					// Dash to first waypoint
					case 1:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.waypoints = this.getPattern();
							this.currentWaypoint = this.waypoints.shift();
							this.phaseInit = true;
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							this.nextPhase();
						}
						break;

					// Shake
					case 2:
						if (!this.phaseInit) {
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseTimer.start(500);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;

					// Follow waypoints dropping spikes
					case 3:
						if (!this.phaseInit) {
							this.currentWaypoint = this.waypoints.shift();
							this.speed = 400;
							this.animDelay = 100;
							this.phaseInit = true;
							this.spikeTimer = new horde.Timer();
							this.spikeTimer.start(200);
						}
						this.spikeTimer.update(elapsed);
						if (this.spikeTimer.expired()) {
							horde.sound.play("spike_attack");
							var id = engine.spawnObject(this, "spikes");
							var o = engine.objects[id];
							if (o) {
								o.ttl = 10000;
							}
							this.spikeTimer.reset();
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							if (this.waypoints.length > 0) {
								this.currentWaypoint = this.waypoints.shift();
							} else {
								this.nextPhase();
							}
						}
						break;

					// Chase hero slowly
					case 4:
						if (!this.phaseInit) {
							this.speed = 100;
							this.animDelay = 200;
							this.phaseTimer.start(7500);
							this.phaseInit = true;
						}
						var player = engine.getPlayerObject();
						if (player.wounds < player.hitPoints) {
							this.chase(player);
						}
						// TODO: Shoot swords
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;

					// Dash to upper left
					case 5:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.phaseInit = true;
							this.targetPos = new horde.Vector2(32, 66);
						}
						this.moveToward(this.targetPos);
						var diff = this.targetPos.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.targetPos.clone();
							this.nextPhase();
						}
						break;

					// Summon spike walls and shoot spears
					case 6:
						if (!this.phaseInit) {
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseInit = true;
							this.makeSpikeWalls(engine);
							this.weapons = [{type: "e_dopp_sword", count: null}];
						}
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						this.chase(engine.getPlayerObject());
						this.stopMoving();
						if (this.wounds > (this.hitPoints * 0.33)) {
							// 2/3 HP (or lower)
							return "shoot";
						}
						break;

					// Chill out for a bit
					case 7:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseTimer.start(4000);
							this.phaseInit = true;
						}
						if (this.phaseTimer.expired()) {
							// Poop out a meat...
							var meat = horde.makeObject("item_food");
							meat.position.x = 32;
							meat.position.y = 64;
							engine.addObject(meat);
							this.nextPhase();
						}
						break;

					// Wander throwing battle axes
					case 8:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.weapons = [{type: "e_dopp_axe", count: null}];
							this.cooldown = false;
							this.waypoints = this.getPattern();
							this.currentWaypoint = this.waypoints.shift();
							this.axeTimer = new horde.Timer();
							this.axeTimer.start(3000);
							this.axeTimer.update(3000);
							this.phaseInit = true;
						}
						this.axeTimer.update(elapsed);
						if (this.axeTimer.expired()) {
							this.chase(engine.getPlayerObject());
							engine.spawnObject(this, "e_dopp_axe");
							this.axeTimer.reset();
						}
						this.moveToward(this.currentWaypoint);
						var diff = this.currentWaypoint.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.currentWaypoint.clone();
							if (this.waypoints.length > 0) {
								this.currentWaypoint = this.waypoints.shift();
							} else {
								this.nextPhase();
							}
						}
						break;

					// Dash to center
					case 9:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 200;
							this.phaseInit = true;
							this.targetPos = new horde.Vector2((640 / 2) - 16, (480 / 2) - 16);
						}
						this.moveToward(this.targetPos);
						var diff = this.targetPos.clone().subtract(this.position).abs().magnitude();
						if (diff < 10) {
							this.position = this.targetPos.clone();
							this.nextPhase();
						}
						break;

					// Spawn some shit...
					case 10:
						if (!this.phaseInit) {
							horde.sound.play("minotaur_dies");
							this.setDirection(new horde.Vector2(0, 1));
							this.stopMoving();
							this.phaseInit = true;
							for (var b = 0; b < 60; ++b) {
								var id = engine.spawnObject(this, "dire_bat");
								var o = engine.objects[id];
								o.setDirection(horde.randomDirection());
								o.addState(horde.Object.states.INVINCIBLE, 250);
							}
							this.phaseTimer.start(8000);
						}
						if (this.phaseTimer.expired()) {
							this.setPhase(1);
						}
						break;

				}

			},

			getPattern: function () {
				switch (horde.randomRange(1, 3)) {

					// Spiral
					case 1:
						return [
							new horde.Vector2(64, 320),
							new horde.Vector2(64, 96),
							new horde.Vector2(544, 96),
							new horde.Vector2(544, 320),
							new horde.Vector2(128, 320),
							new horde.Vector2(128, 160),
							new horde.Vector2(480, 160),
							new horde.Vector2(480, 256),
							new horde.Vector2(192, 256)
						];
						break;
					
					// Snake
					case 2:
						return [
							new horde.Vector2(576, 352),
							new horde.Vector2(32, 352),
							new horde.Vector2(32, 288),
							new horde.Vector2(576, 288),
							new horde.Vector2(576, 224),
							new horde.Vector2(32, 224),
							new horde.Vector2(32, 160),
							new horde.Vector2(576, 160),
							new horde.Vector2(576, 96),
							new horde.Vector2(32, 96)
						];
						break;

					// Hourglass
					case 3:
						return [
							new horde.Vector2(576, 64),
							new horde.Vector2(32, 64),
							new horde.Vector2(288, 192),
							new horde.Vector2(32, 352),
							new horde.Vector2(576, 352),
							new horde.Vector2(352, 224),
							new horde.Vector2(576, 64)
						];
						break;

				}
			},

			makeSpikeWalls: function (engine) {

				horde.sound.play("wizard_reappear");

				var safeSpots = 3;
				var spinUpTime = 5000;
				var wallSpeedMod = 2;

				if (this.wounds > (this.hitPoints * 0.66)) {
					// 1/3 HP (or lower)
					safeSpots = 1;
					spinUpTime = 5000;
					wallSpeedMod = 2;
				} else if (this.wounds > (this.hitPoints * 0.33)) {
					// 2/3 HP (or lower)
					safeSpots = 2;
					spinUpTime = 7500;
					wallSpeedMod = 1.5;
				}

				this.phaseTimer.start(spinUpTime - 1500);

				// Make top wall
				var spike = [];
				for (var a = 0; a < 18; ++a) {
					spike.push(true);
				}

				for (var j = 0; j < safeSpots; ++j) {
					var c = 0;
					var found = false;
					while (found === false) {
						c = horde.randomRange(3, (spike.length - 1));
						found = (spike[c] === true);
					}
					spike[c] = false;
				}

				for (var x = 0; x < spike.length; ++x) {
					if (spike[x] === true) {
						var obj = horde.makeObject("spike_wall");
						obj.position = new horde.Vector2(32 + (x * 32), 64);
						obj.spinUpTime = spinUpTime;
						obj.speed *= wallSpeedMod;
						engine.addObject(obj);
					}
				}

				// Make left wall
				var spike = [];
				for (var a = 0; a < 10; ++a) {
					spike.push(true);
				}

				for (var j = 0; j < safeSpots; ++j) {
					var c = 0;
					var found = false;
					while (found === false) {
						c = horde.randomRange(3, (spike.length - 1));
						found = (spike[c] === true);
					}
					spike[c] = false;
				}

				for (var x = 0; x < spike.length; ++x) {
					if (spike[x] === true) {
						var obj = horde.makeObject("spike_wall");
						obj.position = new horde.Vector2(32, 64 + (x * 32));
						obj.wallDirection = new horde.Vector2(1, 0);
						obj.spinUpTime = spinUpTime;
						obj.speed = 275; // More ground to cover
						obj.speed *= wallSpeedMod;
						engine.addObject(obj);
					}
				}	

			}

		};

		o.e_dopp_axe = {
			role: "projectile",
			cooldown: 2500,
			speed: 250,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 700,
			priority: 5,
			ttl: 10000,
			soundAttacks: "dopp_attacks",

			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},

			onUpdate: function (elapsed, engine) {
				if (!engine.objectExists(this.ownerId)) {
					this.die();
				}
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "e_dopp_fire");
					this.spawnTimer.reset();
				}
			},
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dopp_sword = {
			role: "projectile",
			cooldown: 750,
			speed: 350,
			hitPoints: Infinity,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 544,
			spriteAlign: true,
			priority: 2,
			bounce: false,
			piercing: true,
			soundAttacks: "dopp_attacks",

			onInit: function () {
				this.spawnTimer = new horde.Timer();
				this.spawnTimer.start(50);
			},
			
			onUpdate: function (elapsed, engine) {
				this.spawnTimer.update(elapsed);
				if (this.spawnTimer.expired()) {
					engine.spawnObject(this, "e_dopp_fire");
					this.spawnTimer.reset();
				}
			},
			// Clay.io
			ignoreLogDeath: true
		};

		o.beholder = {
			role: "monster",
			team: 1,
			badass: true,

			size: new horde.Size(128, 128),
			spriteSheet: "beholder",
			animated: true,
			animDelay: 350,
			drawIndex: 3,

			damage: 30,
			hitPoints: 3000,
			speed: 50,

			//soundAttacks: "_attacks",
			soundDamage: "beholder_damage",
			soundDies: "beholder_dies",
			
			// Clay.io
			achievementId: "defeatbeholder",
			deathsForAchievement: 1,

			collidable: false,

			lootTable: [
				{type: "item_weapon_fire_sword", weight: 1}
			],

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.attackTimer = new horde.Timer();
				this.eyeletOffset = 100;
				this.eyeletOffsetMod = 1;
				this.enraged = false;
			},

			onUpdate: function (elapsed, engine) {

				this.attackTimer.update(elapsed);
				if (this.attackTimer.expired()) {
					horde.sound.play("wizard_attacks");

					var id = engine.spawnObject(this, "e_energy_ball");
					var o = engine.objects[id];
					o.chase(engine.getPlayerObject());
					this.attackTimer.reset();
				}

				this.eyeletOffset += (((20 / 1000) * elapsed) * this.eyeletOffsetMod);
				if (this.eyeletOffset > 120) {
					this.eyeletOffsetMod = -1;
				}
				if (this.eyeletOffset < 100) {
					this.eyeletOffsetMod = 1;
				}

				if (this.wounds > (this.hitPoints / 2) && !this.enraged) {
					this.enraged = true;
					this.speed *= 1.5;
					this.animDelay /= 2;
					this.attackTimer.start(2000);
				}

				switch (this.phase) {

					// Charge out of the gates (invisible)
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.addState(horde.Object.states.INVISIBLE);
							this.phaseInit = true;
						}
						if (this.position.y >= 70) {
							this.nextPhase();
						}
						break;

					// Phase in
					case 1:
						if (!this.phaseInit) {
							horde.sound.play("wizard_reappear");
							this.speed = 50;
							this.removeState(horde.Object.states.INVISIBLE);
							this.addState(horde.Object.states.INVINCIBLE);
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						movementTypes.wander.apply(this, arguments);
						if (this.phaseTimer.expired()) {
							this.attackTimer.start(4000);
							this.nextPhase();
						}
						break;

					// Wander and spawn X eyelets (now attackable)
					case 2:
						if (!this.phaseInit) {
							this.removeState(horde.Object.states.INVINCIBLE);
							this.collidable = true;
							this.eyeletTimer = new horde.Timer();
							this.eyeletTimer.start(500);
							this.eyeletsSpawned = 0;
							this.phaseInit = true;
						}
						this.eyeletTimer.update(elapsed);
						movementTypes.wander.apply(this, arguments);
						if (this.eyeletTimer.expired()) {
							horde.sound.play("wizard_reappear");

							this.eyeletTimer.reset();
							var id = engine.spawnObject(this, "eyelet");
							if (this.wounds > (this.hitPoints / 2)) {
								var o = engine.objects[id];
								o.makeBadass();
							}
							++this.eyeletsSpawned;
							if (this.eyeletsSpawned >= 12) {
								this.nextPhase();
							}
						}
						break;

					case 3:
						if (!this.phaseInit) {
							this.phaseTimer.start(20000);
							this.phaseInit = true;
						}
						var hasEyelets = false;
						for (var id in engine.objects) {
							if (engine.objects[id].ownerId === this.id) {
								hasEyelets = true;
								break;
							}
						}
						if (this.phaseTimer.expired() || !hasEyelets) {
							this.nextPhase();
						}
						movementTypes.wander.apply(this, arguments);
						break;

					// Shake
					case 4:
						if (!this.phaseInit) {
							this.stopMoving();
							this.phaseTimer.start(2000);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-2, 2);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					// Shit some gas clouds
					case 5:
						for (var n = 0; n < 2; ++n) {
							engine.spawnObject(this, "gas_cloud");
						}
						this.nextPhase();
						break;

					case 6:
						if (!this.phaseInit) {
							this.oldSpeed = this.speed;
							this.speed = 250;
							this.oldAnimDelay = this.animDelay;
							this.animDelay = 100;
							this.chase(engine.getPlayerObject());
							this.phaseTimer.start(1000); // Must charge for at least 1s
							this.phaseInit = true;
						}
						break;

				}	
			},

			onWallCollide: function () {
				if (this.phase === 6 && this.phaseTimer.expired()) {
					this.speed = this.oldSpeed;
					this.animDelay = this.oldAnimDelay;
					this.setPhase(2);
				}
			}

		};

		o.gas_cloud = {
			role: "trap",
			team: 1,

			animated: true,
			size: new horde.Size(128, 128),
			spriteSheet: "characters",
			spriteX: 640,
			spriteY: 416,
			drawIndex: 2,
			animDelay: 400,

			damage: 20,
			hitPoints: 9999,
			speed: 10,
			ttl: 90000,
			
			damageType: "magic",

			onInit: function () {
				this.setDirection(horde.randomDirection());
				this.moveChangeDelay = horde.randomRange(5000, 10000);
			},

			onUpdate: function (elasped, engine) {
				if (this.animFrameIndex === 2) {
					this.animated = false;
					this.spriteX = 896;
				}
				if (
					this.team === 1
					&& !engine.objects[this.ownerId]
					&& (this.ttl - this.ttlElapsed > 2000)
				) {
					this.ttlElapsed = (this.ttl - 2000);
				}
				movementTypes.wander.apply(this, arguments);
			},

			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
				if (this.team !== 3 && object.damageType == "magic") {
					horde.sound.play("fire_attack");
					this.ownerId = null;
					this.team = 3;
					this.damage = 5;
					this.ttl = 2000;
					this.ttlElapsed = 0;
					this.spriteY += 224;
					this.animDelay = 500;
					this.animFrameIndex = 0;
					this.animNumFrames = 3;
				}
			}

		};

		o.dragon = {
			role: "monster",
			team: 1,
			badass: true,

			animated: true,
			gibletSize: "large",
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteY: 352,

			moveChangeElapsed: 0,
			moveChangeDelay: 0,

			damage: 20,
			hitPoints: 1000,
			speed: 20,
			worth: 0,

			soundAttacks: "dragon_attacks",
			soundDamage: "dragon_damage",
			soundDies: "dragon_dies",
			
			// Clay.io
			achievementId: "defeatdragon",
			deathsForAchievement: 1,

			weapons: [{type: "e_fireball", count: null}],

			lootTable: [
				{type: "item_gold_chest", weight: 1}
			],

			phase: 0,
			phaseInit: false,

			onInit: function () {
				this.phaseTimer = new horde.Timer();
				this.moveChangeDelay = horde.randomRange(500, 1000);
				this.setDirection(horde.directions.toVector(horde.directions.DOWN));
				this.altTimer = new horde.Timer();
			},
			onUpdate: function (elapsed, engine) {
				
				this.altTimer.update(elapsed);

				switch (this.phase) {
					
					// Charge out of the gates
					case 0:
						if (!this.phaseInit) {
							this.speed = 200;
							this.animDelay = 50;
							this.phaseInit = true;
						}
						if (this.position.y >= 200) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.animDelay = 300;
							this.phaseTimer.start(1000);
							this.phaseInit = true;
						}
						this.position.x += horde.randomRange(-1, 1);
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 2:
						if (!this.phaseInit) {
							this.cooldown = false;
							this.stopMoving();
							this.weapons = [{type: "e_ring_fire", count: null}];
							this.phaseInit = false;
						}
						engine.objectAttack(this);
						this.nextPhase();
						break;
					
					// Wiggle it!
					case 3:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animDelay = 100;
							this.phaseTimer.start(2000);
							this.phaseInit = true;
							this.altTimer.start(350);
							this.followUpShot = false;
						}
						if (!this.followUpShot && this.altTimer.expired()) {
							if (this.wounds > (this.hitPoints / 2)) {
								this.cooldown = false;
								this.weapons = [{type: "e_ring_fire_dopp", count: null}];
								engine.objectAttack(this);
								this.followUpShot = true;
							}
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						this.position.x += horde.randomRange(-1, 1);
						break;

					// Charge player
					case 4:
						if (!this.phaseInit) {
							this.speed = 350;
							this.animDelay = 100;
							this.phaseTimer.start(500);
							this.phaseInit = true;
							var p = engine.getPlayerObject();
							this.chase(p);
						}
						if (this.phaseTimer.expired()) {
							this.phase++;
							this.phaseInit = false;
						}
						break;
					
					// Stand still and spew flames!
					case 5:
						if (!this.phaseInit) {
							this.speed = 0;
							this.animDelay = 400;
							this.weapons = [{type: "e_fireball_green", count: null}];
							this.cooldown = false;
							this.cooldownElapsed = 0;
							this.phaseTimer.start(2500);
							this.phaseInit = true;
							this.altTimer.start(750);
						}
						if (this.phaseTimer.expired()) {
							this.phase = 2;
							this.phaseInit = false;
						}
						var p = engine.getPlayerObject();
						this.chase(p);
						if (this.altTimer.expired() && this.wounds > (this.hitPoints / 2)) {
							engine.spawnObject(this, "e_fireball");
							this.altTimer.reset();
							// I don't know why this sound won't play. I give up.
							//horde.sound.play(this.soundAttacks);
						}

						return "shoot";
				}

			}

		};

		// ENEMY WEAPONS

		o.e_arrow = {
			role: "projectile",
			cooldown: 4000,
			speed: 200,
			hitPoints: 1,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 256,
			spriteY: 0,
			spriteAlign: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_trident = {
			role: "projectile",
			cooldown: 5000,
			speed: 200,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 0,
			spriteAlign: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_boulder = {
			role: "projectile",
			cooldown: 2000,
			speed: 150,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 0,
			rotate: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_bouncing_boulder = {
			role: "projectile",
			cooldown: 1500,
			speed: 150,
			hitPoints: Infinity,
			damage: 15,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 0,
			rotate: true,
			bounce: true,
			ttl: 5000,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_minotaur_trident = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 20,
			spriteAlign: true,
			spriteSheet: "objects",
			spriteX: 160,
			spriteY: 0,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_energy_ball = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 320,
			spriteY: 0,
			rotate: true,
			bounce: false,
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_ring_fire = {
			role: "projectile",
			cooldown: 2000,
			speed: 200,
			hitPoints: Infinity,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 0,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_ring_fire_dopp = {
			role: "projectile",
			cooldown: 2000,
			speed: 150,
			hitPoints: Infinity,
			damage: 25,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 544,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_fireball = {
			role: "projectile",
			cooldown: 2000,
			speed: 350,
			hitPoints: Infinity,
			damage: 20,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 544,
			rotate: true,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_fireball_green = {
			role: "projectile",
			cooldown: 75,
			speed: 350,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 352,
			spriteY: 0,
			rotate: true,
			ttl: 400,
			bounce: false,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_static_blue_fire = {
			role: "projectile",
			cooldown: 100,
			speed: 0,
			hitPoints: Infinity,
			damage: 5,
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 100,
			ttl: 1000,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dopp_fire = {
			role: "projectile",
			cooldown: 200,
			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 32,
			rotate: true,
			rotateSpeed: 200,
			ttl: 250,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_static_green_fire = {
			role: "projectile",
			cooldown: 200,
			speed: 0,
			hitPoints: Infinity,
			damage: 10,
			size: new horde.Size(64, 64),
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 192,
			rotate: true,
			rotateSpeed: 150,
			ttl: 2000,
			bounce: false,
			drawIndex: 0,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_dirt_pile = {
			role: "trap",
			cooldown: 100,
			speed: 0,
			hitPoints: Infinity,
			damage: 0,
			spriteSheet: "characters",
			spriteX: 0,
			spriteY: 448,
			//animated: true,
			ttl: 3000,
			bounce: false,
			drawIndex: -2,
			
			onInit: function () {
				if (horde.randomRange(1, 10) > 5) {
					this.spriteX += 32;
				}
			},
			
			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		o.e_spit_pool = {
			role: "trap",
			cooldown: 100,
			speed: 0,
			hitPoints: 9999,
			damage: 5,
			size: new horde.Size(64, 64),
			spriteSheet: "characters",
			spriteX: 896,
			spriteY: 416,
			animated: true,
			ttl: 7500,
			bounce: false,
			drawIndex: -1,
			collidable: false,
			
			onObjectCollide: function (object, engine) {
				if (object.team !== this.team && object.role !== "projectile") {
					object.addState(horde.Object.states.SLOWED, 300);
				}
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		o.e_shock_wave = {
			role: "projectile",
			cooldown: 1000,
			speed: 200,
			hitPoints: Infinity,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 224,
			spriteY: 32,
			spriteAlign: true,
			bounce: false,
			animated: true,
			damageType: "magic",
			// Clay.io
			ignoreLogDeath: true
		};

		o.e_worm_spit = {
			role: "projectile",
			cooldown: 1000,
			speed: 200,
			hitPoints: 1,
			damage: 10,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 64,
			spriteAlign: true,
			bounce: false,
			animated: true,
			damageType: "magic",

			onInit: function () {
				this.dieTimer = new horde.Timer();
				this.dieTimer.start(1000);
			},
			
			onUpdate: function (elapsed, engine) {
				this.dieTimer.update(elapsed);
				if (this.dieTimer.expired()) {
					this.die();
				}
			},
			
			onDelete: function (engine) {
				engine.spawnObject(this, "e_spit_pool");
			},
			// Clay.io
			ignoreLogDeath: true
			
		};

		// OTHER SHIT

		o.mini_heart = {
			role: "fluff",
			spriteSheet: "objects",
			spriteX: 288,
			spriteY: 128,
			size: new horde.Size(10, 10),
			ttl: 600,
			speed: 75,
			collidable: false,
			drawIndex: 5,
			onInit: function () {
				this.setDirection(new horde.Vector2(0, -1));
				this.speed = horde.randomRange(55, 85);
			}
		};

		o.mini_skull = {
			role: "fluff",
			spriteSheet: "objects",
			spriteX: 288 + 32,
			spriteY: 128,
			size: new horde.Size(10, 10),
			ttl: 1300,
			collidable: false,
			drawIndex: 5,
			onInit: function () {
				this.setDirection(new horde.Vector2(0, -1));
				this.speed = horde.randomRange(25, 60);
			}
		};

		o.rose = {
			
			role: "fluff",
			spriteSheet: "objects",
			collidable: false,
			rotate: true,
			
			spriteX: 192,
			spriteY: 256,
			
			drawIndex: -1,
			
			onInit: function () {
				this.speed = horde.randomRange(150, 200);
				this.rotateSpeed = horde.randomRange(75, 100);
				this.phaseTimer = new horde.Timer();
			},
			
			onUpdate: function (elapsed, engine) {
				
				switch (this.phase) {
					
					case 0:
						if (!this.phaseInit) {
							this.phaseInit = true;
							var rnd = horde.randomRange(0, 5);
							this.direction.y = -(rnd / 10);
							this.phaseTimer.start(horde.randomRange(500, 1750));
						}
						this.direction.y += 0.01;
						if (this.phaseTimer.expired()) {
							this.nextPhase();
						}
						break;
					
					case 1:
						if (!this.phaseInit) {
							this.stopMoving();
							this.rotate = false;
							this.phaseInit = true;
						}
						break;
					
				}
				
			}
			
		};

		o.cloud = {
			
			role: "fluff",
			spriteSheet: "objects",
			collidable: false,
			
			drawIndex: 10,
			
			onInit: function () {
				
				this.alpha = 0.25;
				this.speed = horde.randomRange(5, 25);
				this.size = new horde.Size(192, 128);
				
				switch (horde.randomRange(1, 4)) {
					
					case 1:
						this.spriteX = 0;
						this.spriteY = 288;
						break;

					case 2:
						this.size = new horde.Size(128, 96);
						this.spriteX = 192;
						this.spriteY = 288;
						break;

					case 3:
						this.spriteX = 0;
						this.spriteY = 416;
						break;
						
					case 4:
						this.size = new horde.Size(160, 128);
						this.spriteX = 192;
						this.spriteY = 416;
						break;
				}
				
			}
			
		};

		// GATE

		o.gate = {
			role: "fluff",
			speed: 25,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 192,
			size: new horde.Size(64, 64)
		};

		o.pickup_arrow = {
			role: "fluff",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 608,
			size: new horde.Size(118, 52),
			drawIndex: 9,
			animated: true
		};

		// FOOD (Eat Meat!)

		o.item_food = {
			role: "powerup_food",
			healAmount: 10,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 32,
			ttl: 8000
		};

		// GOLD (Collect Gold!)

		o.item_coin = {
			role: "powerup_coin",
			coinAmount: 100,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 64,
			spriteY: 32,
			ttl: 5000
		};

		o.item_chest = {
			role: "powerup_coin",
			coinAmount: 500,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 32,
			ttl: 5000
		};

		o.item_gold_chest = {
			role: "powerup_coin",
			coinAmount: 5000,
			speed: 0,
			spriteSheet: "objects",
			spriteX: 0,
			spriteY: 32
		};

		// WEAPON POWERUPS

		o.item_weapon_knife = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 32,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_knife",
			wepCount: 125
		};

		o.item_weapon_spear = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 96,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_spear",
			wepCount: 100
		};

		o.item_weapon_fireball = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_fireball",
			wepCount: 100
		};

		/*
		o.item_weapon_bomb = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 128,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_bomb",
			wepCount: 10
		};
		*/

		o.item_weapon_axe = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 192,
			spriteY: 32,
			ttl: 5000,
			wepType: "h_axe",
			wepCount: 75
		};

		o.item_weapon_fire_sword = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			wepType: "h_fire_sword",
			wepCount: 5000
		};

		/*
		o.item_weapon_fire_knife = {
			role: "powerup_weapon",
			speed: 0,
			spriteSheet: "objects",
			spriteX: 384,
			spriteY: 0,
			ttl: 5000,
			wepType: "h_fire_knife",
			wepCount: 1000
		};
		*/

		}());


		(function define_horde_ImageLoader () {

			horde.ImageLoader = function horde_ImageLoader () {
				this.images = {};
				this.numLoaded = 0;
				this.numImages = 0;
			};
				
			var proto = horde.ImageLoader.prototype;

			proto.load = function horde_Loader_proto_loadImages (images, fn, context) {
				this.callback = function horde_Loader_proto_loadImages_anon () {
					fn.call(context);
				};
				for (var key in images) {
					this.numImages++;
					this.images[key] = new Image();
					horde.on("load", this.handleImageLoad, this.images[key], this);
					horde.on("error", this.handleImageError, this.images[key], this);
					this.images[key].src = images[key];
				}
			};

			proto.increment = function horde_ImageLoader_proto_increment () {
				this.numLoaded++;
				if (this.numLoaded >= this.numImages) {
					this.callback();
				}
			};

			proto.handleImageLoad = function horde_ImageLoader_proto_handleImageLoad (e) {
				this.increment();
			};

			proto.handleImageError = function horde_ImageLoader_proto_handleImageError (e) {
				this.increment();
			};

			proto.getImage = function horde_ImageLoader_proto_getImage (key) {
				if (this.images[key]) {
					return this.images[key];
				}
				return false;
			};

			}());

		(function define_horde_SpawnPoint () {

			/**
			 * Spawn Point object; holds a queue of objects and spawns them at various intervals
			 * @param {number} left Left coordinate of the spawn location
			 * @param {number} top Top coordinate of the spawn location
			 * @param {number} width Width of the spawn location
			 * @param {number} height Height of the spawn location
			 * @constructor
			 */
			horde.SpawnPoint = function horde_SpawnPoint (left, top, width, height) {
				this.delay = 500; // Default delay between spawns
				this.lastSpawnElapsed = 0; // Milliseconds since last spawn
				this.location = new horde.Rect(left, top, width, height); // Spawn point location
				this.queue = []; // Queue of things to spawn
			};

			var proto = horde.SpawnPoint.prototype;

			/**
			 * Updates this spawn point
			 * @param {number} elapsed Elapsed time in milliseconds since last update
			 * @return {mixed} Returns an object to spawn if necessary otherwise false
			 */
			proto.update = function horde_SpawnPoint_proto_update (elapsed, force) {
				this.lastSpawnElapsed += elapsed;
				if (this.lastSpawnElapsed >= this.delay || force === true) {
					this.lastSpawnElapsed = 0;
					if (this.queue.length < 1) {
						return false;
					}
					var type = this.queue.shift();
					var loc = this.location
					var o = horde.makeObject(type);
					o.position.x = horde.randomRange(loc.left, loc.left + loc.width - o.size.width);
					o.position.y = horde.randomRange(loc.top, loc.top + loc.height - o.size.height);
					var d = o.direction.clone();
					d.y = 1;
					o.setDirection(d);
					return o;
				}
				return false;
			};

			/**
			 * Adds a number of a given type of objects to this spawn point's queue
			 * @param {string} type Type of object to spawn
			 * @param {number} count Number of this type to add
			 * @return {void}
			 */
			proto.queueSpawn = function horde_SpawnPoint_proto_queueSpawn (type, count) {
				count = Number(count) || 1;
				for (var i = 0; i < count; i++) {
					this.queue.push(type);
				}
			};

			}());

		(function define_horde_SpawnWave () {

			horde.SpawnWave = function horde_SpawnWave () {
				this.points = [];
				this.nextWaveTime = 20000; // 20 seconds
				this.bossWave = false;
			};

			var proto = horde.SpawnWave.prototype;

			proto.addSpawnPoint = function horde_SpawnWave_proto_addSpawnPoint (index, spawnDelay) {
				this.points.push({
					spawnPointId: index,
					delay: spawnDelay,
					objects: []
				});
			};

			proto.addObjects = function horde_SpawnWave_proto_addObjects (id, objType, objCount) {
				var pt = null;
				for (var x in this.points) {
					if (this.points[x].spawnPointId === id) {
						pt = this.points[x];
					}
				}
				if (pt === null) {
					return false;
				}
				pt.objects.push({
					type: objType,
					count: Math.floor(objCount)
				});
			};

			}());

		(function () {
			var e = new horde.Engine();
			e.run();
		}());
        })


        let currentPage = 0;
         document.querySelector('#rightArrow').addEventListener('click', () => {  
            if (currentPage == 0) {
                currentPage += 1;
                document.querySelector('#spaceInvaders').style.display = 'none'
                document.querySelector('#frogger').style.display = 'none'
                document.querySelector('#mario').style.display = 'none'
                document.querySelector('#brickbreak').style.display = 'block'
                document.querySelector('#tetris').style.display = 'block'
                document.querySelector('#flappybird').style.display = 'none'

                
                document.querySelector('#snake').style.display = 'block'
                document.querySelector('#pacman').style.display = 'none'
                document.querySelector('#minesweeper').style.display = 'block'
                document.querySelector('#bubbletrouble').style.display = 'block'
                document.querySelector('#arenaOnslaught').style.display = 'none'
            } else {
                currentPage -= 1;
                document.querySelector('#spaceInvaders').style.display = 'block'
                document.querySelector('#frogger').style.display = 'block'
                document.querySelector('#mario').style.display = 'block'
                document.querySelector('#brickbreak').style.display = 'none'
                document.querySelector('#tetris').style.display = 'none'
                document.querySelector('#flappybird').style.display = 'block'

                
                document.querySelector('#snake').style.display = 'none'
                document.querySelector('#pacman').style.display = 'block'
                document.querySelector('#minesweeper').style.display = 'none'
                document.querySelector('#bubbletrouble').style.display = 'none'
                document.querySelector('#arenaOnslaught').style.display = 'block'
            }
            console.log(currentPage)
         })

          document.querySelector('#leftArrow').addEventListener('click', () => {  
            if (currentPage == 0) {
                currentPage += 1;
                document.querySelector('#spaceInvaders').style.display = 'none'
                document.querySelector('#frogger').style.display = 'none'
                document.querySelector('#mario').style.display = 'none'
                document.querySelector('#brickbreak').style.display = 'block'
                document.querySelector('#tetris').style.display = 'block'
                document.querySelector('#flappybird').style.display = 'none'

                
                document.querySelector('#snake').style.display = 'block'
                document.querySelector('#pacman').style.display = 'none'
                document.querySelector('#minesweeper').style.display = 'block'
                document.querySelector('#bubbletrouble').style.display = 'block'
                document.querySelector('#arenaOnslaught').style.display = 'none'
            } else {
                currentPage -= 1;
                document.querySelector('#spaceInvaders').style.display = 'block'
                document.querySelector('#frogger').style.display = 'block'
                document.querySelector('#mario').style.display = 'block'
                document.querySelector('#brickbreak').style.display = 'none'
                document.querySelector('#tetris').style.display = 'none'
                document.querySelector('#flappybird').style.display = 'block'

                
                document.querySelector('#snake').style.display = 'none'
                document.querySelector('#pacman').style.display = 'block'
                document.querySelector('#minesweeper').style.display = 'none'
                document.querySelector('#bubbletrouble').style.display = 'none'
                document.querySelector('#arenaOnslaught').style.display = 'block'
            }
            console.log(currentPage)
         })